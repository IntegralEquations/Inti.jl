<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Boundary integral operators · Inti.jl</title><meta name="title" content="Boundary integral operators · Inti.jl"/><meta property="og:title" content="Boundary integral operators · Inti.jl"/><meta property="twitter:title" content="Boundary integral operators · Inti.jl"/><meta name="description" content="Documentation for Inti.jl."/><meta property="og:description" content="Documentation for Inti.jl."/><meta property="twitter:description" content="Documentation for Inti.jl."/><meta property="og:url" content="https://IntegralEquations.github.io/Inti.jl/tutorials/integral_operators/"/><meta property="twitter:url" content="https://IntegralEquations.github.io/Inti.jl/tutorials/integral_operators/"/><link rel="canonical" href="https://IntegralEquations.github.io/Inti.jl/tutorials/integral_operators/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Inti.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../geo_and_meshes/">Geometry and meshes</a></li><li class="is-active"><a class="tocitem" href>Boundary integral operators</a><ul class="internal"><li><a class="tocitem" href="#Predefined-kernels-and-integral-operators"><span>Predefined kernels and integral operators</span></a></li></ul></li><li><a class="tocitem" href="../layer_potentials/">Layer potentials</a></li><li><a class="tocitem" href="../compression_methods/">Compression methods</a></li><li><a class="tocitem" href="../correction_methods/">Correction methods</a></li><li><a class="tocitem" href="../solvers/">Solvers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/generated/toy_example/">Toy example</a></li><li><a class="tocitem" href="../../examples/generated/helmholtz_scattering/">Helmholtz scattering</a></li><li><a class="tocitem" href="../../examples/generated/poisson/">Poisson solver</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../docstrings/">Docstrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Boundary integral operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Boundary integral operators</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl/blob/main/docs/src/tutorials/integral_operators.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Boundary-integral-operators"><a class="docs-heading-anchor" href="#Boundary-integral-operators">Boundary integral operators</a><a id="Boundary-integral-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-integral-operators" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Important points covered in this tutorial</header><div class="admonition-body"><ul><li>Define layer potentials and the four integral operators of Calderón calculus</li><li>Block operator construction and composition</li><li>Volume integral operators</li></ul></div></div><p>A central piece of integral equation methods is the efficient and accurate computation of integral operators. In the first part of this tutorial we will cover how to assemble and manipulate the four integral operators of Calderón calculus, namely the single-layer, double-layer, hypersingular, and adjoint operators [<a href="../../references/#nedelec2001acoustic">1</a>, <a href="../../references/#colton2013integral">2</a>], for some predefined kernels in Inti.jl. In the second part we will show how to extend the package to handle custom kernels.</p><h2 id="Predefined-kernels-and-integral-operators"><a class="docs-heading-anchor" href="#Predefined-kernels-and-integral-operators">Predefined kernels and integral operators</a><a id="Predefined-kernels-and-integral-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Predefined-kernels-and-integral-operators" title="Permalink"></a></h2><p>To simplify the construction of integral operators for some commonly used PDEs, Inti.jl defines a few <a href="../../docstrings/#Inti.AbstractPDE"><code>AbstractPDE</code></a>s types:</p><pre><code class="language-julia hljs">using Inti, StaticArrays, LinearAlgebra
subtypes(Inti.AbstractPDE)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Any}:
 Inti.Helmholtz
 Inti.Laplace
 Inti.Stokes</code></pre><p>For each of these PDEs, the package provides a <a href="../../docstrings/#Inti.SingleLayerKernel"><code>SingleLayerKernel</code></a>, <a href="../../docstrings/#Inti.DoubleLayerKernel"><code>DoubleLayerKernel</code></a>, <a href="../../docstrings/#Inti.HyperSingularKernel"><code>HyperSingularKernel</code></a>, and <a href="../../docstrings/#Inti.AdjointDoubleLayerKernel"><code>AdjointDoubleLayerKernel</code></a> that can be used to construct the corresponding kernel functions, e.g.:</p><pre><code class="language-julia hljs">pde = Inti.Helmholtz(; dim = 2, k = 1.2)
G   = Inti.SingleLayerKernel(pde)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Inti.SingleLayerKernel{ComplexF64, Inti.Helmholtz{2, Float64}}(Δu + k² u = 0)</code></pre><p>Typically, we are not interested in the kernels themselves, but in the integral operators they define. Two functions, <a href="../../docstrings/#Inti.single_double_layer-Tuple{}"><code>single_double_layer</code></a> and <a href="../../docstrings/#Inti.adj_double_layer_hypersingular-Tuple{}"><code>adj_double_layer_hypersingular</code></a>, are provided as a high-level syntax to construct the four integral operators of Calderón calculus:</p><pre><code class="language-julia hljs">Γ = Inti.parametric_curve(s -&gt; SVector(cos(s), sin(s)), 0, 2π) |&gt; Inti.Domain
Q = Inti.Quadrature(Γ; meshsize = 0.01, qorder = 5)
S, D = Inti.single_double_layer(;
    pde,
    target = Q,
    source = Q,
    compression = (method = :none,),
    correction = (method = :dim,)
)
K, N = Inti.adj_double_layer_hypersingular(;
    pde,
    target = Q,
    source = Q,
    compression = (method = :none,),
    correction = (method = :dim,)
)</code></pre><p>Much goes on under the hood in the function above, and the sections on <a href="../correction_methods/#Correction-methods">correction</a> and <a href="../compression_methods/#Compression-methods">compression</a> methods will provide more details on the options available. The important thing to keep in mind is that <code>S</code>, <code>D</code>, <code>K</code>, and <code>H</code> are discrete approximations of the following (linear) operators:</p><p class="math-container">\[\begin{aligned}
    S[\sigma](\boldsymbol{x}) &amp;:= \int_{\Gamma} G(\boldsymbol{x}, \boldsymbol{y}) \sigma(\boldsymbol{y}) \mathrm{d} s_{\boldsymbol{y}}, \quad 
    &amp;&amp;D[\sigma](\boldsymbol{x}) := \mathrm{p.v.} \int_{\Gamma} \frac{\partial G}{\partial \nu_{\boldsymbol{y}}}(\boldsymbol{x}, \boldsymbol{y}) \sigma(\boldsymbol{y}) \mathrm{d} s_{\boldsymbol{y}} \\
    D&#39;[\sigma](\boldsymbol{x}) &amp;:=  \mathrm{p.v.} \int_{\Gamma} \frac{\partial G}{\partial \nu_{\boldsymbol{x}}}(\boldsymbol{x}, \boldsymbol{y}) \sigma(\boldsymbol{y}) \mathrm{d} s_{\boldsymbol{y}}, \quad
    &amp;&amp;N[\sigma](\boldsymbol{x}) := \mathrm{f.p.} \int_{\Gamma} \frac{\partial^2 G}{\partial \nu_{\boldsymbol{x}} \partial \nu_{\boldsymbol{y}}}(\boldsymbol{x}, \boldsymbol{y}) \sigma(\boldsymbol{y}) \mathrm{d} s_{\boldsymbol{y}}
\end{aligned}\]</p><p>The actual type of <code>S</code>, <code>D</code>, <code>K</code>, and <code>H</code> depends on the <code>compression</code> and <code>correction</code> methods. In the simple case above, these are simply matrices:</p><pre><code class="language-julia hljs">map(typeof, (S, D, K, N))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Matrix{ComplexF64}, Matrix{ComplexF64}, Matrix{ComplexF64}, Matrix{ComplexF64})</code></pre><p>If we turn on a compression method, such as <code>:fmm</code>, the types may change into something different:</p><pre><code class="language-julia hljs">using FMM2D # will load the extension
Sfmm, Dfmm = Inti.single_double_layer(;
    pde,
    target = Q,
    source = Q,
    compression = (method = :fmm, tol = 1e-10),
    correction = (method = :dim, )
)
Kfmm, Nfmm = Inti.adj_double_layer_hypersingular(;
    pde,
    target = Q,
    source = Q,
    compression = (method = :fmm, tol = 1e-10),
    correction = (method = :dim,)
)
typeof(Sfmm)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinearMaps.LinearCombination{ComplexF64, Tuple{LinearMaps.FunctionMap{ComplexF64, IntiFMM2DExt.var&quot;#7#16&quot;{Float64, Bool, Vector{Float64}, Matrix{Float64}, Matrix{Float64}}, Nothing, true}, LinearMaps.WrappedMap{ComplexF64, SparseArrays.SparseMatrixCSC{ComplexF64, Int64}}}}</code></pre><p>This is because the FMM method is used to approximate the matrix-vector in a matrix-free way: the only thing <em>guaranteed</em> is that <code>S</code> and <code>D</code> can be applied to a vector:</p><pre><code class="language-julia hljs">x = rand(size(S,2))
norm(Sfmm*x - S*x, Inf)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.11066541794653399</code></pre><p>The <code>Sfmm</code> object above in fact combines two linear maps:</p><pre><code class="language-julia hljs">Sfmm</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3774×3774 LinearMaps.LinearCombination{ComplexF64} with 2 maps:
  3774×3774 LinearMaps.FunctionMap{ComplexF64,true}(#7; issymmetric=false, ishermitian=false, isposdef=false)
  3774×3774 LinearMaps.WrappedMap{ComplexF64} of
    3774×3774 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 22644 stored entries</code></pre><p>The <code>FunctionMap</code> computes a matrix-vector by performing a function call to the <code>FMM2D</code> library. The <code>WrappedMap</code> accounts for a sparse matrix used to account for singular and nearly singular interactions. These two objects are added lazily using <a href="https://github.com/JuliaLinearAlgebra/LinearMaps.jl">LinearMaps</a>.</p><p>Effortlessly and efficiently composing operators is a powerful abstraction for integral equations, as it allows for the construction of complex systems from simple building blocks. To show this, let us show how one may construct the Calderón projectors:</p><p class="math-container">\[\begin{aligned}
H = \begin{bmatrix}
    -D &amp; S \\
    -N &amp; D&#39;
\end{bmatrix} 
\end{aligned}\]</p><p>As is well-known [<a href="../../references/#nedelec2001acoustic">1</a>, Theorem 3.1.3], the operators <span>$C_\pm = I/2 \pm H$</span> are the projectors (i.e. <span>$C_{\pm}^2 = C_{\pm}$</span>):</p><pre><code class="language-julia hljs">using LinearMaps
H = [-Dfmm Sfmm; -Nfmm Kfmm]
C₊ = I / 2 + H
C₋ = I / 2 - H
u = map(q -&gt; cos(q.coords[1] + q.coords[2]), Q)
v = map(q-&gt; q.coords[1], Q)
x = [u; v]
e₊ = norm(C₊*(C₊*x) - C₊*x, Inf)
e₋ = norm(C₋*(C₋*x) - C₋*x, Inf)
println(&quot;projection error for C₊: $e₊&quot;)
println(&quot;projection error for C₋: $e₋&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">projection error for C₊: 2.9771260435034023e-8
projection error for C₋: 2.9771093010162426e-8</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../geo_and_meshes/">« Geometry and meshes</a><a class="docs-footer-nextpage" href="../layer_potentials/">Layer potentials »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 5 June 2024 16:01">Wednesday 5 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Helmholtz scattering · Inti.jl</title><meta name="title" content="Helmholtz scattering · Inti.jl"/><meta property="og:title" content="Helmholtz scattering · Inti.jl"/><meta property="twitter:title" content="Helmholtz scattering · Inti.jl"/><meta name="description" content="Documentation for Inti.jl."/><meta property="og:description" content="Documentation for Inti.jl."/><meta property="twitter:description" content="Documentation for Inti.jl."/><meta property="og:url" content="https://IntegralEquations.github.io/Inti.jl/examples/generated/helmholtz_scattering/"/><meta property="twitter:url" content="https://IntegralEquations.github.io/Inti.jl/examples/generated/helmholtz_scattering/"/><link rel="canonical" href="https://IntegralEquations.github.io/Inti.jl/examples/generated/helmholtz_scattering/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Inti.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../../tutorials/getting_started/">Getting started</a></li><li><a class="tocitem" href="../../../tutorials/geo_and_meshes/">Geometry and meshes</a></li><li><a class="tocitem" href="../../../tutorials/integral_operators/">Boundary integral operators</a></li><li><a class="tocitem" href="../../../tutorials/layer_potentials/">Layer potentials</a></li><li><a class="tocitem" href="../../../tutorials/compression_methods/">Compression methods</a></li><li><a class="tocitem" href="../../../tutorials/correction_methods/">Correction methods</a></li><li><a class="tocitem" href="../../../tutorials/solvers/">Solvers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../toy_example/">Toy example</a></li><li class="is-active"><a class="tocitem" href>Helmholtz scattering</a><ul class="internal"><li><a class="tocitem" href="#helmholtz-soundsoft"><span>Sound-soft problem</span></a></li><li><a class="tocitem" href="#helmholtz-scattering-2d"><span>Two-dimensional scattering</span></a></li><li><a class="tocitem" href="#helmholtz-scattering-3d"><span>Three-dimensional scattering</span></a></li></ul></li><li><a class="tocitem" href="../poisson/">Poisson solver</a></li></ul></li><li><a class="tocitem" href="../../../references/">References</a></li><li><a class="tocitem" href="../../../docstrings/">Docstrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Helmholtz scattering</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Helmholtz scattering</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl/blob/main/docs/src/examples/helmholtz_scattering.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="helmholtz_scattering"><a class="docs-heading-anchor" href="#helmholtz_scattering">Helmholtz scattering</a><a id="helmholtz_scattering-1"></a><a class="docs-heading-anchor-permalink" href="#helmholtz_scattering" title="Permalink"></a></h1><p><a href="../helmholtz_scattering.ipynb"><img src="https://img.shields.io/badge/download-ipynb-blue" alt="ipynb"/></a> <a href="https://nbviewer.jupyter.org/github/IntegralEquations/Inti.jl/blob/gh-pages/v0.1.0-alpha/examples/generated/helmholtz_scattering.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-blue.svg" alt="nbviewer"/></a></p><div class="admonition is-info"><header class="admonition-header">Important points covered in this example</header><div class="admonition-body"><ul><li>Creating a geometry using the <em>Gmsh</em> API</li><li>Assembling integral operators and integral potentials</li><li>Setting up a sound-soft problem in both 2 and 3 spatial dimensions</li><li>Using <em>GMRES</em> to solve the linear system</li><li>Exporting the solution to <em>Gmsh</em> for visualization</li></ul></div></div><p>In this tutorial we will show how to solve an acoustic scattering problem in the context of Helmholtz equation. We will focus on a <em>smooth</em> sound-soft obstacle for simplicity, and introduce along the way the necessary techniques used to handle some difficulties encountered. We will use various packages throughout this example (including of course <code>Inti.jl</code>); if they are not on your environment, you can install them using <code>] add &lt;package&gt;</code> in the REPL.</p><p>In the <a href="#helmholtz-soundsoft">following section</a>, we will provide a brief mathematical description of the problem (valid in both <span>$2$</span> and <span>$3$</span> dimensions). We will tackle the <a href="#helmholtz-scattering-2d">two-dimensional problem</a> first, for which we do not need to worry much about performance issues (e.g. compressing the integral operators, or exporting the solution to <em>Gmsh</em> for visualization). Finally, we present a <a href="#helmholtz-scattering-3d">three-dimensional example</a>, where we will use <a href="https://github.com/WaveProp/HMatrices.jl"><code>HMatrices.jl</code></a> to compress the underlying integral operators.</p><h2 id="helmholtz-soundsoft"><a class="docs-heading-anchor" href="#helmholtz-soundsoft">Sound-soft problem</a><a id="helmholtz-soundsoft-1"></a><a class="docs-heading-anchor-permalink" href="#helmholtz-soundsoft" title="Permalink"></a></h2><p>This example concerns the sound-soft acoustic scattering problem. Mathematically, this means solving an exterior problem governed by Helmholtz equation (time-harmonic acoustics) with a Dirichlet boundary condition. More precisely, letting <span>$\Omega \subset \mathbb{R}^d$</span> be a bounded domain, and denoting by <span>$\Gamma = \partial \Omega$</span> its boundary, we wish to solve</p><p class="math-container">\[    \Delta u + k^2 u = 0 \quad \text{on} \quad \mathbb{R}^d \setminus \bar{\Omega},\]</p><p>subject to Dirichlet boundary conditions on <span>$\Gamma$</span></p><p class="math-container">\[    u(\boldsymbol{x}) = g(\boldsymbol{x}) \quad \text{for} \quad \boldsymbol{x} \in \Gamma.\]</p><p>and the <em>Sommerfeld radiation condition</em> at infinity</p><p class="math-container">\[    \lim_{|\boldsymbol{x}| \to \infty} \|\boldsymbol{x}|^{(d-1)/2} \left( \frac{\partial u}{\partial |\boldsymbol{x}|} - i k u \right) = 0.\]</p><p>Here <span>$g$</span> is a (given) boundary datum, and <span>$k$</span> is the constant wavenumber.</p><p>For simplicity, we will take <span>$\Gamma$</span> circle/sphere, and focus on the <em>plane-wave scattering</em> problem. This means we will seek a solution <span>$u$</span> of the form <span>$u = u_s + u_i$</span>, where <span>$u_i$</span> is a known incident field, and <span>$u_s$</span> is the scattered field we wish to compute.</p><div class="admonition is-info"><header class="admonition-header">Complex geometries</header><div class="admonition-body"><p>The main reason for focusing on such a simple example is two-folded. First,   it alleviates the complexities associated with the mesh generation. Second,   since exact solutions are known for this problem (in the form of a series),   it is easy to assess the accuracy of the solution obtained. In practice, you   can use the same techniques to solve the problem on more complex geometries   by providing a <code>.msh</code> file containing the mesh.</p></div></div><p>Using the theory of boundary integral equations, we can express <span>$u_s$</span> as</p><p class="math-container">\[    u_s(\boldsymbol{r}) = \mathcal{D}[\sigma](\boldsymbol{r}) - i k \mathcal{S}[\sigma](\boldsymbol{r}),\]</p><p>where <span>$\mathcal{S}$</span> is the so-called single layer potential, <span>$\mathcal{D}$</span> is the double-layer potential, and <span>$\sigma : \Gamma \to \mathbb{C}$</span> is a surface density. This is an indirect formulation (because <span>$\sigma$</span> is an <em>auxiliary</em> density, not necessarily physical) commonly referred to as a <em>combined field formulation</em>. Taking the limit <span>$\mathbb{R}^d \setminus \bar \Omega \ni x \to \Gamma$</span>, it can be shown that the following equation holds on <span>$\Gamma$</span>:</p><p class="math-container">\[    \left( \frac{\mathrm{I}}{2} + \mathrm{D} - i k \mathrm{S} \right)[\sigma] = g,\]</p><p>where <span>$\mathrm{I}$</span> is the identity operator, and <span>$\mathrm{S}$</span> and <span>$\mathrm{D}$</span> are the single- and double-layer operators. This is the <strong>combined field integral equation</strong> that we will solve. The boundary data <span>$g$</span> is obtained by applying the sound-soft condition <span>$u=0$</span> on <span>$\Gamma$</span>, from which it readily follows that <span>$u_s = -u_i$</span> on <span>$\Gamma$</span>.</p><p>We are now have the necessary background to solve this problem in both 2 and 3 spatial dimensions. Let&#39;s load <code>Inti.jl</code> and setup some of the (global) problem parameters:</p><pre><code class="language-julia hljs">using Inti

k        = 4π
λ        = 2π / k
meshsize = λ / 5
qorder   = 4 # quadrature order
gorder   = 2 # order of geometrical approximation</code></pre><h2 id="helmholtz-scattering-2d"><a class="docs-heading-anchor" href="#helmholtz-scattering-2d">Two-dimensional scattering</a><a id="helmholtz-scattering-2d-1"></a><a class="docs-heading-anchor-permalink" href="#helmholtz-scattering-2d" title="Permalink"></a></h2><p>We use <a href="https://gmsh.info/doc/texinfo/gmsh.html#Gmsh-application-programming-interface">Gmsh API</a> for creating <code>.msh</code> file containing the desired geometry and mesh. Here is a function to mesh the circle:</p><pre><code class="language-julia hljs">using Gmsh # this will trigger the loading of Inti&#39;s Gmsh extension

function gmsh_circle(; name, meshsize, order = 1, radius = 1, center = (0, 0))
    try
        gmsh.initialize()
        gmsh.model.add(&quot;circle-mesh&quot;)
        gmsh.option.setNumber(&quot;Mesh.MeshSizeMax&quot;, meshsize)
        gmsh.option.setNumber(&quot;Mesh.MeshSizeMin&quot;, meshsize)
        gmsh.model.occ.addDisk(center[1], center[2], 0, radius, radius)
        gmsh.model.occ.synchronize()
        gmsh.model.mesh.generate(1)
        gmsh.model.mesh.setOrder(order)
        gmsh.write(name)
    finally
        gmsh.finalize()
    end
end</code></pre><p>Let us now use <code>gmsh_circle</code> to create a <code>circle.msh</code> file. As customary in wave-scattering problems, we will choose a mesh size that is proportional to wavelength:</p><pre><code class="language-julia hljs">name = joinpath(@__DIR__, &quot;circle.msh&quot;)
gmsh_circle(; meshsize, order = gorder, name)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Info    : Meshing 1D...
Info    : Meshing curve 1 (Ellipse)
Info    : Done meshing 1D (Wall 0.000211696s, CPU 0.000234s)
Info    : 63 nodes 64 elements
Info    : Meshing order 2 (curvilinear on)...
Info    : [  0%] Meshing curve 1 order 2
Info    : [ 50%] Meshing surface 1 order 2
Info    : Done meshing order 2 (Wall 0.00057868s, CPU 0.000578s)
Info    : Writing &#39;/home/lfaria/runner-integral-equations/_work/Inti.jl/Inti.jl/docs/build/examples/generated/circle.msh&#39;...
Info    : Done writing &#39;/home/lfaria/runner-integral-equations/_work/Inti.jl/Inti.jl/docs/build/examples/generated/circle.msh&#39;</code></pre><p>We can now import the file and parse the mesh and domain information into <code>Inti.jl</code> using the <a href="../../../docstrings/#Inti.import_mesh-Tuple"><code>import_mesh</code></a> function:</p><pre><code class="language-julia hljs">Inti.clear_entities!() # empty the entity cache
msh = Inti.import_mesh(name; dim = 2)
@show msh</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Inti.LagrangeMesh{2, Float64} containing:
	 63 elements of type Inti.LagrangeElement{Inti.ReferenceHyperCube{1}, 3, StaticArraysCore.SVector{2, Float64}}
	 1 elements of type StaticArraysCore.SVector{2, Float64}</code></pre><p>The code above will import the mesh with all of its geometrical entities. The <code>dim=2</code> projects all points to two dimensions by ignoring the third component. To extract the domain <span>$\Omega$</span> we need to filter the entities in the mesh; here we will simply filter them based on the <code>geometric_dimension</code>:</p><pre><code class="language-julia hljs">Ω = Inti.Domain(e -&gt; Inti.geometric_dimension(e) == 2, Inti.entities(msh))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Domain with 1 entity
 EntityKey: (2, 1) =&gt; Inti.GeometricEntity with labels String[]</code></pre><p>To solve our boundary integral equation usign a Nyström method, we actually need a quadrature of our curve/surface (and possibly the normal vectors at the quadrature nodes). Once a mesh is available, creating a quadrature object can be done via the <a href="../../../docstrings/#Inti.Quadrature"><code>Quadrature</code></a> constructor, which requires passing a mesh the domain that one wishes to generate a quadrature for:</p><pre><code class="language-julia hljs">Γ = Inti.boundary(Ω)
Γ_msh = view(msh, Γ)
Q = Inti.Quadrature(Γ_msh; qorder)</code></pre><div class="admonition is-success"><header class="admonition-header">Views of a mesh</header><div class="admonition-body"><p>In <code>Inti.jl</code>, you can use domain to create a <em>view</em> of a mesh containing <em>only   the elements in the domain</em>. For example <code>view(msh,Γ)</code> will return an   <code>SubMesh</code> type that you can use to iterate over the elements in the boundary   of the disk without actually creating a new mesh. You can use <code>msh[Γ]</code>,   or <code>collect(view(msh,Γ))</code> to create a new mesh containing <em>only</em> the   elements and nodes in <code>Γ</code>.</p></div></div><p>The object <code>Q</code> now contains a quadrature (of order <code>4</code>) that can be used to solve a boundary integral equation on <code>Γ</code>. As a sanity check, let&#39;s make sure integrating the function <code>x-&gt;1</code> over <code>Q</code> gives an approximation to the perimeter:</p><pre><code class="language-julia hljs">Inti.integrate(x -&gt; 1, Q) - 2π</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-6.470135849312442e-7</code></pre><p>With the <a href="../../../docstrings/#Inti.Quadrature"><code>Quadrature</code></a> constructed, we now can define discrete approximation to the integral operators <span>$\mathrm{S}$</span> and <span>$\mathrm{D}$</span> as follows:</p><pre><code class="language-julia hljs">pde = Inti.Helmholtz(; k, dim = 2)
S, D = Inti.single_double_layer(;
    pde,
    target = Q,
    source = Q,
    compression = (method = :none,),
    correction = (method = :dim,),
)</code></pre><p>There are two well-known difficulties related to the discretization of the boundary integral operators <span>$S$</span> and <span>$D$</span>:</p><ul><li>The kernel of the integral operator is not smooth, and thus specialized quadrature rules are required to accurately approximate the matrix entries for which the target and source point lie <em>close</em> (relative to some scale) to each other.</li><li>The underlying matrix is dense, and thus the storage and computational cost of the operator is prohibitive for large problems unless acceleration techniques such as <em>Fast Multipole Methods</em> or <em>Hierarchical Matrices</em> are employed.</li></ul><p><code>Inti.jl</code> tries to provide a modular and transparent interface for dealing with both of these difficulties, where the general approach for solving a BIE will be to first construct a (possible compressed) naive representation of the integral operator where singular and nearly-singular integrals are ignored, followed by a the creation of a (sparse) correction intended to account for such singular interactions. See <a href="../../../docstrings/#Inti.single_double_layer-Tuple{}"><code>single_double_layer</code></a> for more details on the various options available.</p><p>We can now combine <code>S</code> and <code>D</code> to form the combined-field operator:</p><pre><code class="language-julia hljs">using LinearAlgebra
L = I / 2 + D - im * k * S</code></pre><p>where <code>I</code> is the identity matrix. Assuming an incident field along the <span>$x_1$</span> direction of the form <span>$u_i =e^{ikx_1}$</span>, the right-hand side of the equation can be construted using:</p><pre><code class="language-julia hljs">uᵢ = x -&gt; exp(im * k * x[1]) # plane-wave incident field
rhs = map(Q) do q
    x = q.coords
    return -uᵢ(x)
end</code></pre><div class="admonition is-info"><header class="admonition-header">Iterating over a quadrature</header><div class="admonition-body"><p>In computing <code>rhs</code> above, we used <code>map</code> to evaluate the incident field at   all quadrature nodes. When iterating over <code>Q</code>, the iterator returns a   <a href="../../../docstrings/#Inti.QuadratureNode"><code>QuadratureNode</code></a>, and not simply the   <em>coordinate</em> of the quadrature node. This is so that you can access   additional information, such as the <code>normal</code> vector, at the quadrature node.</p></div></div><p>We can now solve the integral equation using e.g. the backslash operator:</p><pre><code class="language-julia hljs">σ = L \ rhs</code></pre><p>The variable <code>σ</code> contains the value of the approximate density at the quadrature nodes. To reconstruct a continuous approximation to the solution, we can use <a href="../../../docstrings/#Inti.single_double_layer_potential-Tuple{}"><code>single_double_layer_potential</code></a> to obtain the single- and double-layer potentials, and then combine them as follows:</p><pre><code class="language-julia hljs">𝒮, 𝒟 = Inti.single_double_layer_potential(; pde, source = Q)
uₛ   = x -&gt; 𝒟[σ](x) - im * k * 𝒮[σ](x)</code></pre><p>The variable <code>uₛ</code> is an anonymous/lambda function representing the approximate scattered field.</p><p>To assess the accuracy of the solution, we can compare it to the exact solution (obtained by separation of variables in polar coordinates):</p><pre><code class="language-julia hljs">using SpecialFunctions # for bessel functions

function circle_helmholtz_soundsoft(pt; radius = 1, k, θin)
    x = pt[1]
    y = pt[2]
    r = sqrt(x^2 + y^2)
    θ = atan(y, x)
    u = 0.0
    r &lt; radius &amp;&amp; return u
    c(n) = -exp(im * n * (π / 2 - θin)) * besselj(n, k * radius) / besselh(n, k * radius)
    u    = c(0) * besselh(0, k * r)
    n    = 1
    while (abs(c(n)) &gt; 1e-12)
        u +=
            c(n) * besselh(n, k * r) * exp(im * n * θ) +
            c(-n) * besselh(-n, k * r) * exp(-im * n * θ)
        n += 1
    end
    return u
end</code></pre><p>Here is the maximum error on some points located on a circle of radius <code>2</code>:</p><pre><code class="language-julia hljs">uₑ = x -&gt; circle_helmholtz_soundsoft(x; k, radius = 1, θin = 0) # exact solution
er = maximum(0:0.01:2π) do θ
    R = 2
    x = (R * cos(θ), R * sin(θ))
    return abs(uₛ(x) - uₑ(x))
end
@info &quot;maximum error = $er&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: maximum error = 1.5016309865099643e-6</code></pre><p>As we can see, the error is quite small! To visualize the solution in this simple (2d) example, we could simply use <code>Makie</code>:</p><pre><code class="language-julia hljs">using GLMakie
xx = yy = range(-4; stop = 4, length = 200)
vals = map(pt -&gt; norm(pt) &gt; 1 ? real(uₛ(pt) + uᵢ(pt)) : NaN, Iterators.product(xx, yy))
fig, ax, hm = heatmap(
    xx,
    yy,
    vals;
    colormap = :inferno,
    interpolate = true,
    axis = (aspect = DataAspect(), xgridvisible = false, ygridvisible = false),
)
lines!(
    ax,
    [cos(θ) for θ in 0:0.01:2π],
    [sin(θ) for θ in 0:0.01:2π];
    color = :black,
    linewidth = 4,
)
Colorbar(fig[1, 2], hm)
fig</code></pre><img src="25ac6c64.png" alt="Example block output"/><p>More complex problems, however, may require a mesh-based visualization, where we would first need to create a mesh for the places where we want to visualize the solution. In the 3D example that follows, we will use the <code>Gmsh</code> API to create a a mesh of a punctured plane where we will visualize the solution.</p><p>Before moving on to the 3D example let us simply mention that, besides the fact that an analytic solution was available for comparisson, there was nothing special about the unit disk in the example above. We could have, for instance, replaced the disk by a kite-like shape:</p><pre><code class="language-julia hljs">f = (s) -&gt; (cospi(2 * s[1]) + 0.65 * cospi(4 * s[1]) - 0.65, 1.5 * sinpi(2 * s[1]))
Inti.clear_entities!() # empty the entity cacheg
gmsh.initialize()
gmsh.option.setNumber(&quot;Mesh.MeshSizeMax&quot;, meshsize)
gmsh.option.setNumber(&quot;Mesh.MeshSizeMin&quot;, meshsize)
# parametrization of a kite-like shape
tag = Inti.gmsh_curve(f, 0, 1; npts = 100, meshsize)
# create a surface from the curve
tl = gmsh.model.occ.addCurveLoop([tag])
ta = gmsh.model.occ.addPlaneSurface([tl])
gmsh.model.occ.synchronize()
gmsh.model.mesh.generate(2)
gmsh.model.mesh.setOrder(gorder)
msh = Inti.import_mesh(; dim = 2)
gmsh.finalize()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Info    : Meshing 1D...
Info    : Meshing curve 1 (BSpline)
Info    : Done meshing 1D (Wall 0.0155124s, CPU 0.015526s)
Info    : Meshing 2D...
Info    : Meshing surface 1 (Plane, Frontal-Delaunay)
Info    : Done meshing 2D (Wall 0.100643s, CPU 0.100629s)
Info    : 717 nodes 1335 elements
Info    : Meshing order 2 (curvilinear on)...
Info    : [  0%] Meshing curve 1 order 2
Info    : [ 50%] Meshing surface 1 order 2
Info    : Surface mesh: worst distortion = 0.978009 (0 elements in ]0, 0.2]); worst gamma = 0.764133
Info    : Done meshing order 2 (Wall 0.00951446s, CPU 0.00951s)</code></pre><h2 id="helmholtz-scattering-3d"><a class="docs-heading-anchor" href="#helmholtz-scattering-3d">Three-dimensional scattering</a><a id="helmholtz-scattering-3d-1"></a><a class="docs-heading-anchor-permalink" href="#helmholtz-scattering-3d" title="Permalink"></a></h2><p>We now consider the same problem in 3D. Unlike the 2D case, assembling dense matrix representations of the integral operators quickly becomes unfeasiable as the problem size increases. <code>Inti</code> adds support for compressing the underlying linear operators by wrapping external libraries. In this example, we will rely on <a href="https://github.com/WaveProp/HMatrices.jl"><code>HMatrices.jl</code></a> to handle the compression.</p><p>The visualization is also more involved, and we will use instead the <code>Gmsh</code> API to create a view of the solution on a punctured plane. Let us begin by creating our domain containing both the sphere and the puctured plane where we will visualize the solution:</p><pre><code class="language-julia hljs">function gmsh_sphere(; meshsize, order = gorder, radius = 1, visualize = false, name)
    gmsh.initialize()
    gmsh.model.add(&quot;sphere-scattering&quot;)
    gmsh.option.setNumber(&quot;Mesh.MeshSizeMax&quot;, meshsize)
    gmsh.option.setNumber(&quot;Mesh.MeshSizeMin&quot;, meshsize)
    sphere_tag = gmsh.model.occ.addSphere(0, 0, 0, radius)
    xl, yl, zl = -2 * radius, -2 * radius, 0
    Δx, Δy = 4 * radius, 4 * radius
    rectangle_tag = gmsh.model.occ.addRectangle(xl, yl, zl, Δx, Δy)
    outDimTags, _ =
        gmsh.model.occ.cut([(2, rectangle_tag)], [(3, sphere_tag)], -1, true, false)
    gmsh.model.occ.synchronize()
    gmsh.model.addPhysicalGroup(3, [sphere_tag], -1, &quot;omega&quot;)
    gmsh.model.addPhysicalGroup(2, [dt[2] for dt in outDimTags], -1, &quot;sigma&quot;)
    gmsh.model.mesh.generate(2)
    gmsh.model.mesh.setOrder(order)
    visualize &amp;&amp; gmsh.fltk.run()
    gmsh.option.setNumber(&quot;Mesh.SaveAll&quot;, 1) # otherwise only the physical groups are saved
    gmsh.write(name)
    return gmsh.finalize()
end</code></pre><p>As before, lets write a file with our mesh, and import it into <code>Inti.jl</code>:</p><pre><code class="language-julia hljs">name = joinpath(@__DIR__, &quot;sphere.msh&quot;)
gmsh_sphere(; meshsize, order = gorder, name, visualize = false)
Inti.clear_entities!()
msh = Inti.import_mesh(name; dim = 3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Inti.LagrangeMesh{3, Float64} containing:
	 7 elements of type StaticArraysCore.SVector{3, Float64}
	 255 elements of type Inti.LagrangeElement{Inti.ReferenceHyperCube{1}, 3, StaticArraysCore.SVector{3, Float64}}
	 6239 elements of type Inti.LagrangeElement{Inti.ReferenceSimplex{2}, 6, StaticArraysCore.SVector{3, Float64}}</code></pre><p>Since we created physical groups in <code>Gmsh</code>, we can use them to extract the relevant domains <code>Ω</code> and <code>Σ</code>:</p><pre><code class="language-julia hljs">Ω = Inti.Domain(e -&gt; &quot;omega&quot; ∈ Inti.labels(e), Inti.entities(msh))
Σ = Inti.Domain(e -&gt; &quot;sigma&quot; ∈ Inti.labels(e), Inti.entities(msh))
Γ = Inti.boundary(Ω)</code></pre><p>We can now create a quadrature as before</p><pre><code class="language-julia hljs">Γ_msh = view(msh, Γ)
Q = Inti.Quadrature(Γ_msh; qorder)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If you pass <code>visualize=true</code> to <code>gmsh_sphere</code>, it will open a window   with the current mode. This is done by calling <code>gmsh.fltk.run()</code>. Note   that the main julia thread will be blocked until the window is closed.</p></div></div><div class="admonition is-success"><header class="admonition-header">Writing/reading a mesh from disk</header><div class="admonition-body"><p>Writing and reading a mesh to/from disk can be time consuming. You can   avoid doing so by using <a href="../../../docstrings/#Inti.import_mesh-Tuple"><code>import_mesh</code></a> without a   file name to import the mesh from the current <code>gmsh</code> session without the   need to write it to disk.</p></div></div><p>We can now assemble the integral operators, indicating that we wish to compress them using hierarchical matrices:</p><pre><code class="language-julia hljs">using HMatrices
pde = Inti.Helmholtz(; k, dim = 3)
S, D = Inti.single_double_layer(;
    pde,
    target = Q,
    source = Q,
    compression = (method = :hmatrix, tol = 1e-6),
    correction = (method = :dim,),
)</code></pre><p>Here is how much memory it would take to store the dense representation of these matrices:</p><pre><code class="language-julia hljs">mem = 2 * length(S) * 16 / 1e9 # 16 bytes per complex number, 1e9 bytes per GB, two matrices
println(&quot;memory required to store S and D: $(mem) GB&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">memory required to store S and D: 11.445239808 GB</code></pre><p>Even for this simple example, the dense representation of the integral operators as matrix is already quite expensive!</p><div class="admonition is-info"><header class="admonition-header">Compression methods</header><div class="admonition-body"><p>It is worth mentioning that hierchical matrices are not the only way to   compress such integral operators, and may in fact not even be the best   for the problem at hand. For example, one could use a fast multipole   method (FMM), which has a much lighter memory footprint, and is also   faster to assemble. The main advantage of hierarchical matrices is that   they are purely algebraic, allowing for the use of <em>direct solver</em>.   Hierarchical matrices also tend to give a faster matrix-vector product   after the (offline) assembly stage.</p></div></div><p>We will use the generalized minimal residual (GMRES) iterative solver, for the linear system. This requires us to define a linear operator <code>L</code>, approximating the combined-field operator, that supports the matrix-vector product. In what follows we use <code>LinearMaps</code> to <em>lazily</em> assemble <code>L</code>:</p><pre><code class="language-julia hljs">using LinearMaps
L = I / 2 + LinearMap(D) - im * k * LinearMap(S)</code></pre><p>Note that wrapping <code>S</code> and <code>D</code> in <code>LinearMap</code> allows for combining them in a <em>lazy</em> fashion. Alternatively, you can use e.g. <code>axpy!</code> to add two hierarchical matrices.</p><p>We can now solve the linear system using GMRES solver:</p><pre><code class="language-julia hljs">using IterativeSolvers
rhs = map(Q) do q
    x = q.coords
    return -uᵢ(x)
end
σ, hist =
    gmres(L, rhs; log = true, abstol = 1e-6, verbose = false, restart = 100, maxiter = 100)
@show hist</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Converged after 18 iterations.</code></pre><p>As before, let us represent the solution using <code>IntegralPotential</code>s:</p><pre><code class="language-julia hljs">𝒮, 𝒟 = Inti.single_double_layer_potential(; pde, source = Q)
uₛ = x -&gt; 𝒟[σ](x) - im * k * 𝒮[σ](x)</code></pre><p>To check the result, we compare against the exact solution obtained through a series:</p><pre><code class="language-julia hljs">using GSL
sphbesselj(l, r) = sqrt(π / (2r)) * besselj(l + 1 / 2, r)
sphbesselh(l, r) = sqrt(π / (2r)) * besselh(l + 1 / 2, r)
sphharmonic(l, m, θ, ϕ) = GSL.sf_legendre_sphPlm(l, abs(m), cos(θ)) * exp(im * m * ϕ)
function sphere_helmholtz_soundsoft(xobs; radius = 1, k = 1, θin = 0, ϕin = 0)
    x = xobs[1]
    y = xobs[2]
    z = xobs[3]
    r = sqrt(x^2 + y^2 + z^2)
    θ = acos(z / r)
    ϕ = atan(y, x)
    u = 0.0
    r &lt; radius &amp;&amp; return u
    function c(l, m)
        return -4π * im^l * sphharmonic(l, -m, θin, ϕin) * sphbesselj(l, k * radius) /
               sphbesselh(l, k * radius)
    end
    l = 0
    for l in 0:60
        for m in -l:l
            u += c(l, m) * sphbesselh(l, k * r) * sphharmonic(l, m, θ, ϕ)
        end
        l += 1
    end
    return u
end</code></pre><p>We will compute the error on some point on the sphere of radius <code>2</code>:</p><pre><code class="language-julia hljs">uₑ = (x) -&gt; sphere_helmholtz_soundsoft(x; radius = 1, k = k, θin = π / 2, ϕin = 0)
er = maximum(1:100) do _
    x̂ = rand(Inti.Point3D) |&gt; normalize # an SVector of unit norm
    x = 2 * x̂
    return abs(uₛ(x) - uₑ(x))
end
@info &quot;error with correction = $er&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: error with correction = 8.972818933350554e-6</code></pre><p>We see that, once again, the approximation is quite accurate. Let us now visualize the solution on the punctured plane (which we labeled as &quot;sigma&quot;). Since evaluating the integral representation of the solution at many points is expensive, we will use a compression method to accelerate the evaluation as well. In the example below, we use the fast-multipole method:</p><pre><code class="language-julia hljs">using FMM3D
Σ_msh = view(msh, Σ)
target = Inti.nodes(Σ_msh)

S, D = Inti.single_double_layer(;
    pde,
    target,
    source = Q,
    compression = (method = :fmm, tol = 1e-6),
    # correction for the nearfield (for visual purposes, set to `:none` to disable)
    correction = (method = :dim, maxdist = meshsize, target_location = :outside),
)

ui_eval_msh = uᵢ.(target)
us_eval_msh = D * σ - im * k * S * σ
u_eval_msh = ui_eval_msh + us_eval_msh</code></pre><p>Finalize, we use <a href="@ref Meshes.viz"><code>viz</code></a> to visualize the scattered field:</p><pre><code class="language-julia hljs">using Meshes
using GLMakie # or your preferred Makie backend

nv = length(Inti.nodes(Γ_msh))
colorrange = extrema(real(u_eval_msh))
colormap = :inferno
fig, ax, pl = viz(Γ_msh; colorrange, colormap, color = zeros(nv))
viz!(Σ_msh; colorrange, colormap, color = real(u_eval_msh))
cb = Colorbar(fig[1, 2]; label = &quot;real(u)&quot;, colormap, colorrange)</code></pre><img src="8d05215f.png" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../toy_example/">« Toy example</a><a class="docs-footer-nextpage" href="../poisson/">Poisson solver »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 5 June 2024 16:01">Wednesday 5 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

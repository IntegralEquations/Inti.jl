var documenterSearchIndex = {"docs":
[{"location":"tutorials/solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"tutorials/solvers/","page":"Solvers","title":"Solvers","text":"CurrentModule = Inti","category":"page"},{"location":"references/","page":"References","title":"References","text":"CurrentModule = Inti","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"J.-C. Nédélec. Acoustic and electromagnetic equations: integral representations for harmonic problems. Vol. 144 (Springer, 2001).\n\n\n\nD. Colton and R. Kress. Integral equation methods in scattering theory (SIAM, 2013).\n\n\n\nL. M. Faria, C. Pérez-Arancibia and M. Bonnet. General-purpose kernel regularization of boundary integral equations via density interpolation. Computer Methods in Applied Mechanics and Engineering 378, 113703 (2021).\n\n\n\nT. G. Anderson, M. Bonnet, L. M. Faria and C. Pérez-Arancibia. Fast, high-order numerical evaluation of volume potentials via polynomial density interpolation. Journal of Computational Physics, 113091 (2024).\n\n\n\n","category":"page"},{"location":"examples/generated/toy_example/","page":"Toy example","title":"Toy example","text":"EditURL = \"../toy_example.jl\"","category":"page"},{"location":"examples/generated/toy_example/#Toy-example","page":"Toy example","title":"Toy example","text":"","category":"section"},{"location":"examples/generated/toy_example/","page":"Toy example","title":"Toy example","text":"(Image: ipynb) (Image: nbviewer)","category":"page"},{"location":"examples/generated/toy_example/","page":"Toy example","title":"Toy example","text":"All examples in Inti.jl are autogenerated by executing the make.jl script in the docs folder. The workflow uses Literate.jl to generate (i) markdown files passed to Documenter.jl, and (ii) notebook files downloadable from the example's page.","category":"page"},{"location":"examples/generated/toy_example/","page":"Toy example","title":"Toy example","text":"using Inti","category":"page"},{"location":"examples/generated/toy_example/","page":"Toy example","title":"Toy example","text":"","category":"page"},{"location":"examples/generated/toy_example/","page":"Toy example","title":"Toy example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/layer_potentials/#Layer-potentials","page":"Layer potentials","title":"Layer potentials","text":"","category":"section"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"CurrentModule = Inti","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"note: Important points covered in this tutorial\nNearly singular evaluation of layer potentials\nCreating a smooth domain with splines using Gmsh.jl","category":"page"},{"location":"tutorials/layer_potentials/#Direct-evaluation-of-layer-potentials","page":"Layer potentials","title":"Direct evaluation of layer potentials","text":"","category":"section"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"using Inti, StaticArrays, LinearAlgebra, Meshes, GLMakie, Gmsh\n# define the PDE\nk = 4π\npde = Inti.Helmholtz(; dim = 2, k)\nmeshsize = 2π / k / 10\n# create the domain and mesh using the Gmsh API\ngmsh.initialize()\nkite = Inti.gmsh_curve(0, 1; meshsize) do s\n    SVector(0.25, 0.0) + SVector(cos(2π * s) + 0.65 * cos(4π * s[1]) - 0.65, 1.5 * sin(2π * s))\nend\ncl = gmsh.model.occ.addCurveLoop([kite])\nsurf = gmsh.model.occ.addPlaneSurface([cl])\ngmsh.model.occ.synchronize()\ngmsh.model.mesh.generate(2)\nmsh = Inti.import_mesh(; dim = 2)\ngmsh.finalize()\n# extract the domain Ω from the mesh entities\nents = Inti.entities(msh)\nΩ = Inti.Domain(e->Inti.geometric_dimension(e) == 2, ents)\n# create a quadrature on the boundary\nΓ = Inti.boundary(Ω)\nQ = Inti.Quadrature(view(msh,Γ); qorder = 5)\n# construct an exact interior solution as a sum of random plane waves\ndirs  = [SVector(cos(θ), sin(θ)) for θ in 2π*rand(10)]\ncoefs = rand(ComplexF64, 10)\nu  =  (x)   -> sum(c*exp(im*k*dot(x, d)) for (c,d) in zip(coefs, dirs))\ndu =  (x,ν) -> sum(c*im*k*dot(d, ν)*exp(im*k*dot(x, d)) for (c,d) in zip(coefs, dirs))\n# plot it \nΩ_msh = view(msh, Ω)\ntarget = Inti.nodes(Ω_msh)\nviz(Ω_msh; showsegments = false, axis = (aspect = DataAspect(), ), color = real(u.(target)))","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"Let us now compute the layer potentials of the exact solution on the boundary, and evaluate the error on the target nodes:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"# evaluate the layer potentials\n𝒮, 𝒟 = Inti.single_double_layer_potential(; pde, source = Q)\nγ₀u = map(q -> u(q.coords), Q)\nγ₁u = map(q -> du(q.coords, q.normal), Q)\nuₕ = x -> 𝒮[γ₁u](x) - 𝒟[γ₀u](x)\n# plot the error on the target nodes\ner_log10 = log10.(abs.(u.(target) - uₕ.(target)))\ncolorrange = extrema(er_log10)\nfig, ax, pl = viz(Ω_msh;\n    color = er_log10,\n    colormap = :viridis,\n    colorrange,\n    axis = (aspect = DataAspect(),), \n    interpolate=true\n)\nColorbar(fig[1, 2]; label = \"log₁₀(error)\", colorrange)\nfig","category":"page"},{"location":"tutorials/layer_potentials/#Near-field-correction-of-layer-potentials","page":"Layer potentials","title":"Near-field correction of layer potentials","text":"","category":"section"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"S, D = Inti.single_double_layer(; pde, target, source = Q,\n    compression = (method = :none, ),\n    correction = (method = :dim, target_location = :inside, maxdist = 0.2)\n)\ner_log10_cor = log10.(abs.(S*γ₁u - D*γ₀u - u.(target)))\ncolorrange = extrema(er_log10_cor)\nfig, ax, pl = viz(Ω_msh;\n    color = er_log10_cor,\n    colormap = :viridis,\n    colorrange,\n    axis = (aspect = DataAspect(),), \n    interpolate=true\n)\nColorbar(fig[1, 2]; label = \"log₁₀(error)\", colorrange)\nfig","category":"page"},{"location":"tutorials/integral_operators/#Boundary-integral-operators","page":"Boundary integral operators","title":"Boundary integral operators","text":"","category":"section"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"CurrentModule = Inti","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"note: Important points covered in this tutorial\nDefine layer potentials and the four integral operators of Calderón calculus\nBlock operator construction and composition\nVolume integral operators","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"A central piece of integral equation methods is the efficient and accurate computation of integral operators. In the first part of this tutorial we will cover how to assemble and manipulate the four integral operators of Calderón calculus, namely the single-layer, double-layer, hypersingular, and adjoint operators [1, 2], for some predefined kernels in Inti.jl. In the second part we will show how to extend the package to handle custom kernels.","category":"page"},{"location":"tutorials/integral_operators/#Predefined-kernels-and-integral-operators","page":"Boundary integral operators","title":"Predefined kernels and integral operators","text":"","category":"section"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"To simplify the construction of integral operators for some commonly used PDEs, Inti.jl defines a few AbstractPDEs types:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"using Inti, StaticArrays, LinearAlgebra\nusing InteractiveUtils: subtypes # hide\nsubtypes(Inti.AbstractPDE)","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"For each of these PDEs, the package provides a SingleLayerKernel, DoubleLayerKernel, HyperSingularKernel, and AdjointDoubleLayerKernel that can be used to construct the corresponding kernel functions, e.g.:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"pde = Inti.Helmholtz(; dim = 2, k = 1.2)\nG   = Inti.SingleLayerKernel(pde)","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"Typically, we are not interested in the kernels themselves, but in the integral operators they define. Two functions, single_double_layer and adj_double_layer_hypersingular, are provided as a high-level syntax to construct the four integral operators of Calderón calculus:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"Γ = Inti.parametric_curve(s -> SVector(cos(s), sin(s)), 0, 2π) |> Inti.Domain\nQ = Inti.Quadrature(Γ; meshsize = 0.01, qorder = 5)\nS, D = Inti.single_double_layer(; \n    pde, \n    target = Q, \n    source = Q, \n    compression = (method = :none,), \n    correction = (method = :dim,)\n)\nK, N = Inti.adj_double_layer_hypersingular(; \n    pde, \n    target = Q, \n    source = Q, \n    compression = (method = :none,), \n    correction = (method = :dim,)\n)\nnothing # hide","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"Much goes on under the hood in the function above, and the sections on correction and compression methods will provide more details on the options available. The important thing to keep in mind is that S, D, K, and H are discrete approximations of the following (linear) operators:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"beginaligned\n    Ssigma(boldsymbolx) = int_Gamma G(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly quad \n    Dsigma(boldsymbolx) = mathrmpv int_Gamma fracpartial Gpartial nu_boldsymboly(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly \n    Dsigma(boldsymbolx) =  mathrmpv int_Gamma fracpartial Gpartial nu_boldsymbolx(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly quad\n    Nsigma(boldsymbolx) = mathrmfp int_Gamma fracpartial^2 Gpartial nu_boldsymbolx partial nu_boldsymboly(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly\nendaligned","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"The actual type of S, D, K, and H depends on the compression and correction methods. In the simple case above, these are simply matrices:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"@assert all(T -> T == Matrix{ComplexF64}, map(typeof, (S, D, K, N))) # hide\nmap(typeof, (S, D, K, N))","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"If we turn on a compression method, such as :fmm, the types may change into something different:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"using FMM2D # will load the extension\nSfmm, Dfmm = Inti.single_double_layer(; \n    pde, \n    target = Q, \n    source = Q, \n    compression = (method = :fmm, tol = 1e-10), \n    correction = (method = :dim, )\n)\nKfmm, Nfmm = Inti.adj_double_layer_hypersingular(; \n    pde, \n    target = Q, \n    source = Q, \n    compression = (method = :fmm, tol = 1e-10), \n    correction = (method = :dim,)\n)\ntypeof(Sfmm)","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"This is because the FMM method is used to approximate the matrix-vector in a matrix-free way: the only thing guaranteed is that S and D can be applied to a vector:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"x = rand(size(S,2))\n# @assert norm(Sfmm*x - S*x, Inf) / norm(S*x, Inf) < 1e-3 # hide\nnorm(Sfmm*x - S*x, Inf)","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"The Sfmm object above in fact combines two linear maps:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"Sfmm","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"The FunctionMap computes a matrix-vector by performing a function call to the FMM2D library. The WrappedMap accounts for a sparse matrix used to account for singular and nearly singular interactions. These two objects are added lazily using LinearMaps.","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"Effortlessly and efficiently composing operators is a powerful abstraction for integral equations, as it allows for the construction of complex systems from simple building blocks. To show this, let us show how one may construct the Calderón projectors:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"beginaligned\nH = beginbmatrix\n    -D  S \n    -N  D\nendbmatrix \nendaligned","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"As is well-known [1, Theorem 3.1.3], the operators C_pm = I2 pm H are the projectors (i.e. C_pm^2 = C_pm):","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"using LinearMaps\nH = [-Dfmm Sfmm; -Nfmm Kfmm]\nC₊ = I / 2 + H\nC₋ = I / 2 - H\nu = map(q -> cos(q.coords[1] + q.coords[2]), Q)\nv = map(q-> q.coords[1], Q)\nx = [u; v]\ne₊ = norm(C₊*(C₊*x) - C₊*x, Inf)\ne₋ = norm(C₋*(C₋*x) - C₋*x, Inf)\nprintln(\"projection error for C₊: $e₊\")\nprintln(\"projection error for C₋: $e₋\")","category":"page"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"CurrentModule = Inti","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Modules = [Inti]","category":"page"},{"location":"docstrings/#Inti.Inti","page":"Docstrings","title":"Inti.Inti","text":"module Inti\n\nLibrary for solving integral equations using Nyström methods.\n\n\n\n\n\n","category":"module"},{"location":"docstrings/#Inti.COMPRESSION_METHODS","page":"Docstrings","title":"Inti.COMPRESSION_METHODS","text":"const COMPRESSION_METHODS = [:none, :hmatrix, :fmm]\n\nAvailable compression methods for the dense linear operators in Inti.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#Inti.CORRECTION_METHODS","page":"Docstrings","title":"Inti.CORRECTION_METHODS","text":"const CORRECTION_METHODS = [:none, :dim, :hcubature]\n\nAvailable correction methods for the singular and nearly-singular integrals in Inti.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#Inti.ENTITIES","page":"Docstrings","title":"Inti.ENTITIES","text":"const ENTITIES\n\nDictionary mapping EntityKey to GeometricEntity. Contains all entities created in a given session.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#Inti.SAME_POINT_TOLERANCE","page":"Docstrings","title":"Inti.SAME_POINT_TOLERANCE","text":"SAME_POINTS_TOLERANCE\n\nTwo points x and y are considerd the same if norm(x-y) ≤ SAME_POINT_TOLERANCE.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#Inti.AbstractKernel","page":"Docstrings","title":"Inti.AbstractKernel","text":"abstract type AbstractKernel{T}\n\nA kernel functions K with the signature K(target,source)::T.\n\nSee also: GenericKernel, SingleLayerKernel, DoubleLayerKernel, AdjointDoubleLayerKernel, HyperSingularKernel\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.AbstractMesh","page":"Docstrings","title":"Inti.AbstractMesh","text":"abstract type AbstractMesh{N,T}\n\nAn abstract mesh structure in dimension N with primite data of type T (e.g. Float64 for double precision representation).\n\nConcrete subtypes of AbstractMesh should implement ElementIterator for accessing the mesh elements.\n\nSee also: LagrangeMesh\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.AbstractPDE","page":"Docstrings","title":"Inti.AbstractPDE","text":"abstract type AbstractPDE{N}\n\nA partial differential equation in dimension N. AbstractPDE types are used to define AbstractPDEKernels.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.AbstractPDEKernel","page":"Docstrings","title":"Inti.AbstractPDEKernel","text":"abstract type AbstractPDEKernel{T,Op} <: AbstractKernel{T}\n\nAn AbstractKernel with an associated pde::Op field.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.AdjointDoubleLayerKernel","page":"Docstrings","title":"Inti.AdjointDoubleLayerKernel","text":"struct AdjointDoubleLayerKernel{T,Op} <: AbstractPDEKernel{T,Op}\n\nGiven an operator Op, construct its free-space adjoint double-layer kernel. This corresponds to the transpose(γ₁,ₓ[G]), where G is the SingleLayerKernel. For operators such as Laplace or Helmholtz, this is simply the normal derivative of the fundamental solution respect to the target variable.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.DimParameters","page":"Docstrings","title":"Inti.DimParameters","text":"struct DimParameters\n\nParameters associated with the density interpolation method used in bdim_correction.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Domain","page":"Docstrings","title":"Inti.Domain","text":"struct Domain\n\nRepresentation of a geometrical domain formed by a set of entities with the same geometric dimension. For basic set operations on domains are supported (union, intersection, difference, etc), and they all return a new Domain object.\n\nCalling keys(Ω) returns the set of EntityKeys that make up the domain; given a key, the underlying entities can be accessed with global_get_entity(key).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Domain-Tuple{Function, Any}","page":"Docstrings","title":"Inti.Domain","text":"Domain([f::Function,] keys)\n\nCreate a domain from a set of EntityKeys. Optionally, a filter function f can be passed to filter the entities.\n\nNote that all entities in a domain must have the same geometric dimension.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.DoubleLayerKernel","page":"Docstrings","title":"Inti.DoubleLayerKernel","text":"struct DoubleLayerKernel{T,Op} <: AbstractPDEKernel{T,Op}\n\nGiven an operator Op, construct its free-space double-layer kernel. This corresponds to the γ₁ trace of the SingleLayerKernel. For operators such as Laplace or Helmholtz, this is simply the normal derivative of the fundamental solution respect to the source variable.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ElementIterator","page":"Docstrings","title":"Inti.ElementIterator","text":"struct ElementIterator{E,M} <: AbstractVector{E}\n\nStructure to lazily access elements of type E in a mesh of type M. This is particularly useful for LagrangeElements, where the information to reconstruct the element is stored in the mesh connectivity matrix.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.EmbeddedQuadrature","page":"Docstrings","title":"Inti.EmbeddedQuadrature","text":"struct EmbeddedQuadrature{L,H,D} <: ReferenceQuadrature{D}\n\nA quadrature rule for the reference shape D based on a high-order quadrature of type H and a low-order quadrature of type L. The low-order quadrature rule is embedded in the sense that its n nodes are exactly the first n nodes of the high-order quadrature rule.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.EntityKey","page":"Docstrings","title":"Inti.EntityKey","text":"EntityKey\n\nUsed to represent the key of a GeometricEntity, comprised of a dim and a tag field, where dim is the geometrical dimension of the entity, and tag is a unique integer identifying the entity.\n\nThe sign of the tag field is used to distinguish the orientation of the entity, and is ignored when comparing two EntityKeys for equality.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Fejer","page":"Docstrings","title":"Inti.Fejer","text":"struct Fejer{N}\n\nN-point Fejer's first quadrature rule for integrating a function over [0,1]. Exactly integrates all polynomials of degree ≤ N-1.\n\nusing Inti\n\nq = Inti.Fejer(;order=10)\n\nInti.integrate(cos,q) ≈ sin(1) - sin(0)\n\n# output\n\ntrue\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Gauss","page":"Docstrings","title":"Inti.Gauss","text":"struct Gauss{D,N} <: ReferenceQuadrature{D}\n\nTabulated N-point symmetric Gauss quadrature rule for integration over D.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.GenericKernel","page":"Docstrings","title":"Inti.GenericKernel","text":"struct GenericKernel{T,F} <: AbstractKernel{T}\n\nAn AbstractKernel with kernel of type F.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.GeometricEntity","page":"Docstrings","title":"Inti.GeometricEntity","text":"struct GeometricEntity\n\nUsed to represent geometrical objects such as lines, surfaces, and volumes.\n\nGeometrical entities are stored in a global ENTITIES dictionary mapping EntityKey to the corresponding GeometricEntity.\n\nA GeometricEntity can also contain a pushforward field used to parametrically represent the entry as the image of a reference domain (pushforward.domain) under some function (pushforward.parametrization).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Helmholtz","page":"Docstrings","title":"Inti.Helmholtz","text":"struct Helmholtz{N,T}\n\nHelmholtz equation in N dimensions: Δu + k²u = 0.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.HyperRectangle","page":"Docstrings","title":"Inti.HyperRectangle","text":"struct HyperRectangle{N,T} <: ReferenceInterpolant{ReferenceHyperCube{N},T}\n\nAxis-aligned hyperrectangle in N dimensions given by low_corner::SVector{N,T} and high_corner::SVector{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.HyperSingularKernel","page":"Docstrings","title":"Inti.HyperSingularKernel","text":"struct HyperSingularKernel{T,Op} <: AbstractPDEKernel{T,Op}\n\nGiven an operator Op, construct its free-space hypersingular kernel. This corresponds to the transpose(γ₁,ₓγ₁[G]), where G is the SingleLayerKernel. For operators such as Laplace or Helmholtz, this is simply the normal derivative of the fundamental solution respect to the target variable of the DoubleLayerKernel.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.IntegralOperator","page":"Docstrings","title":"Inti.IntegralOperator","text":"struct IntegralOperator{T} <: AbstractMatrix{T}\n\nA discrete linear integral operator given by\n\nIu(x) = int_Gamma_s K(xy)u(y) ds_y x in Gamma_t\n\nwhere Gamma_s and Gamma_t are the source and target domains, respectively.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.IntegralPotential","page":"Docstrings","title":"Inti.IntegralPotential","text":"struct IntegralPotential\n\nRepresent a potential given by a kernel and a quadrature over which integration is performed.\n\nIntegralPotentials are created using IntegralPotential(kernel, quadrature).\n\nEvaluating an integral potential requires a density σ (defined over the quadrature nodes of the source mesh) and a point x at which to evaluate the integral\n\nint_Gamma K(oldsymbolxoldsymboly)sigma(y) ds_y x not in Gamma\n\nAssuming 𝒮 is an integral potential and σ is a vector of values defined on quadrature, calling 𝒮[σ] creates an anonymous function that can be evaluated at any point x.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Kronrod","page":"Docstrings","title":"Inti.Kronrod","text":"struct Kronrod{D,N} <: ReferenceQuadrature{D}\n\nN-point Kronrod rule obtained by adding n+1 points to a Gauss quadrature containing n points. The order is either 3n + 1 for n even or 3n + 2 for n odd.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeCube","page":"Docstrings","title":"Inti.LagrangeCube","text":"const LagrangeSquare = LagrangeElement{ReferenceSquare}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeElement","page":"Docstrings","title":"Inti.LagrangeElement","text":"struct LagrangeElement{D,Np,T} <: ReferenceInterpolant{D,T}\n\nA polynomial p : D → T uniquely defined by its Np values on the Np reference nodes of D.\n\nThe return type T should be a vector space (i.e. support addition and multiplication by scalars). For istance, T could be a number or a vector, but not a Tuple.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeLine","page":"Docstrings","title":"Inti.LagrangeLine","text":"const LagrangeLine = LagrangeElement{ReferenceLine}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeMesh","page":"Docstrings","title":"Inti.LagrangeMesh","text":"struct LagrangeMesh{N,T} <: AbstractMesh{N,T}\n\nUnstructured mesh is defined by a set of nodes(of typeSVector{N,T}`), and a dictionary mapping element types to connectivity matrices. Each columns of a given connectivity matrix stores the integer tags of the nodes in the mesh comprising the element.\n\nAdditionally, the mesh contains a mapping from EntityKeys to the tags of the elements composing the entity. This can be used to extract submeshes from a given mesh using e.g. view(msh,Γ) or msh[Γ], where Γ is a Domain.\n\nSee elements for a way to iterate over the elements of a mesh.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeSquare","page":"Docstrings","title":"Inti.LagrangeSquare","text":"const LagrangeSquare = LagrangeElement{ReferenceSquare}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeTetrahedron","page":"Docstrings","title":"Inti.LagrangeTetrahedron","text":"const LagrangeTetrahedron = LagrangeElement{ReferenceTetrahedron}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeTriangle","page":"Docstrings","title":"Inti.LagrangeTriangle","text":"const LagrangeTriangle = LagrangeElement{ReferenceTriangle}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Laplace","page":"Docstrings","title":"Inti.Laplace","text":"struct Laplace{N}\n\nLaplace equation in N dimension: Δu = 0.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.MultiIndex","page":"Docstrings","title":"Inti.MultiIndex","text":"MultiIndex{N}\n\nWrapper around NTuple{N,Int} mimicking a multi-index in ℤ₀ᴺ.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ParametricElement","page":"Docstrings","title":"Inti.ParametricElement","text":"ParametricElement{D,T,F} <: ReferenceInterpolant{D,T}\n\nAn element represented through a explicit function f mapping D into the element. For performance reasons, f should take as input a StaticVector and return a StaticVector or StaticArray.\n\nSee also: ReferenceInterpolant, LagrangeElement\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ParametricElement-Union{Tuple{T}, Tuple{N}, Tuple{Any, Inti.HyperRectangle{N, T}}} where {N, T}","page":"Docstrings","title":"Inti.ParametricElement","text":"ParametricElement(f, d::HyperRectangle)\n\nConstruct the element defined as the image of f over d.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.PolynomialSpace","page":"Docstrings","title":"Inti.PolynomialSpace","text":"struct PolynomialSpace{D,K}\n\nThe space of all polynomials of degree ≤K, commonly referred to as ℙₖ.\n\nThe type parameter D, of singleton type, is used to determine the reference domain of the polynomial basis. In particular, when D is a hypercube in d dimensions, the precise definition is ℙₖ = span{𝐱ᶿ : 0≤max(θ)≤ K}; when D is a d-dimensional simplex, the space is ℙₖ = span{𝐱ᶿ : 0≤sum(θ)≤ K}, where θ ∈ 𝐍ᵈ is a multi-index.\n\nSee also: monomial_basis, lagrange_basis\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Quadrature","page":"Docstrings","title":"Inti.Quadrature","text":"struct Quadrature{N,T} <: AbstractVector{QuadratureNode{N,T}}\n\nA collection of QuadratureNodes used to integrate over an AbstractMesh.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Quadrature-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.Quadrature","text":"Quadrature(Ω::Domain; meshsize, qorder)\n\nConstruct a Quadrature over the domain Ω with a mesh of size meshsize and quadrature order qorder.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.Quadrature-Union{Tuple{T}, Tuple{N}, Tuple{Inti.AbstractMesh{N, T}, Dict}} where {N, T}","page":"Docstrings","title":"Inti.Quadrature","text":"Quadrature(msh::AbstractMesh, etype2qrule::Dict)\nQuadrature(msh::AbstractMesh; qorder)\n\nConstruct a Quadrature for msh, where for each element type E in msh the reference quadrature q = etype2qrule[E] is used. If an order keyword is passed, a default quadrature of the desired order is used for each element type usig _qrule_for_reference_shape.\n\nFor co-dimension one elements, the normal vector is also computed and stored in the QuadratureNodes.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.QuadratureNode","page":"Docstrings","title":"Inti.QuadratureNode","text":"QuadratureNode{N,T<:Real}\n\nA point in ℝᴺ with a weight for performing numerical integration. A QuadratureNode can optionally store a normal vector.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceCube","page":"Docstrings","title":"Inti.ReferenceCube","text":"const ReferenceCube = ReferenceHyperCube{3}\n\nSingleton type representing the unit cube [0,1]³.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceHyperCube","page":"Docstrings","title":"Inti.ReferenceHyperCube","text":"struct ReferenceHyperCube{N} <: ReferenceShape{N}\n\nSingleton type representing the axis-aligned hypercube in N dimensions with the lower corner at the origin and the upper corner at (1,1,…,1).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceInterpolant","page":"Docstrings","title":"Inti.ReferenceInterpolant","text":"abstract type ReferenceInterpolant{D,T}\n\nInterpolanting function mapping points on the domain D<:ReferenceShape (of singleton type) to a value of type T.\n\nInstances el of ReferenceInterpolant are expected to implement:\n\nel(x̂): evaluate the interpolation scheme at the (reference) coordinate x̂ ∈ D.\njacobian(el,x̂) : evaluate the jacobian matrix of the interpolation at the (reference) coordinate x ∈ D.\n\nnote: Note\nFor performance reasons, both el(x̂) and jacobian(el,x̂) should take as input a StaticVector and output a static vector or static array.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceLine","page":"Docstrings","title":"Inti.ReferenceLine","text":"const ReferenceLine = ReferenceHyperCube{1}\n\nSingleton type representing the [0,1] segment.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceQuadrature","page":"Docstrings","title":"Inti.ReferenceQuadrature","text":"abstract type ReferenceQuadrature{D}\n\nA quadrature rule for integrating a function over the domain D <: ReferenceShape.\n\nCalling x,w = q() returns the nodes x, given as SVectors, and weights w, for performing integration over domain(q).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceShape","page":"Docstrings","title":"Inti.ReferenceShape","text":"abstract type ReferenceShape\n\nA fixed reference domain/shape. Used mostly for defining more complex shapes as transformations mapping an ReferenceShape to some region of ℜᴹ.\n\nSee e.g. ReferenceLine or ReferenceTriangle for some examples of concrete subtypes.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceSimplex","page":"Docstrings","title":"Inti.ReferenceSimplex","text":"struct ReferenceSimplex{N}\n\nSingleton type representing the N-simplex with N+1 vertices (0,...,0),(0,...,0,1),(0,...,0,1,0),(1,0,...,0)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceSquare","page":"Docstrings","title":"Inti.ReferenceSquare","text":"const ReferenceSquare = ReferenceHyperCube{2}\n\nSingleton type representing the unit square [0,1]².\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceTetrahedron","page":"Docstrings","title":"Inti.ReferenceTetrahedron","text":"struct ReferenceTetrahedron\n\nSingleton type representing the tetrahedron with vertices (0,0,0),(0,0,1),(0,1,0),(1,0,0)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceTriangle","page":"Docstrings","title":"Inti.ReferenceTriangle","text":"struct ReferenceTriangle\n\nSingleton type representing the triangle with vertices (0,0),(1,0),(0,1)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.SingleLayerKernel","page":"Docstrings","title":"Inti.SingleLayerKernel","text":"struct SingleLayerKernel{T,Op} <: AbstractPDEKernel{T,Op}\n\nThe free-space single-layer kernel (i.e. the fundamental solution) of an OP <: AbstractPDE.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.SubMesh","page":"Docstrings","title":"Inti.SubMesh","text":"struct SubMesh{N,T} <: AbstractMesh{N,T}\n\nView into a parent mesh over a given domain.\n\nA submesh implements the interface for AbstractMesh; therefore you can iterate over elements of the submesh just like you would with a mesh.\n\nConstruct SubMeshs using view(parent,Ω::Domain).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.TensorProductQuadrature","page":"Docstrings","title":"Inti.TensorProductQuadrature","text":"TensorProductQuadrature{N,Q}\n\nA tensor-product of one-dimension quadrature rules. Integrates over [0,1]^N.\n\nExamples\n\nqx = Fejer(10)\nqy = TrapezoidalOpen(15)\nq  = TensorProductQuadrature(qx,qy)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.VioreanuRokhlin","page":"Docstrings","title":"Inti.VioreanuRokhlin","text":"struct VioreanuRokhlin{D,N} <: ReferenceQuadrature{D}\n\nTabulated N-point Vioreanu-Rokhlin quadrature rule for integration over D.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Base.iterate","page":"Docstrings","title":"Base.iterate","text":"iterate(Ω::Domain)\n\nIterating over a domain means iterating over its entities.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti._copyto!-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:StaticArraysCore.SMatrix}}","page":"Docstrings","title":"Inti._copyto!","text":"_copyto!(target,source)\n\nDefaults to Base.copyto!, but includes some specialized methods to copy from a Matrix of SMatrix to a Matrix of Numbers and viceversa.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._get_gauss_qcoords_and_qweights-Tuple{Type{<:Inti.ReferenceShape}, Any}","page":"Docstrings","title":"Inti._get_gauss_qcoords_and_qweights","text":"_get_gauss_and_qweights(R::Type{<:ReferenceShape{D}}, N) where D\n\nReturns the N-point symmetric gaussian qnodes and qweights (x, w) for integration over R.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._get_vioreanurokhlin_qcoords_and_qweights-Tuple{Type{<:Inti.ReferenceShape}, Any}","page":"Docstrings","title":"Inti._get_vioreanurokhlin_qcoords_and_qweights","text":"_get_vioreanurokhlin_qcoords_and_qweights(R::Type{<:ReferenceShape{D}}, N) where D\n\nReturns the N-point Vioreanu-Rokhlin qnodes and qweights (x, w) for integration over R.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._green_multiplier-Tuple{Symbol}","page":"Docstrings","title":"Inti._green_multiplier","text":"_green_multiplier(s::Symbol)\n\nReturn -1.0 if s == :inside, 0.0 if s == :outside, and -0.5 if s == :on; otherwise, throw an error. The orientation is relative to the normal of the bounding curve/surface.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._green_multiplier-Union{Tuple{N}, Tuple{StaticArraysCore.SVector, Inti.Quadrature{N}}} where N","page":"Docstrings","title":"Inti._green_multiplier","text":"_green_multiplier(x, quad)\n\nHelper function to help determine the constant σ in the Green identity S[γ₁u](x)\n\nD[γ₀u](x) + σ*u(x) = 0. This can be used as a predicate to determine whether a\n\npoint is inside a domain or not.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._meshgen-Tuple{Any, Inti.HyperRectangle, Tuple{Vararg{T, N}} where {N, T}}","page":"Docstrings","title":"Inti._meshgen","text":"_meshgen(f,d::HyperRectangle,sz)\n\nCreate prod(sz) elements of ParametricElement type representing the push forward of f on each of the subdomains defined by a uniform cartesian mesh of d of size sz.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._normal-Union{Tuple{StaticArraysCore.SMatrix{N, M}}, Tuple{M}, Tuple{N}} where {N, M}","page":"Docstrings","title":"Inti._normal","text":"_normal(jac::SMatrix{M,N})\n\nGiven a an M by N matrix representing the jacobian of a codimension one object, compute the normal vector.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._qrule_for_reference_shape-Tuple{Any, Any}","page":"Docstrings","title":"Inti._qrule_for_reference_shape","text":"_qrule_for_reference_shape(ref,order)\n\nGiven a reference shape and a desired quadrature order, return an appropiate quadrature rule.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.adaptive_correction-Tuple{Inti.IntegralOperator}","page":"Docstrings","title":"Inti.adaptive_correction","text":"adaptive_correction(iop::IntegralOperator; tol, maxdist = farfield_distance(iop; atol), maxsplit = 1000])\n\nGiven an integral operator iop, this function provides a sparse correction to iop for the entries i,j such that the distance between the i-th target and the j-th source is less than maxdist.\n\nChoosing maxdist is a trade-off between accuracy and efficiency. The smaller the value, the fewer corrections are needed, but this may compromise the accuracy. For a fixed quadrature, the size of maxdist has to grow as the tolerance tol decreases. The default [farfield_distance(iop; tol)](@ref) provides a heuristic to determine a suitablemaxdist`.\n\nThe correction is computed by using the adaptive_integration routine, with a tolerance atol and a maximum number of subdivisions maxsplit; see adaptive_integration for more details.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.adaptive_integration-Tuple{Any, Inti.EmbeddedQuadrature}","page":"Docstrings","title":"Inti.adaptive_integration","text":"adaptive_integration(f, τ̂::RefernceShape; kwargs...)\nadaptive_integration(f, qrule::EmbeddedQuadrature; kwargs...)\n\nUse an adaptive procedure to estimate the integral of f over τ̂ = domain(qrule). The following optional keyword arguments are available:\n\natol::Real=0.0: absolute tolerance for the integral estimate\nrtol::Real=0.0: relative tolerance for the integral estimate\nmaxsplit::Int=1000: maximum number of times to split the domain\nnorm::Function=LinearAlgebra.norm: norm to use for error estimates\nbuffer::BinaryHeap: a pre-allocated buffer to use for the adaptive procedure (see allocate_buffer)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.adaptive_integration_singular-Tuple{Any, Inti.ReferenceHyperCube{1}, Any}","page":"Docstrings","title":"Inti.adaptive_integration_singular","text":"adaptive_integration_singular(f, τ̂, x̂ₛ; kwargs...)\n\nSimilar to adaptive_integration, but indicates that f has an isolated (integrable) singularity at x̂ₛ ∈ x̂ₛ.\n\nThe integration is performed by splitting τ̂ so that x̂ₛ is a fixed vertex, guaranteeing that f is never evaluated at x̂ₛ. Aditionally, a suitable change of variables may be applied to alleviate the singularity and improve the rate of convergence.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.adj_double_layer_hypersingular-Tuple{}","page":"Docstrings","title":"Inti.adj_double_layer_hypersingular","text":"adj_double_layer_hypersingular(; pde, target, source, compression,\ncorrection)\n\nSimilar to single_double_layer, but for the adjoint double-layer and hypersingular operators. See the documentation of [single_double_layer] for a description of the arguments.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.allocate_buffer-Tuple{Any, Inti.EmbeddedQuadrature}","page":"Docstrings","title":"Inti.allocate_buffer","text":"allocate_buffer(f, quad::EmbeddedQuadrature)\n\nCreate the buffer needed for the call adaptive_integration(f, τ̂; buffer, ...).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.ambient_dimension","page":"Docstrings","title":"Inti.ambient_dimension","text":"ambient_dimension(x)\n\nDimension of the ambient space where x lives. For geometrical objects this can differ from its geometric_dimension; for example a triangle in ℝ³ has ambient dimension 3 but geometric dimension 2, while a curve in ℝ³ has ambient dimension 3 but geometric dimension 1.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.assemble_fmm-Tuple{Inti.IntegralOperator, Vararg{Any}}","page":"Docstrings","title":"Inti.assemble_fmm","text":"assemble_fmm(iop; atol)\n\nSet up a 2D or 3D FMM for evaluating the discretized integral operator iop associated with the pde. In 2D the FMM2D or FMMLIB2D library is used (whichever was most recently loaded) while in 3D FMM3D is used.\n\nwarning: FMMLIB2D\nFMMLIB2D does no checking for if the targets and sources coincide, and will return Inf values if iop.target !== iop.source, but there is a point x ∈ iop.target such that x ∈ iop.source.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.assemble_hmatrix-Tuple","page":"Docstrings","title":"Inti.assemble_hmatrix","text":"assemble_hmatrix(iop[; atol, rank, rtol, eta])\n\nAssemble an H-matrix representation of the discretized integral operator iop using the HMatrices.jl library.\n\nSee the assemble_hmatrix function from HMatrices.jl for more details on the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.assemble_matrix-Tuple{Inti.IntegralOperator}","page":"Docstrings","title":"Inti.assemble_matrix","text":"assemble_matrix(iop::IntegralOperator; threads = true)\n\nAssemble the dense matrix representation of an IntegralOperator.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.bdim_correction-Tuple{Any, Any, Inti.Quadrature, Any, Any}","page":"Docstrings","title":"Inti.bdim_correction","text":"bdim_correction(pde,X,Y,S,D; green_multiplier, kwargs...)\n\nGiven a pde and a (possibly innacurate) discretizations of its single and double-layer operators S and D (taking a vector of values on Y and returning a vector on of values on X), compute corrections δS and δD such that S + δS and D + δD are more accurate approximations of the underlying single- and double-layer integral operators.\n\nSee [3] for more details on the method.\n\nArguments\n\nRequired:\n\npde must be an AbstractPDE\nY must be a Quadrature object of a closed surface\nX is either inside, outside, or on Y\nS and D are approximations to the single- and double-layer operators for pde taking densities in Y and returning densities in X.\ngreen_multiplier (keyword argument) is a vector with the same length as X storing the value of μ(x) for x ∈ X in the Green identity S\\[γ₁u\\](x) - D\\[γ₀u\\](x) + μ*u(x) = 0. See _green_multiplier.\n\nOptional kwargs:\n\nparameters::DimParameters: parameters associated with the density interpolation method\nderivative: if true, compute the correction to the adjoint double-layer and hypersingular operators instead. In this case, S and D should be replaced by a (possibly innacurate) discretization of adjoint double-layer and hypersingular operators, respectively.\nmaxdist: distance beyond which interactions are considered sufficiently far so that no correction is needed. This is used to determine a threshold for nearly-singular corrections when X and Y are different surfaces. When X === Y, this is not needed.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.boundary-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.boundary","text":"boundary(Ω::Domain)\n\nReturn the external boundaries of a domain.\n\nSee also: external_boundary, internal_boundary, skeleton.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.boundary_idxs-Tuple{Inti.LagrangeElement{Inti.ReferenceHyperCube{1}}}","page":"Docstrings","title":"Inti.boundary_idxs","text":"boundary_idxs(el::LagrangeElement)\n\nThe indices of the nodes in el that define the boundary of the element.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.connectivity-Tuple{Inti.LagrangeMesh, DataType}","page":"Docstrings","title":"Inti.connectivity","text":"connectivity(msh::AbstractMesh,E::DataType)\n\nReturn the connectivity matrix for elements of type E in msh. The integer tags in the matrix refer to the points in nodes(msh)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.coords-Tuple{T} where T","page":"Docstrings","title":"Inti.coords","text":"coords(q)\n\nReturn the spatial coordinates of q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.decompose","page":"Docstrings","title":"Inti.decompose","text":"decompose(s::ReferenceShape,x)\n\nDecompose an ReferenceShape into LagrangeElements so that x is a fixed vertex of the children elements.\n\nThe decomposed elements may be oriented differently than the parent, and thus care has to be taken regarding e.g. normal vectors.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.degree-Union{Tuple{Type{<:Inti.LagrangeElement{D, Np}}}, Tuple{Np}, Tuple{D}} where {D, Np}","page":"Docstrings","title":"Inti.degree","text":"degree(el::LagrangeElement)\ndegree(el::Type{<:LagrangeElement})\n\nThe polynomial degree el.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.dimension-Union{Tuple{Type{Inti.PolynomialSpace{D, K}}}, Tuple{K}, Tuple{D}} where {D, K}","page":"Docstrings","title":"Inti.dimension","text":"dimension(space)\n\nThe length of a basis for space; i.e. the number of linearly independent elements required to span space.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.dom2elt-Tuple{Inti.AbstractMesh, Inti.Domain, DataType}","page":"Docstrings","title":"Inti.dom2elt","text":"dom2elt(m::LagrangeMesh,Ω,E)::Vector{Int}\n\nCompute the element indices idxs of the elements of type E composing Ω.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.dom2qtags-Tuple{Inti.Quadrature, Inti.Domain}","page":"Docstrings","title":"Inti.dom2qtags","text":"dom2qtags(Q::Quadrature, dom::Domain)\n\nGiven a domain, return the indices of the quadratures nodes in Q associated to its quadrature.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.domain","page":"Docstrings","title":"Inti.domain","text":"domain(f)\n\nGiven a function-like object f: Ω → R, return Ω.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.domain-Tuple{Inti.AbstractMesh}","page":"Docstrings","title":"Inti.domain","text":"domain(msh::AbstractMesh)\n\nReturn a [Domain] containing of all entities covered by the mesh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.domain-Tuple{Inti.Quadrature}","page":"Docstrings","title":"Inti.domain","text":"domain(Q::Quadrature)\n\nThe Domain over which Q performs integration.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.domain-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D","page":"Docstrings","title":"Inti.domain","text":"domain(q::ReferenceQuadrature)\n\nThe domain of integratino for quadrature rule q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.element_types","page":"Docstrings","title":"Inti.element_types","text":"element_types(msh::AbstractMesh)\n\nReturn the element types present in the msh.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.elements","page":"Docstrings","title":"Inti.elements","text":"elements(msh::AbstractMesh [, E::DataType])\n\nReturn the elements of a msh. Passing and element type E will restricts to elements of that type.\n\nA common pattern to avoid type-instabilies in performance critical parts of the code is to use a function barrier, as illustrated below:\n\nfor E in element_types(msh)\n    _long_computation(elements(msh, E), args...)\nend\n\n@noinline function _long_computation(iter, args...)\n    for el in iter # the type of el is known at compile time\n        # do something with el\n    end\nend\n\nwhere a dynamic dispatch is performed only on the element types (typically small for a given mesh).\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.entities-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.entities","text":"entities(Ω::Domain)\n\nReturn all entities making up a domain.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.etype_to_nearest_points-Tuple{Any, Inti.Quadrature}","page":"Docstrings","title":"Inti.etype_to_nearest_points","text":"etype_to_nearest_points(X,Y::Quadrature; maxdist)\n\nFor each element el in Y.mesh, return a list with the indices of all points in X for which el is the nearest element. Ignore indices for which the distance exceeds maxdist.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.external_boundary-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.external_boundary","text":"external_boundary(Ω::Domain)\n\nReturn the external boundaries inside a domain. These are entities in the skeleton of Ω which are not in the internal boundaries of Ω.\n\nSee also: internal_boundary, skeleton.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.farfield_distance-Tuple{Inti.IntegralOperator}","page":"Docstrings","title":"Inti.farfield_distance","text":"farfield_distance(iop::IntegralOperator; tol, maxiter = 10)\nfarfield_distance(K, Q::Quadrature; tol, maxiter = 10)\n\nReturn an estimate of the distance d such that the (absolute) quadrature error of the integrand y -> K(x,y) is below tol for x at a distance d from the center of the largest element in Q; when an integral operator is passed, we have Q::Quadrature = source(iop) and K = kernel(iop).\n\nThe estimate is computed by finding the first integer n such that the quadrature error on the largest element τ lies below tol for points x satisfying dist(x,center(τ)) = n*radius(τ).\n\nNote that the desired tolerance may not be achievable if the quadrature rule is not accurate enough, or if τ is not sufficiently small, and therefore a maximum number of iterations maxiter is provided to avoid an infinite loops. In such cases, it is recommended that you either increase the quadrature order, or decrease the mesh size.\n\nNote: this is obviously a heuristic, and may not be accurate in all cases.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.fibonnaci_points_sphere-Tuple{Any, Any, Any}","page":"Docstrings","title":"Inti.fibonnaci_points_sphere","text":"fibonnaci_points_sphere(N,r,c)\n\nReturn N points distributed (roughly) in a uniform manner on the sphere of radius r centered at c.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.flip_normal-Tuple{Inti.QuadratureNode}","page":"Docstrings","title":"Inti.flip_normal","text":"flip_normal(q::QuadratureNode)\n\nReturn a new QuadratureNode with the normal vector flipped.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.geometric_dimension","page":"Docstrings","title":"Inti.geometric_dimension","text":"geometric_dimension(x)\n\nNNumber of degrees of freedom necessary to locally represent the geometrical object. For example, lines have geometric dimension of 1 (whether in ℝ² or in ℝ³), while surfaces have geometric dimension of 2.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.global_get_entity-Tuple{Inti.EntityKey}","page":"Docstrings","title":"Inti.global_get_entity","text":"global_get_entity(k::EntityKey)\n\nRetrieve the GeometricEntity corresponding to the EntityKey k from the global ENTITIES dictionary.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.gmsh_curve-Tuple","page":"Docstrings","title":"Inti.gmsh_curve","text":"gmsh_curve(f::Function, a, b; npts=100, meshsize = 0, tag=-1)\n\nCreate a curve in the current gmsh model given by {f(t) : t ∈ (a,b) } where f is a function from ℝ to ℝ^3. The curve is approximated by C² b-splines passing through npts equispaced in parameter space. If a meshsize is given, gmsh will use it when meshing the curve.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.image","page":"Docstrings","title":"Inti.image","text":"image(f)\n\nGiven a function-like object f: Ω → R, return f(Ω).\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.import_mesh-Tuple","page":"Docstrings","title":"Inti.import_mesh","text":"import_mesh(filename = nothing; dim=3)\n\nOpen filename and create a LagrangeMesh from the gmsh model in it.\n\nIf filename is nothing, the current gmsh model is used. Note that this assumes that the Gmsh API has been initialized through gmsh.initialize.\n\nPassing dim=2 will create a two-dimensional mesh by projecting the original mesh onto the x,y plane.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.integrate-Tuple{Any, Inti.Quadrature}","page":"Docstrings","title":"Inti.integrate","text":"integrate(f,quad::Quadrature)\n\nCompute ∑ᵢ f(qᵢ)wᵢ, where the qᵢ are the quadrature nodes of quad, and wᵢ are the quadrature weights.\n\nNote that you must define f(::QuadratureNode): use q.coords and q.normal if you need to access the coordinate or normal vector at que quadrature node.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.integrate-Tuple{Any, Inti.ReferenceQuadrature}","page":"Docstrings","title":"Inti.integrate","text":"integrate(f,q::ReferenceQuadrature)\nintegrate(f,x,w)\n\nIntegrate the function f using the quadrature rule q. This is simply sum(f.(x) .* w), where x and w are the quadrature nodes and weights, respectively.\n\nThe function f should take an SVector as input.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.integrate_with_error_estimate","page":"Docstrings","title":"Inti.integrate_with_error_estimate","text":"integrate_with_error_estimate(f, quad::EmbeddedQuadrature, norm = LinearAlgebra.norm)\n\nReturn I, E where I is the estimated integral of f over domain(quad) using the high-order quadrature and E is the error estimate obtained by taking the norm of the difference between the high and low-order quadratures in quad.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.integration_measure-Tuple{Any, Any}","page":"Docstrings","title":"Inti.integration_measure","text":"integration_measure(f, x̂)\n\nGiven the Jacobian matrix J of a transformation f : ℝᴹ → ℝᴺ compute the integration measure √det(JᵀJ) at the parametric coordinate x̂\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.interface_method-Tuple{DataType}","page":"Docstrings","title":"Inti.interface_method","text":"interface_method(x)\n\nA method of an abstract type for which concrete subtypes are expected to provide an implementation.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.internal_boundary-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.internal_boundary","text":"internal_boundary(Ω::Domain)\n\nReturn the internal boundaries of a Domain. These are entities in skeleton(Ω) which appear at least twice as a boundary of entities in Ω.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.interpolation_order-Tuple{Inti.ReferenceQuadrature{Inti.ReferenceHyperCube{1}}}","page":"Docstrings","title":"Inti.interpolation_order","text":"interpolation_order(qrule::ReferenceQuadrature)\n\nThe interpolation order of a quadrature rule is defined as the the smallest k such that there exists a unique polynomial in PolynomialSpace{D,k} that minimizes the error in approximating the function f at the quadrature nodes.\n\nFor an N-point Gauss quadrature rule on the segment, the interpolation order is N-1 since N points uniquely determine a polynomial of degree N-1.\n\nFor a triangular reference domain, the interpolation order is more difficult to define. An unisolvent three-node quadrature on the triangular, for example, has an interpolation order k=1 since the three nodes uniquely determine a linear polynomial, but a four-node quadrature may also have an interpolation order k=1 since for k=2 there are multiple polynomials that pass through the four nodes.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.jacobian-Tuple{Any, Any}","page":"Docstrings","title":"Inti.jacobian","text":"jacobian(f,x)\n\nGiven a (possibly vector-valued) functor f : 𝐑ᵐ → 𝐅ⁿ, return the n × m matrix Aᵢⱼ = ∂fᵢ/∂xⱼ. By default ForwardDiff is used to comptue the jacobian, but you should overload this method for specific f if better performance and/or precision is required.\n\nNote: both x and f(x) are expected to be of SVector type.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.lagrange_basis-Tuple{Any, Inti.PolynomialSpace}","page":"Docstrings","title":"Inti.lagrange_basis","text":"lagrange_basis(nodes,[sp::AbstractPolynomialSpace])\n\nReturn the set of n polynomials in sp taking the value of 1 on node i and 0 on nodes j ≂̸ i for 1 ≤ i ≤ n.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.lagrange_basis-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D","page":"Docstrings","title":"Inti.lagrange_basis","text":"lagrange_basis(qrule::ReferenceQuadrature)\n\nReturn a function L : ℝᴺ → ℝᵖ where N is the dimension of the domain of qrule, and p is the number of nodes in qrule. The function L is a polynomial in polynomial_space(qrule), and L(xⱼ)[i] = δᵢⱼ (i.e. the ith component of L is the ith Lagrange basis).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.lagrange_basis-Union{Tuple{Type{Inti.LagrangeElement{D, N, T}}}, Tuple{T}, Tuple{N}, Tuple{D}} where {D, N, T}","page":"Docstrings","title":"Inti.lagrange_basis","text":"lagrange_basis(E::Type{<:LagrangeElement})\n\nReturn the Lagrange basis B for the element E. Evaluating B(x) yields the value of each basis function at x.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.line-Tuple{Any, Any}","page":"Docstrings","title":"Inti.line","text":"line(a,b)\n\nCreate a [GeometricEntity] representing a straight line connecting points a and b. The points a and b can be either SVectors or a Tuple.\n\nThe parametrization of the line is given by f(u) = a + u(b - a), where 0 ≤ u ≤ 1.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.measure","page":"Docstrings","title":"Inti.measure","text":"measure(k::EntityKey, rtol)\n\nCompute the length/area/volume of the entity k using an adaptive quadrature with a relative tolerance rtol. Assumes that the entity has an explicit parametrization.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.meshgen!-Tuple{Inti.LagrangeMesh, Inti.Domain, Int64}","page":"Docstrings","title":"Inti.meshgen!","text":"meshgen!(mesh,Ω,sz)\n\nSimilar to meshgen, but append entries to mesh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.meshgen-Tuple{Inti.Domain, Vararg{Any}}","page":"Docstrings","title":"Inti.meshgen","text":"meshgen(Ω::Domain, n)\nmeshgen(Ω::Domain, n_dict)\nmeshgen(Ω::Domain; meshsize)\n\nGenerate a LagrangeMesh for the domain Ω where each curve is meshed using n elements. Passing a dictionary allows for a finer control; in such cases, n_dict[ent] should return an integer for each entity ent in Ω of geometric_dimension one.\n\nAlternatively, a meshsize can be passed, in which case, the number of elements is computed as so as to obtain an average mesh size of meshsize. Note that the actual mesh size may vary significantly for each element if the parametrization is far from uniform.\n\nThis function requires the entities forming Ω to have an explicit parametrization.\n\nwarning: Mesh quality\nThe quality of the generated mesh created usign meshgen depends on the quality of the underlying parametrization. For complex surfaces, you are better off using a proper mesher such as gmsh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.monomial_basis","page":"Docstrings","title":"Inti.monomial_basis","text":"monomial_basis(sp::PolynomialSpace)\n\nReturn a function f : ℝᴺ → ℝᵈ, where N is the dimension of the domain of sp     containing a basis of monomials 𝐱ᶿ spanning the polynomial space PolynomialSpace.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.near_interaction_list-Union{Tuple{N}, Tuple{AbstractVector{<:StaticArraysCore.SVector{N}}, Inti.AbstractMesh{N}}} where N","page":"Docstrings","title":"Inti.near_interaction_list","text":"near_interaction_list(X,Y::AbstractMesh; tol)\n\nFor each element el of type E in Y, return the indices of the points in X which are closer than tol to the center of el.\n\nThis function returns a dictionary where e.g. dict[E][5] --> Vector{Int} gives the indices of points in X which are closer than tol to the center of the fifth element of type E.\n\nIf tol is a Dict, then tol[E] is the tolerance for elements of type E.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.new_tag-Tuple{Int64}","page":"Docstrings","title":"Inti.new_tag","text":"new_tag(dim)\n\nReturn a new tag for an entity of dimension dim so that EntityKey(dim, tag) is not already in ENTITIES.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.nodes-Tuple{Inti.SubMesh}","page":"Docstrings","title":"Inti.nodes","text":"nodes(msh::SubMesh)\n\nA view of the nodes of the parent mesh belonging to the submesh. The ordering is given by the nodetags function.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.nodetags-Tuple{Inti.SubMesh}","page":"Docstrings","title":"Inti.nodetags","text":"nodetags(msh::SubMesh)\n\nReturn the tags of the nodes in the parent mesh belonging to the submesh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.normal-Tuple{Any, Any}","page":"Docstrings","title":"Inti.normal","text":"normal(el, x̂)\n\nReturn the normal vector of el at the parametric coordinate x̂.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.normal-Tuple{T} where T","page":"Docstrings","title":"Inti.normal","text":"normal(q)\n\nReturn the normal vector of q, if it exists.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.notimplemented-Tuple{}","page":"Docstrings","title":"Inti.notimplemented","text":"notimplemented()\n\nThings which should probably be implemented at some point.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.order-Union{Tuple{Inti.Fejer{N}}, Tuple{N}} where N","page":"Docstrings","title":"Inti.order","text":"order(q::ReferenceQuadrature)\n\nA quadrature of order p (sometimes called degree of precision) integrates all polynomials of degree ≤ p but not ≤ p + 1.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.order-Union{Tuple{Type{<:Inti.LagrangeElement{D, Np}}}, Tuple{Np}, Tuple{D}} where {D, Np}","page":"Docstrings","title":"Inti.order","text":"order(el::LagrangeElement)\n\nThe order of the element's interpolating polynomial (e.g. a LagrangeLine with 2 nodes defines a linear polynomial, and thus has order 1).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.parametric_curve-Union{Tuple{F}, Tuple{F, Real, Real}} where F","page":"Docstrings","title":"Inti.parametric_curve","text":"parametric_curve(f, a::Real, b::Real)\n\nCreate a [GeometricEntity] representing a parametric curve defined by the {f(t) | a ≤ t ≤ b}. The function f should map a scalar to a SVector.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.pde-Tuple{Inti.AbstractPDEKernel}","page":"Docstrings","title":"Inti.pde","text":"pde(K::AbstractPDEKernel)\n\nReturn the underlying AbstractPDE when K correspond to the kernel related to the underlying Greens function of a PDE.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.polynomial_solutions_vdim","page":"Docstrings","title":"Inti.polynomial_solutions_vdim","text":"polynomial_solutions_vdim(pde, order[, center])\n\nFor every monomial term pₙ of degree order, compute a polynomial Pₙ such that ℒ[Pₙ] = pₙ, where ℒ is the differential operator associated with pde. This function returns {pₙ,Pₙ,γ₁Pₙ}, where γ₁Pₙ is the generalized Neumann trace of Pₙ.\n\nPassing a point center will shift the monomials and solutions accordingly.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.polynomial_space-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D","page":"Docstrings","title":"Inti.polynomial_space","text":"polynomial_space(qrule::ReferenceQuadrature)\n\nReturn a PolynomialSpace associated with the interpolation_order of the quadrature nodes of qrule.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.qcoords-Tuple{Inti.ReferenceQuadrature}","page":"Docstrings","title":"Inti.qcoords","text":"qcoords(q)\n\nReturn the coordinate of the quadrature nodes associated with q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.quadrature_to_node_vals-Tuple{Inti.Quadrature, AbstractVector}","page":"Docstrings","title":"Inti.quadrature_to_node_vals","text":"quadrature_to_node_vals(Q::Quadrature, qvals::AbstractVector)\n\nGiven a vector qvals of scalar values at the quadrature nodes of Q, return a vector ivals of scalar values at the interpolation nodes of Q.mesh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.qweights-Tuple{Inti.ReferenceQuadrature}","page":"Docstrings","title":"Inti.qweights","text":"qweights(q)\n\nReturn the quadrature weights associated with q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.reference_nodes-Tuple{Inti.LagrangeElement}","page":"Docstrings","title":"Inti.reference_nodes","text":"reference_nodes(el::LagrangeElement)\nreference_nodes(::Type{<:LagrangeElement})\n\nReturn the reference nodes on domain(el) used for the polynomial interpolation. The function values on these nodes completely determines the interpolating polynomial.\n\nWe use the same convention as gmsh for defining the reference nodes and their order (see node ordering on gmsh documentation).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.return_type-Tuple{Any, Vararg{Any}}","page":"Docstrings","title":"Inti.return_type","text":"return_type(f[,args...])\n\nThe type returned by f(args...), where args is a tuple of types. Falls back to Base.promote_op by default.\n\nA functors of type T with a knonw return type should extend return_type(::T,args...) to avoid relying on promote_op.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.single_double_layer-Tuple{}","page":"Docstrings","title":"Inti.single_double_layer","text":"single_double_layer(; pde, target, source::Quadrature, compression,\ncorrection, derivative = false)\n\nConstruct a discrete approximation to the single- and double-layer integral operators for pde, mapping values defined on the quadrature nodes of source to values defined on the nodes of target. If derivative = true, return instead the adjoint double-layer and hypersingular operators (which are the derivative of the single- and double-layer, respectively).\n\nYou  must choose a compression method and a correction method, as described below.\n\nCompression\n\nThe compression argument is a named tuple with a method field followed by method-specific fields. It specifies how the dense linear operators should be compressed. The available options are:\n\n(method = :none, ): no compression is performed, the resulting matrices are dense.\n(method =:hmatrix, tol): the resulting operators are compressed using hierarchical matrices with an absolute tolerance tol (defaults to 1e-8).\n(method = :fmm, tol): the resulting operators are compressed using the fast multipole method with an absolute tolerance tol (defaults to 1e-8).\n\nCorrection\n\nThe correction argument is a named tuple with a method field followed by method-specific fields. It specifies how the singular and nearly-singular integrals should be computed. The available options are:\n\n(method = :none, ): no correction is performed. This is not recommented, as the resulting approximation will be inaccurate if the source and target are not sufficiently far apart.\n(method = :dim, maxdist, target_location): use the density interpolation method to compute the correction. maxdist specifies the distance between source and target points above which no correction is performed (defaults to Inf). target_location should be either :inside, :outside, or :on, and specifies where the targetpoints lie relative to the to thesourcecurve/surface (which is assumed to be closed). Whentarget === source,target_location` is not needed.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.single_double_layer_potential-Tuple{}","page":"Docstrings","title":"Inti.single_double_layer_potential","text":"single_double_layer_potential(; pde, source)\n\nReturn the single- and double-layer potentials for pde as IntegralPotentials.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.skeleton-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.skeleton","text":"skeleton(Ω::Domain)\n\nReturn all the boundaries of the domain, i.e. the domain's skeleton.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.standard_basis_vector-Union{Tuple{N}, Tuple{Any, Val{N}}} where N","page":"Docstrings","title":"Inti.standard_basis_vector","text":"standard_basis_vector(k, ::Val{N})\n\nCreate an SVector of length N with a 1 in the kth position and zeros elsewhere.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.svector-Union{Tuple{F}, Tuple{F, Any}} where F","page":"Docstrings","title":"Inti.svector","text":"svector(f,n)\n\nCreate an SVector of length n, computing each element as f(i), where i is the index of the element.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.uniform_points_circle-Tuple{Any, Any, Any}","page":"Docstrings","title":"Inti.uniform_points_circle","text":"uniform_points_circle(N,r,c)\n\nReturn N points uniformly distributed on a circle of radius r centered at c.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.vdim_correction-Union{Tuple{SHIFT}, Tuple{Any, Any, Inti.Quadrature, Inti.Quadrature, Any, Any, Any}} where SHIFT","page":"Docstrings","title":"Inti.vdim_correction","text":"vdim_correction(pde,X,Y,Y_boundary,S,D,V; green_multiplier, kwargs...)\n\nCompute a correction to the volume potential V : Y → X such that V + δV is a more accurate approximation of the underlying volume potential operator. The correction is computed using the (volume) density interpolation method.\n\nThis function requires a pde::AbstractPDE, a target set X, a source quadrature Y, a boundary quadrature Y_boundary, approximations S : Y_boundary -> X and D : Y_boundary -> X to the single- and double-layer potentials (correctly handling nearly-singular integrals), and a naive approximation of the volume potential V. The green_multiplier is a vector of the same length as X storing the value of μ(x) for x ∈ X in the Green identity (see _green_multiplier).\n\nSee [4] for more details on the method.\n\nOptional kwargs:\n\ninterpolation_order: the order of the polynomial interpolation. By default, the maximum order of the quadrature rules is used.\nmaxdist: distance beyond which interactions are considered sufficiently far so that no correction is needed. This is used to determine a threshold for nearly-singular corrections.\ncenter: the center of the basis functions. By default, the basis functions are centered at the origin.\nshift: a boolean indicating whether the basis functions should be shifted and rescaled to each element.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.vdim_mesh_center-Tuple{Inti.AbstractMesh}","page":"Docstrings","title":"Inti.vdim_mesh_center","text":"vdim_mesh_center(msh)\n\nPoint x which minimizes ∑ (x-xⱼ)²/r²ⱼ, where xⱼ and rⱼ are the circumcenter and circumradius of the elements of msh, respectively.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.vertices-Tuple{Inti.LagrangeElement}","page":"Docstrings","title":"Inti.vertices","text":"vertices(el::LagrangeElement)\n\nCoordinates of the vertices of el.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.vertices_idxs-Tuple{Type{<:Inti.LagrangeElement{Inti.ReferenceHyperCube{1}}}}","page":"Docstrings","title":"Inti.vertices_idxs","text":"vertices_idxs(el::LagrangeElement)\n\nThe indices of the nodes in el that define the vertices of the element.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/compression_methods/#Compression-methods","page":"Compression methods","title":"Compression methods","text":"","category":"section"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"CurrentModule = Inti","category":"page"},{"location":"tutorials/correction_methods/#Correction-methods","page":"Correction methods","title":"Correction methods","text":"","category":"section"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"CurrentModule = Inti","category":"page"},{"location":"tutorials/geo_and_meshes/#Geometry-and-meshes","page":"Geometry and meshes","title":"Geometry and meshes","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"CurrentModule = Inti","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"note: Important points covered in this tutorial\nCombine simple shapes to create domains\nImport a mesh from a Gmsh file\n...","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"In the getting started tutorial, we saw how to solve a simple Helmholtz scattering problem in 2D. Since domains and meshes are fundamental to solving boundary and volume integral equations, we will now dig deeper into how to create and manipulate them in Inti.jl.","category":"page"},{"location":"tutorials/geo_and_meshes/#Parametric-curves","page":"Geometry and meshes","title":"Parametric curves","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Inti.jl offers a limited support for creating simple shapes for which an explicit parametric representation is available. The simplest of such shapes are parametric_curves, which are defined by a function that maps a scalar parameter t to a point in 2D or 3D space. Parametric curves are expected to return an SVector, and can be created as follows:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"using Inti, StaticArrays, Meshes, GLMakie\nl1 = Inti.parametric_curve(x->SVector(x, 0.1 * sin(2π * x)), 0.0, 1.0, labels = [\"l₁\"])\nl2 = Inti.parametric_curve(x->SVector(1 + 0.1 * sin(2π * x), x), 0.0, 1.0, labels = [\"l₂\"])\nl3 = Inti.parametric_curve(x->SVector(1 - x, 1 - 0.1 * sin(2π * x)), 0.0, 1.0, labels = [\"l₃\"])\nl4 = Inti.parametric_curve(x->SVector(0.1 * sin(2π * x), 1 - x), 0.0, 1.0, labels = [\"l₄\"])","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Each variable above represents a geometrical entity, and entities can be combined to form a Domain object which can be passed to the meshgen function. For instance, the following code creates two domains comprised of two curves each, and meshes them:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Γ1 = Inti.Domain(l1, l3)\nΓ2 = Inti.Domain(l2, l4)\nΓ1_msh = Inti.meshgen(Γ1; meshsize = 0.05)\nΓ2_msh = Inti.meshgen(Γ2; meshsize = 0.05)\nfig, ax, pl = viz(Γ1_msh; segmentsize = 4,  label = \"Γ₁\")\nviz!(Γ2_msh; segmentsize = 4, color = :red, label = \"Γ₂\")\naxislegend()\nfig # hide","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Domains can be manipulated using basic set operations, such as intersect","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"@assert isempty(Γ1 ∩ Γ2) # hide\nΓ1 ∩ Γ2 # empty","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"and union:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"@assert (Γ1 ∪ Γ2) == Inti.Domain(l1,l2,l3,l4) # hide\nΓ  = Γ1 ∪ Γ2 # the whole boundary","category":"page"},{"location":"tutorials/geo_and_meshes/#Transfinite-squares","page":"Geometry and meshes","title":"Transfinite squares","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Note that you can also combine the lines to form a transfinite square, which inherits its parametrization from the lines that form it:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"surf = Inti.transfinite_square(l1, l2, l3, l4; labels = [\"Ω\"])\nΩ = Inti.Domain(surf)\nmsh = Inti.meshgen(Ω; meshsize = 0.05)\nviz(msh; showsegments = true)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Note that the msh object contains all entities used to construct Ω, including the boundary segments:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Inti.entities(msh)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"This allows you to index the mesh by Domains, extracting either a new mesh:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"msh[Γ1]","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"or a view of the mesh:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"view(msh, Γ1)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"fig, ax, p = viz(view(msh,Γ1); segmentsize = 4, label = \"view of Γ₁\")\naxislegend()\nfig # hide","category":"page"},{"location":"tutorials/geo_and_meshes/#Importing-meshes","page":"Geometry and meshes","title":"Importing meshes","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"While creating simple geometries natively in Inti.jl is useful for testing and academic problems, most real-world applications require manipulating complex geometries through CAD and meshing software. Inti.jl possesses a Gmsh extension that will load additional functionality if Gmsh.jl is loaded. This extension allows you to import meshes from Gmsh files:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"using Gmsh\nfilename = joinpath(Inti.PROJECT_ROOT,\"docs\", \"assets\", \"piece.msh\")\nmsh = Inti.import_mesh(filename)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Note that the msh object contains all entities used to construct the mesh:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"ents = Inti.entities(msh)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"You need to filter entities satisfying a certain condition, e.g., entities of a given dimension of containing a certain label, in order to construct a domain:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"filter = e -> Inti.geometric_dimension(e) == 2\nΓ = Inti.Domain(filter, ents)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"As before, you can visualize the mesh using Meshes.jl:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"using Meshes, GLMakie\nviz(view(msh,Γ); showsegments = true, alpha = 0.5)","category":"page"},{"location":"tutorials/geo_and_meshes/#Elements-of-a-mesh","page":"Geometry and meshes","title":"Elements of a mesh","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Although we have created several meshes this far in the tutorial, we have not done much with them except for visualizing. Conceptually, a mesh is simply a collection of elements, of possibly different type. To iterate over the elements of a mesh and perform some computation, you can simply use the elements function:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"els = Inti.elements(view(msh, Γ))\ncenters = map(el -> Inti.center(el), els)\nscatter([c[1] for c in centers], [c[2] for c in centers], [c[3] for c in centers], markersize = 5)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"This example shows how to extract the centers of the elements in the mesh, and of course you can perform any computation you like on the elements.","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"tip: Type-stable iteration over elements\nSince a mesh in Inti.jl can contain elements of various types, the   elements function above is not type-stable. For a type-stable iterator   approach, you should first iterate over the element types using   element_types, and then use elements(msh, E) to iterate over a   specific element type E.","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Under the hood, each element is simply a functor which maps points x̂ from a ReferenceShape into the physical space:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"el = first(els)\nx̂ = SVector(1/3,1/3)\nel(x̂)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"You can compute the Jacobian of an element","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Inti.jacobian(el, x̂)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"or its normal vector if the element is of co-dimension one:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Inti.normal(el, x̂)","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"EditURL = \"../poisson.jl\"","category":"page"},{"location":"examples/generated/poisson/#poisson","page":"Poisson solver","title":"Poisson solver","text":"","category":"section"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"(Image: ipynb) (Image: nbviewer)","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"note: Important points covered in this example\nSolving a volumetric problem\nUsing the method of manufactured solutions\n...","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"using Inti","category":"page"},{"location":"examples/generated/poisson/#Problem-definition","page":"Poisson solver","title":"Problem definition","text":"","category":"section"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"In this example we will solve the Poisson equation in a domain Omega with Dirichlet boundary conditions on Gamma = partial Omega:","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"  beginalign\n      Delta u = f  quad textin  Omega \n      u = g  quad texton  partial Gamma\n  endalign","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"where f  Omega to mathbbR and g  Gamma to mathbbR are given functions.","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"Seeking for a solution u of the form ...","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"meshsize = 0.1","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"n in the VDIM paper","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"interpolation_order = 3\nqorder = Inti.Triangle_VR_interpolation_order_to_quadrature_order(interpolation_order)\nnothing #hide","category":"page"},{"location":"examples/generated/poisson/#Meshing","page":"Poisson solver","title":"Meshing","text":"","category":"section"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"We now create the required meshes and quadratures for both Omega and Gamma:","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"using Gmsh # this will trigger the loading of Inti's Gmsh extension\n\nfunction gmsh_disk(; name, meshsize, order = 1, center = (0, 0), paxis = (2, 1))\n    try\n        gmsh.initialize()\n        gmsh.option.setNumber(\"General.Terminal\", 0)\n        gmsh.model.add(\"circle-mesh\")\n        gmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\n        gmsh.option.setNumber(\"Mesh.MeshSizeMin\", meshsize)\n        gmsh.model.occ.addDisk(center[1], center[2], 0, paxis[1], paxis[2])\n        gmsh.model.occ.synchronize()\n        gmsh.model.mesh.generate(2)\n        gmsh.model.mesh.setOrder(order)\n        gmsh.write(name)\n    finally\n        gmsh.finalize()\n    end\nend\n\nname = joinpath(@__DIR__, \"disk.msh\")\ngmsh_disk(; meshsize, order = 2, name)\n\nInti.clear_entities!() # empty the entity cache\nmsh = Inti.import_mesh(name; dim = 2)\nΩ = Inti.Domain(e -> Inti.geometric_dimension(e) == 2, Inti.entities(msh))\nΓ = Inti.boundary(Ω)\n\nΩₕ = view(msh, Ω)\nΓₕ = view(msh, Γ)","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"Use VDIM with the Vioreanu-Rokhlin quadrature rule","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"Q = Inti.VioreanuRokhlin(; domain = :triangle, order = qorder);\ndict = Dict(E => Q for E in Inti.element_types(Ωₕ))\nΩₕ_quad = Inti.Quadrature(Ωₕ, dict)\nΓₕ_quad = Inti.Quadrature(Γₕ; qorder)","category":"page"},{"location":"examples/generated/poisson/#Manufactured-solution","page":"Poisson solver","title":"Manufactured solution","text":"","category":"section"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"For the purpose of comparing our numerical results to an exact solution, we will use the method of manufactured solutions. For simplicity, we will take as an exact solution","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"uₑ = (x) -> cos(2 * x[1]) * sin(2 * x[2])","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"which yields","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"fₑ = (x) -> -8 * uₑ(x)","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"Here is what the solution looks like: qvals = map(Ωₕ_quad) do q     return uₑ(q.coords) end","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"ivals = Inti.quadraturetonodevals(Ωₕquad, qvals)","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"er = ivals - uₑ.(Ωₕquad.mesh.nodes) norm(er,Inf) Inti.writegmsh_view(Ωₕ, uₑ.(Ωₕ.nodes))","category":"page"},{"location":"examples/generated/poisson/#Boundary-and-integral-operators","page":"Poisson solver","title":"Boundary and integral operators","text":"","category":"section"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"using FMM2D\n\npde = Inti.Laplace(; dim = 2)\n\n# Boundary operators\nS_b2b, D_b2b = Inti.single_double_layer(;\n    pde,\n    target = Γₕ_quad,\n    source = Γₕ_quad,\n    compression = (method = :fmm, tol = 1e-12),\n    correction = (method = :dim,),\n)\nS_b2d, D_b2d = Inti.single_double_layer(;\n    pde,\n    target = Ωₕ_quad,\n    source = Γₕ_quad,\n    compression = (method = :fmm, tol = 1e-12),\n    correction = (method = :dim, maxdist = 5 * meshsize, target_location = :inside),\n)\n\n# Volume potentials\nV_d2d = Inti.volume_potential(;\n    pde,\n    target = Ωₕ_quad,\n    source = Ωₕ_quad,\n    compression = (method = :fmm, tol = 1e-12),\n    correction = (method = :dim, interpolation_order),\n)\nV_d2b = Inti.volume_potential(;\n    pde,\n    target = Γₕ_quad,\n    source = Ωₕ_quad,\n    compression = (method = :fmm, tol = 1e-12),\n    correction = (\n        method = :dim,\n        maxdist = 5 * meshsize,\n        interpolation_order,\n        target_location = :on,\n    ),\n)","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"We can now solve a BIE for the unknown density sigma:","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"f = map(Ωₕ_quad) do q\n    return fₑ(q.coords)\nend\ng = map(Γₕ_quad) do q\n    return uₑ(q.coords)\nend\nrhs = V_d2b * f + g\n\nusing LinearAlgebra\nL = -I / 2 + D_b2b","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"If compression=none or compresion=hmatrix is used above for constructing D_b2b, we could alternately use dense linear algebra:","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"#F = lu(L)\n#σ = F \\ rhs\n\nusing IterativeSolvers\nσ, hist =\n    gmres(L, rhs; log = true, abstol = 1e-10, verbose = false, restart = 100, maxiter = 100)\n@show hist","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"To check the solution, lets evaluate it at the nodes Omega","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"uₕ_quad = -(V_d2d * f) + D_b2d * σ\nuₑ_quad = map(q -> uₑ(q.coords), Ωₕ_quad)\ner = abs.(uₕ_quad - uₑ_quad)\n@assert norm(er) < 1e-5 #hide\n@show norm(er, Inf)","category":"page"},{"location":"examples/generated/poisson/#Visualize-the-solution-error-using-Gmsh","page":"Poisson solver","title":"Visualize the solution error using Gmsh","text":"","category":"section"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"er_nodes = Inti.quadrature_to_node_vals(Ωₕ_quad, er)\nuₕ_nodes = Inti.quadrature_to_node_vals(Ωₕ_quad, uₕ_quad)\n\nusing GLMakie, Meshes\nfig = Figure(; size = (1200, 400))\nax1 = Axis(fig[1, 1]; aspect = DataAspect(), title = \"solution\")\ncolorrange = extrema(uₕ_nodes)\nviz!(Ωₕ; showsegments = true, color = uₕ_nodes, colorrange)\nColorbar(fig[1, 2]; colorrange = colorrange)\nax2 = Axis(fig[1, 3]; aspect = DataAspect(), title = \"error\")\ncolorrange = extrema(er_nodes)\nviz!(Ωₕ; showsegments = false, color = er_nodes, colorrange)\nColorbar(fig[1, 4]; colorrange = colorrange)\nfig","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"","category":"page"},{"location":"examples/generated/poisson/","page":"Poisson solver","title":"Poisson solver","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"EditURL = \"../helmholtz_scattering.jl\"","category":"page"},{"location":"examples/generated/helmholtz_scattering/#helmholtz_scattering","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"","category":"section"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"(Image: ipynb) (Image: nbviewer)","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"note: Important points covered in this example\nCreating a geometry using the Gmsh API\nAssembling integral operators and integral potentials\nSetting up a sound-soft problem in both 2 and 3 spatial dimensions\nUsing GMRES to solve the linear system\nExporting the solution to Gmsh for visualization","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"In this tutorial we will show how to solve an acoustic scattering problem in the context of Helmholtz equation. We will focus on a smooth sound-soft obstacle for simplicity, and introduce along the way the necessary techniques used to handle some difficulties encountered. We will use various packages throughout this example (including of course Inti.jl); if they are not on your environment, you can install them using ] add <package> in the REPL.","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"In the following section, we will provide a brief mathematical description of the problem (valid in both 2 and 3 dimensions). We will tackle the two-dimensional problem first, for which we do not need to worry much about performance issues (e.g. compressing the integral operators, or exporting the solution to Gmsh for visualization). Finally, we present a three-dimensional example, where we will use HMatrices.jl to compress the underlying integral operators.","category":"page"},{"location":"examples/generated/helmholtz_scattering/#helmholtz-soundsoft","page":"Helmholtz scattering","title":"Sound-soft problem","text":"","category":"section"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"This example concerns the sound-soft acoustic scattering problem. Mathematically, this means solving an exterior problem governed by Helmholtz equation (time-harmonic acoustics) with a Dirichlet boundary condition. More precisely, letting Omega subset mathbbR^d be a bounded domain, and denoting by Gamma = partial Omega its boundary, we wish to solve","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"    Delta u + k^2 u = 0 quad texton quad mathbbR^d setminus barOmega","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"subject to Dirichlet boundary conditions on Gamma","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"    u(boldsymbolx) = g(boldsymbolx) quad textfor quad boldsymbolx in Gamma","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"and the Sommerfeld radiation condition at infinity","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"    lim_boldsymbolx to infty boldsymbolx^(d-1)2 left( fracpartial upartial boldsymbolx - i k u right) = 0","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Here g is a (given) boundary datum, and k is the constant wavenumber.","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"For simplicity, we will take Gamma circle/sphere, and focus on the plane-wave scattering problem. This means we will seek a solution u of the form u = u_s + u_i, where u_i is a known incident field, and u_s is the scattered field we wish to compute.","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"note: Complex geometries\nThe main reason for focusing on such a simple example is two-folded. First,   it alleviates the complexities associated with the mesh generation. Second,   since exact solutions are known for this problem (in the form of a series),   it is easy to assess the accuracy of the solution obtained. In practice, you   can use the same techniques to solve the problem on more complex geometries   by providing a .msh file containing the mesh.","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Using the theory of boundary integral equations, we can express u_s as","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"    u_s(boldsymbolr) = mathcalDsigma(boldsymbolr) - i k mathcalSsigma(boldsymbolr)","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"where mathcalS is the so-called single layer potential, mathcalD is the double-layer potential, and sigma  Gamma to mathbbC is a surface density. This is an indirect formulation (because sigma is an auxiliary density, not necessarily physical) commonly referred to as a combined field formulation. Taking the limit mathbbR^d setminus bar Omega ni x to Gamma, it can be shown that the following equation holds on Gamma:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"    left( fracmathrmI2 + mathrmD - i k mathrmS right)sigma = g","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"where mathrmI is the identity operator, and mathrmS and mathrmD are the single- and double-layer operators. This is the combined field integral equation that we will solve. The boundary data g is obtained by applying the sound-soft condition u=0 on Gamma, from which it readily follows that u_s = -u_i on Gamma.","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We are now have the necessary background to solve this problem in both 2 and 3 spatial dimensions. Let's load Inti.jl and setup some of the (global) problem parameters:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"using Inti\n\nk        = 4π\nλ        = 2π / k\nmeshsize = λ / 5\nqorder   = 4 # quadrature order\ngorder   = 2 # order of geometrical approximation\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/#helmholtz-scattering-2d","page":"Helmholtz scattering","title":"Two-dimensional scattering","text":"","category":"section"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We use Gmsh API for creating .msh file containing the desired geometry and mesh. Here is a function to mesh the circle:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"using Gmsh # this will trigger the loading of Inti's Gmsh extension\n\nfunction gmsh_circle(; name, meshsize, order = 1, radius = 1, center = (0, 0))\n    try\n        gmsh.initialize()\n        gmsh.model.add(\"circle-mesh\")\n        gmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\n        gmsh.option.setNumber(\"Mesh.MeshSizeMin\", meshsize)\n        gmsh.model.occ.addDisk(center[1], center[2], 0, radius, radius)\n        gmsh.model.occ.synchronize()\n        gmsh.model.mesh.generate(1)\n        gmsh.model.mesh.setOrder(order)\n        gmsh.write(name)\n    finally\n        gmsh.finalize()\n    end\nend\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Let us now use gmsh_circle to create a circle.msh file. As customary in wave-scattering problems, we will choose a mesh size that is proportional to wavelength:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"name = joinpath(@__DIR__, \"circle.msh\")\ngmsh_circle(; meshsize, order = gorder, name)\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We can now import the file and parse the mesh and domain information into Inti.jl using the import_mesh function:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Inti.clear_entities!() # empty the entity cache\nmsh = Inti.import_mesh(name; dim = 2)\n@show msh","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The code above will import the mesh with all of its geometrical entities. The dim=2 projects all points to two dimensions by ignoring the third component. To extract the domain Omega we need to filter the entities in the mesh; here we will simply filter them based on the geometric_dimension:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Ω = Inti.Domain(e -> Inti.geometric_dimension(e) == 2, Inti.entities(msh))","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"To solve our boundary integral equation usign a Nyström method, we actually need a quadrature of our curve/surface (and possibly the normal vectors at the quadrature nodes). Once a mesh is available, creating a quadrature object can be done via the Quadrature constructor, which requires passing a mesh the domain that one wishes to generate a quadrature for:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Γ = Inti.boundary(Ω)\nΓ_msh = view(msh, Γ)\nQ = Inti.Quadrature(Γ_msh; qorder)\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"tip: Views of a mesh\nIn Inti.jl, you can use domain to create a view of a mesh containing only   the elements in the domain. For example view(msh,Γ) will return an   SubMesh type that you can use to iterate over the elements in the boundary   of the disk without actually creating a new mesh. You can use msh[Γ],   or collect(view(msh,Γ)) to create a new mesh containing only the   elements and nodes in Γ.","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The object Q now contains a quadrature (of order 4) that can be used to solve a boundary integral equation on Γ. As a sanity check, let's make sure integrating the function x->1 over Q gives an approximation to the perimeter:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"@assert abs(Inti.integrate(x -> 1, Q) - 2π) < 1e-5 #hide\nInti.integrate(x -> 1, Q) - 2π","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"With the Quadrature constructed, we now can define discrete approximation to the integral operators mathrmS and mathrmD as follows:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"pde = Inti.Helmholtz(; k, dim = 2)\nS, D = Inti.single_double_layer(;\n    pde,\n    target = Q,\n    source = Q,\n    compression = (method = :none,),\n    correction = (method = :dim,),\n)\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"There are two well-known difficulties related to the discretization of the boundary integral operators S and D:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The kernel of the integral operator is not smooth, and thus specialized quadrature rules are required to accurately approximate the matrix entries for which the target and source point lie close (relative to some scale) to each other.\nThe underlying matrix is dense, and thus the storage and computational cost of the operator is prohibitive for large problems unless acceleration techniques such as Fast Multipole Methods or Hierarchical Matrices are employed.","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Inti.jl tries to provide a modular and transparent interface for dealing with both of these difficulties, where the general approach for solving a BIE will be to first construct a (possible compressed) naive representation of the integral operator where singular and nearly-singular integrals are ignored, followed by a the creation of a (sparse) correction intended to account for such singular interactions. See single_double_layer for more details on the various options available.","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We can now combine S and D to form the combined-field operator:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"using LinearAlgebra\nL = I / 2 + D - im * k * S\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"where I is the identity matrix. Assuming an incident field along the x_1 direction of the form u_i =e^ikx_1, the right-hand side of the equation can be construted using:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"uᵢ = x -> exp(im * k * x[1]) # plane-wave incident field\nrhs = map(Q) do q\n    x = q.coords\n    return -uᵢ(x)\nend\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"note: Iterating over a quadrature\nIn computing rhs above, we used map to evaluate the incident field at   all quadrature nodes. When iterating over Q, the iterator returns a   QuadratureNode, and not simply the   coordinate of the quadrature node. This is so that you can access   additional information, such as the normal vector, at the quadrature node.","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We can now solve the integral equation using e.g. the backslash operator:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"σ = L \\ rhs\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The variable σ contains the value of the approximate density at the quadrature nodes. To reconstruct a continuous approximation to the solution, we can use single_double_layer_potential to obtain the single- and double-layer potentials, and then combine them as follows:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"𝒮, 𝒟 = Inti.single_double_layer_potential(; pde, source = Q)\nuₛ   = x -> 𝒟[σ](x) - im * k * 𝒮[σ](x)\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The variable uₛ is an anonymous/lambda function representing the approximate scattered field.","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"To assess the accuracy of the solution, we can compare it to the exact solution (obtained by separation of variables in polar coordinates):","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"using SpecialFunctions # for bessel functions\n\nfunction circle_helmholtz_soundsoft(pt; radius = 1, k, θin)\n    x = pt[1]\n    y = pt[2]\n    r = sqrt(x^2 + y^2)\n    θ = atan(y, x)\n    u = 0.0\n    r < radius && return u\n    c(n) = -exp(im * n * (π / 2 - θin)) * besselj(n, k * radius) / besselh(n, k * radius)\n    u    = c(0) * besselh(0, k * r)\n    n    = 1\n    while (abs(c(n)) > 1e-12)\n        u +=\n            c(n) * besselh(n, k * r) * exp(im * n * θ) +\n            c(-n) * besselh(-n, k * r) * exp(-im * n * θ)\n        n += 1\n    end\n    return u\nend\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Here is the maximum error on some points located on a circle of radius 2:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"uₑ = x -> circle_helmholtz_soundsoft(x; k, radius = 1, θin = 0) # exact solution\ner = maximum(0:0.01:2π) do θ\n    R = 2\n    x = (R * cos(θ), R * sin(θ))\n    return abs(uₛ(x) - uₑ(x))\nend\n@assert er < 1e-3 #hide\n@info \"maximum error = $er\"","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"As we can see, the error is quite small! To visualize the solution in this simple (2d) example, we could simply use Makie:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"using GLMakie\nxx = yy = range(-4; stop = 4, length = 200)\nvals = map(pt -> norm(pt) > 1 ? real(uₛ(pt) + uᵢ(pt)) : NaN, Iterators.product(xx, yy))\nfig, ax, hm = heatmap(\n    xx,\n    yy,\n    vals;\n    colormap = :inferno,\n    interpolate = true,\n    axis = (aspect = DataAspect(), xgridvisible = false, ygridvisible = false),\n)\nlines!(\n    ax,\n    [cos(θ) for θ in 0:0.01:2π],\n    [sin(θ) for θ in 0:0.01:2π];\n    color = :black,\n    linewidth = 4,\n)\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"More complex problems, however, may require a mesh-based visualization, where we would first need to create a mesh for the places where we want to visualize the solution. In the 3D example that follows, we will use the Gmsh API to create a a mesh of a punctured plane where we will visualize the solution.","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Before moving on to the 3D example let us simply mention that, besides the fact that an analytic solution was available for comparisson, there was nothing special about the unit disk in the example above. We could have, for instance, replaced the disk by a kite-like shape:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"f = (s) -> (cospi(2 * s[1]) + 0.65 * cospi(4 * s[1]) - 0.65, 1.5 * sinpi(2 * s[1]))\nInti.clear_entities!() # empty the entity cacheg\ngmsh.initialize()\ngmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\ngmsh.option.setNumber(\"Mesh.MeshSizeMin\", meshsize)\n# parametrization of a kite-like shape\ntag = Inti.gmsh_curve(f, 0, 1; npts = 100, meshsize)\n# create a surface from the curve\ntl = gmsh.model.occ.addCurveLoop([tag])\nta = gmsh.model.occ.addPlaneSurface([tl])\ngmsh.model.occ.synchronize()\ngmsh.model.mesh.generate(2)\ngmsh.model.mesh.setOrder(gorder)\nmsh = Inti.import_mesh(; dim = 2)\ngmsh.finalize()","category":"page"},{"location":"examples/generated/helmholtz_scattering/#helmholtz-scattering-3d","page":"Helmholtz scattering","title":"Three-dimensional scattering","text":"","category":"section"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We now consider the same problem in 3D. Unlike the 2D case, assembling dense matrix representations of the integral operators quickly becomes unfeasiable as the problem size increases. Inti adds support for compressing the underlying linear operators by wrapping external libraries. In this example, we will rely on HMatrices.jl to handle the compression.","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The visualization is also more involved, and we will use instead the Gmsh API to create a view of the solution on a punctured plane. Let us begin by creating our domain containing both the sphere and the puctured plane where we will visualize the solution:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"function gmsh_sphere(; meshsize, order = gorder, radius = 1, visualize = false, name)\n    gmsh.initialize()\n    gmsh.model.add(\"sphere-scattering\")\n    gmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\n    gmsh.option.setNumber(\"Mesh.MeshSizeMin\", meshsize)\n    sphere_tag = gmsh.model.occ.addSphere(0, 0, 0, radius)\n    xl, yl, zl = -2 * radius, -2 * radius, 0\n    Δx, Δy = 4 * radius, 4 * radius\n    rectangle_tag = gmsh.model.occ.addRectangle(xl, yl, zl, Δx, Δy)\n    outDimTags, _ =\n        gmsh.model.occ.cut([(2, rectangle_tag)], [(3, sphere_tag)], -1, true, false)\n    gmsh.model.occ.synchronize()\n    gmsh.model.addPhysicalGroup(3, [sphere_tag], -1, \"omega\")\n    gmsh.model.addPhysicalGroup(2, [dt[2] for dt in outDimTags], -1, \"sigma\")\n    gmsh.model.mesh.generate(2)\n    gmsh.model.mesh.setOrder(order)\n    visualize && gmsh.fltk.run()\n    gmsh.option.setNumber(\"Mesh.SaveAll\", 1) # otherwise only the physical groups are saved\n    gmsh.write(name)\n    return gmsh.finalize()\nend\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"As before, lets write a file with our mesh, and import it into Inti.jl:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"name = joinpath(@__DIR__, \"sphere.msh\")\ngmsh_sphere(; meshsize, order = gorder, name, visualize = false)\nInti.clear_entities!()\nmsh = Inti.import_mesh(name; dim = 3)","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Since we created physical groups in Gmsh, we can use them to extract the relevant domains Ω and Σ:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Ω = Inti.Domain(e -> \"omega\" ∈ Inti.labels(e), Inti.entities(msh))\nΣ = Inti.Domain(e -> \"sigma\" ∈ Inti.labels(e), Inti.entities(msh))\nΓ = Inti.boundary(Ω)\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We can now create a quadrature as before","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Γ_msh = view(msh, Γ)\nQ = Inti.Quadrature(Γ_msh; qorder)\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"tip: Tip\nIf you pass visualize=true to gmsh_sphere, it will open a window   with the current mode. This is done by calling gmsh.fltk.run(). Note   that the main julia thread will be blocked until the window is closed.","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"tip: Writing/reading a mesh from disk\nWriting and reading a mesh to/from disk can be time consuming. You can   avoid doing so by using import_mesh without a   file name to import the mesh from the current gmsh session without the   need to write it to disk.","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We can now assemble the integral operators, indicating that we wish to compress them using hierarchical matrices:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"using HMatrices\npde = Inti.Helmholtz(; k, dim = 3)\nS, D = Inti.single_double_layer(;\n    pde,\n    target = Q,\n    source = Q,\n    compression = (method = :hmatrix, tol = 1e-6),\n    correction = (method = :dim,),\n)\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Here is how much memory it would take to store the dense representation of these matrices:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"mem = 2 * length(S) * 16 / 1e9 # 16 bytes per complex number, 1e9 bytes per GB, two matrices\nprintln(\"memory required to store S and D: $(mem) GB\")","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Even for this simple example, the dense representation of the integral operators as matrix is already quite expensive!","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"note: Compression methods\nIt is worth mentioning that hierchical matrices are not the only way to   compress such integral operators, and may in fact not even be the best   for the problem at hand. For example, one could use a fast multipole   method (FMM), which has a much lighter memory footprint, and is also   faster to assemble. The main advantage of hierarchical matrices is that   they are purely algebraic, allowing for the use of direct solver.   Hierarchical matrices also tend to give a faster matrix-vector product   after the (offline) assembly stage.","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We will use the generalized minimal residual (GMRES) iterative solver, for the linear system. This requires us to define a linear operator L, approximating the combined-field operator, that supports the matrix-vector product. In what follows we use LinearMaps to lazily assemble L:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"using LinearMaps\nL = I / 2 + LinearMap(D) - im * k * LinearMap(S)\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Note that wrapping S and D in LinearMap allows for combining them in a lazy fashion. Alternatively, you can use e.g. axpy! to add two hierarchical matrices.","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We can now solve the linear system using GMRES solver:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"using IterativeSolvers\nrhs = map(Q) do q\n    x = q.coords\n    return -uᵢ(x)\nend\nσ, hist =\n    gmres(L, rhs; log = true, abstol = 1e-6, verbose = false, restart = 100, maxiter = 100)\n@show hist","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"As before, let us represent the solution using IntegralPotentials:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"𝒮, 𝒟 = Inti.single_double_layer_potential(; pde, source = Q)\nuₛ = x -> 𝒟[σ](x) - im * k * 𝒮[σ](x)\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"To check the result, we compare against the exact solution obtained through a series:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"using GSL\nsphbesselj(l, r) = sqrt(π / (2r)) * besselj(l + 1 / 2, r)\nsphbesselh(l, r) = sqrt(π / (2r)) * besselh(l + 1 / 2, r)\nsphharmonic(l, m, θ, ϕ) = GSL.sf_legendre_sphPlm(l, abs(m), cos(θ)) * exp(im * m * ϕ)\nfunction sphere_helmholtz_soundsoft(xobs; radius = 1, k = 1, θin = 0, ϕin = 0)\n    x = xobs[1]\n    y = xobs[2]\n    z = xobs[3]\n    r = sqrt(x^2 + y^2 + z^2)\n    θ = acos(z / r)\n    ϕ = atan(y, x)\n    u = 0.0\n    r < radius && return u\n    function c(l, m)\n        return -4π * im^l * sphharmonic(l, -m, θin, ϕin) * sphbesselj(l, k * radius) /\n               sphbesselh(l, k * radius)\n    end\n    l = 0\n    for l in 0:60\n        for m in -l:l\n            u += c(l, m) * sphbesselh(l, k * r) * sphharmonic(l, m, θ, ϕ)\n        end\n        l += 1\n    end\n    return u\nend\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We will compute the error on some point on the sphere of radius 2:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"uₑ = (x) -> sphere_helmholtz_soundsoft(x; radius = 1, k = k, θin = π / 2, ϕin = 0)\ner = maximum(1:100) do _\n    x̂ = rand(Inti.Point3D) |> normalize # an SVector of unit norm\n    x = 2 * x̂\n    return abs(uₛ(x) - uₑ(x))\nend\n@assert er < 1e-3 #hide\n@info \"error with correction = $er\"","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We see that, once again, the approximation is quite accurate. Let us now visualize the solution on the punctured plane (which we labeled as \"sigma\"). Since evaluating the integral representation of the solution at many points is expensive, we will use a compression method to accelerate the evaluation as well. In the example below, we use the fast-multipole method:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"using FMM3D\nΣ_msh = view(msh, Σ)\ntarget = Inti.nodes(Σ_msh)\n\nS, D = Inti.single_double_layer(;\n    pde,\n    target,\n    source = Q,\n    compression = (method = :fmm, tol = 1e-6),\n    # correction for the nearfield (for visual purposes, set to `:none` to disable)\n    correction = (method = :dim, maxdist = meshsize, target_location = :outside),\n)\n\nui_eval_msh = uᵢ.(target)\nus_eval_msh = D * σ - im * k * S * σ\nu_eval_msh = ui_eval_msh + us_eval_msh\nnothing #hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Finalize, we use viz to visualize the scattered field:","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"using Meshes\nusing GLMakie # or your preferred Makie backend\n\nnv = length(Inti.nodes(Γ_msh))\ncolorrange = extrema(real(u_eval_msh))\ncolormap = :inferno\nfig, ax, pl = viz(Γ_msh; colorrange, colormap, color = zeros(nv))\nviz!(Σ_msh; colorrange, colormap, color = real(u_eval_msh))\ncb = Colorbar(fig[1, 2]; label = \"real(u)\", colormap, colorrange)\nfig # hide","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"","category":"page"},{"location":"examples/generated/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"CurrentModule = Inti","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"note: Important points covered in this tutorial\nCreate a domain and its accompanying mesh\nSolve a basic boundary integral equation\nVisualize the solution","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"This first tutorial will guide you through the basic steps of setting up a boundary integral equation problem and solving it using Inti.jl. We will consider the classic Helmholtz scattering problem in 2D, and solve it using a direct boundary integral formulation. More precisely, letting Omega subset mathbbR^2 be a bounded domain, and denoting by Gamma = partial Omega its boundary, we will solve the following Helmholtz problem:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"beginaligned\n    Delta u + k^2 u  = 0 quad textin quad mathbbR^2 setminus overlineOmega\n    partial_nu u = g quad texton quad Gamma\n    sqrtr left( fracpartial upartial r - i k u right) = o(1) quad textas quad r = boldsymbolx to infty\nendaligned","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"where g is a (given) boundary datum, nu is the outward unit normal to Gamma, and k is the constant wavenumber.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"tip: Sommerfeld radiation condition\nThe last condition is the Sommerfeld radiation condition, and is required to ensure the uniqueness of the solution; physically, it means that the solution sought should radiate energy towards infinity.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Let us begin by specifying the partial differential equation, and creating the domain, mesh, and quadrature for the problem:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"using Inti, LinearAlgebra, StaticArrays\n\n# PDE\nk = 2π\npde = Inti.Helmholtz(; dim = 2, k)\n\n# Create the geometry as the union of a kite and a circle\nkite = Inti.parametric_curve(0.0, 1.0) do s\n    return SVector(2.5 + cos(2π * s[1]) + 0.65 * cos(4π * s[1]) - 0.65, 1.5 * sin(2π * s[1]))\nend\ncircle = Inti.parametric_curve(0.0, 1.0) do s\n    return SVector(cos(2π * s[1]), sin(2π * s[1]))\nend\nΓ = kite ∪ circle\n# Create a mesh for the geometry\nmsh = Inti.meshgen(Γ; meshsize = 2π / k / 10)\n# Create a quadrature\nQ = Inti.Quadrature(msh; qorder = 5)\nnothing # hide","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"We can easily check the mesh by visualizing it using the Meshes.jl package:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"using Meshes, GLMakie\nfig, ax, pl = viz(msh; segmentsize = 3, axis = (aspect = DataAspect(), ))","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Next we need to reformulate the Helmholtz problem as a boundary integral equation. Among the plethora of options, we will use in this tutorial a simple direct formulation, which uses Green's third identity to relate the values of u and partial_nu u on Gamma:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"    -fracu(boldsymbolx)2 + Du(boldsymbolx) = Spartial_nu u(boldsymbolx) quad boldsymbolx in Gamma","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Here S and D are the single- and double-layer operators, formally defined as:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"    Ssigma(boldsymbolx) = int_Gamma G(boldsymbolx boldsymboly) sigma(boldsymboly)  mathrmds(boldsymboly) quad\n    Dsigma(boldsymbolx) = int_Gamma fracpartial Gpartial nu_boldsymboly(boldsymbolx boldsymboly) sigma(boldsymboly)  mathrmds(boldsymboly)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"where G is the fundamental solution of the Helmholtz equation. Note that G is typically singular when boldsymbolx = boldsymboly, and therefore the numerical discretization of these integral operators requires special care.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"To approximate S and D in Inti.jl we can proceed as follows:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"S, D = Inti.single_double_layer(;\n    pde,\n    target = Q,\n    source = Q,\n    compression = (method = :none,),\n    correction = (method = :dim,),\n)\nnothing # hide","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"tip: Fast algorithms\nPowered by external libraries, Inti.jl supports several acceleration methods for matrix-vector multiplication, including so far:Fast multipole method (FMM) mapsto correction = (method = :fmm, tol = 1e-8)\nHierarchical matrix (H-matrix) mapsto `correction = (method = :hmatrix, tol =1e-8)`Note that in such cases only the matrix-vector product may not be available, and therefore iterative solvers such as GMRES may be required for the solution of the resulting linear systems.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Much of the complexity involved in the numerical computation is hidden in the function above; later in the tutorials we will discuss in more details the options available for the compression and correction methods, as well as how to define your own kernels and operators. For now, it suffices to know that S and D are matrix-like objects that can be used to solve the boundary integral equation. For that, we need to provide the boundary data g.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"We are interested in the scattered field u produced by an incident plane wave u_i = e^i k boldsymbold cdot boldsymbolx, where boldsymbold is a unit vector denoting the direction of the plane wave. Assuming that the total field u_t = u_i + u satisfies a homogenous Neumann condition on Gamma, and that the scattered field u satisfies the Sommerfeld radiation condition, we can write the boundary condition as:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"    partial_nu u = -partial_nu u_i quad boldsymbolx in Gamma","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"We can thus solve the boundary integral equation to find u on Gamma:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# define the incident field and compute its normal derivative\nθ = 0\nd = SVector(cos(θ), sin(θ))\ng = map(Q) do q\n    # normal derivative of e^{ik*d⃗⋅x}\n    x, ν = q.coords, q.normal\n    return -im * k * exp(im * k * dot(x, d)) * dot(d, ν)\nend ## Neumann trace on boundary\nu = (-I / 2 + D) \\ (S * g) # Dirichlet trace on boundary","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Now that we know both the Dirichlet and Neumann data on the boundary, we can use Green's representation formula, i.e., ","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"    mathcalDu(boldsymbolr) - mathcalSpartial_nu u(boldsymbolr) = begincases\n        u(boldsymbolr)  textif  boldsymbolr in mathbbR^2 setminus overlineOmega\n        0  textif  boldsymbolr in Omega\n    endcases","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"where mathcalD and mathcalS are the double- and single-layer potentials defined as:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"    mathcalSsigma(boldsymbolr) = int_Gamma G(boldsymbolr boldsymboly) sigma(boldsymboly)  mathrmds(boldsymboly) quad\n    mathcalDsigma(boldsymbolr) = int_Gamma fracpartial Gpartial nu_boldsymboly(boldsymbolr boldsymboly) sigma(boldsymboly)  mathrmds(boldsymboly)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"to compute the solution u in the domain:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"𝒮, 𝒟 = Inti.single_double_layer_potential(; pde, source = Q)\nuₛ = x -> 𝒟[u](x) - 𝒮[g](x)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"To wrap things up, let's visualize the scattered field:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"using GLMakie # or your favorite plotting backend for Makie\nxx = yy = range(-5; stop = 5, length = 100)\nU = map(uₛ, Iterators.product(xx, yy))\nUi = map(x -> exp(im*k*dot(x, d)), Iterators.product(xx, yy))\nUt = Ui + U\nfig, ax, hm = heatmap(\n    xx,\n    yy,\n    real(Ut);\n    colormap = :inferno,\n    interpolate = true,\n    axis = (aspect = DataAspect(), xgridvisible = false, ygridvisible = false),\n)\nviz!(msh; segmentsize = 2)\nColorbar(fig[1, 2], hm; label = \"real(u)\")\nfig # hide","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"tip: Going further\n...","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# build an exact solution\nG = Inti.SingleLayerKernel(pde)\ndG = Inti.DoubleLayerKernel(pde)\nxs = map(θ -> 0.5 * rand() * SVector(cos(θ), sin(θ)), 2π * rand(10))\ncs = rand(ComplexF64, length(xs))\nuₑ  = q -> sum(c * G(x, q) for (x, c) in zip(xs, cs))\n∂ₙu = q -> sum(c * dG(x, q) for (x, c) in zip(xs, cs))\ng  = map(∂ₙu, Q) \nu = (-I / 2 + D) \\ (S * g)\nuₛ = x -> 𝒟[u](x) - 𝒮[g](x)\npts = [5*SVector(cos(θ), sin(θ)) for θ in range(0, 2π, length = 100)]\ner = norm(uₛ.(pts) - uₑ.(pts), Inf)\nprintln(\"maximum error on circle of radius 5: $er\")","category":"page"},{"location":"#Inti","page":"Home","title":"Inti","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Inti","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: codecov) (Image: Aqua)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Inti.jl is a Julia library for the numerical solution of boundary and volume integral equations. It provides routines for assembling and solving the linear systems of equations that arise from applying a Nyström discretization method to an integral equation. The package is designed to be flexible and efficient, and supports the following features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Specialized integration routines for computing singular and nearly-singular integrals\nIntegrated support for acceleration routines such as the Fast Multipole Method (FMM) and Hierarchical Matrices by the wrapping of external libraries.\nPredefined kernels for some partial differential equations (PDEs) commonly found in mathematical physics such as the Laplace, Helmholtz, and Stokes equations.\nSupport for complex geometries in 2D and 3D, either through native parametric representations or by importing complex meshes using Gmsh.\nEfficient construction of complex integral operators from simpler ones through lazy composition.","category":"page"},{"location":"#Installing-Julia","page":"Home","title":"Installing Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Download of Julia from julialang.org, or use juliaup installer. We recommend using the latest stable version of Julia, although Inti.jl should work with >=v1.6.","category":"page"},{"location":"#Installing-Inti.jl","page":"Home","title":"Installing Inti.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Inti.jl is not yet registered in the Julia General registry. You can install it using by launching a Julia REPL and typing the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"Inti\"; rev = \"main\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will download and install the latest version of Inti.jl from the main branch. Change rev if you need a different branch or specific commit hash.","category":"page"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Inti.jl can be used to solve a variety of linear partial differential equations by recasting them as integral equations. The general workflow for solving a problem consists of the following steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"    underbracefboxGeometry rightarrow fboxMesh_textbfpre-processing rightarrow fboxcolorredSolver rightarrow underbracefboxVisualization_textbfpost-processing","category":"page"},{"location":"","page":"Home","title":"Home","text":"Geometry: The first step is to define the domain of interest, which can be done using a combination of simple shapes (e.g., circles, rectangles) or more complex CAD models.\nMesh: The mesh is a collection of points and segments that approximate the domain. The mesh is used to create a quadrature and discretize the boundary integral equation.\nSolver: Once a mesh and an accompanying quadrature are available, Inti.jl provides routines for assembling and solving the linear system of equations arising from the discretization of the integral operators. Once found, the solution can be evaluated using an integral representation.\nVisualization: Finally, the solution can be visualized using a plotting library, such as Makie.jl, or exported to a file for further analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As a simple example, consider an interior Laplace problem in two dimensions with Dirichlet boundary conditions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nDelta u = 0 quad textin  Omega \nu = g quad texton  Gamma\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where Omega subset mathbbR^2 is a sufficiently smooth domain, and Gamma = partial Omega its boundary. A boundary integral reformulation can be achieved by e.g. searching for the solution u in the form of a single-layer potential:","category":"page"},{"location":"","page":"Home","title":"Home","text":"u(boldsymbolr) = int_Gamma G(boldsymbolrboldsymboly)sigma(boldsymboly)  mathrmdGamma(boldsymboly)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where sigma  Gamma to mathbbR is an unknown density function, and G is the fundamental solution of the Laplace equation. This ansatz is, by construction, an exact solution to the PDE. Imposing the boundary condition on Gamma leads to the following integral equation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"    int_Gamma G(boldsymbolxboldsymboly)sigma(boldsymboly)  mathrmdGamma(boldsymboly) = g(boldsymbolx) quad forall boldsymbolx in Gamma","category":"page"},{"location":"","page":"Home","title":"Home","text":"Formulating the problem above in Inti.jl looks like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Inti, LinearAlgebra, StaticArrays\n# create a geometry\ngeo = Inti.parametric_curve(0, 1) do s\n    return SVector(0.25, 0.0) +\n            SVector(cos(2π * s) + 0.65 * cos(4π * s[1]) - 0.65, 1.5 * sin(2π * s))\nend\nΓ = Inti.Domain(geo)\n# create a mesh and quadrature\nmsh = Inti.meshgen(Γ; meshsize = 0.1)\nQ = Inti.Quadrature(msh; qorder = 5)\n# create the integral operators\npde = Inti.Laplace(;dim=2)\nS, _ = Inti.single_double_layer(;\n    pde, \n    target = Q,\n    source = Q,\n    compression = (method = :none,),\n    correction = (method = :dim,)\n)\n# manufacture an exact solution and take its trace on Γ\nuₑ = x -> x[1] + x[2] + x[1]*x[2] + x[1]^2 - x[2]^2 + 0.5 * log(norm(x .- SVector(0.5, 1.5))) - 2 * log(norm(x .- SVector(-0.5, -1.5)))\ng = map(q -> uₑ(q.coords), Q) # value at quad nodes\n# solve for σ\nσ = S \\ g\n# use the single-layer potential to evaluate the solution\n𝒮, 𝒟 = Inti.single_double_layer_potential(; pde, source = Q)\nuₕ = x -> 𝒮[σ](x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The function uₕ is now a numerical approximation of the solution to the Laplace equation, and can be evaluated at any point in the domain:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pt = SVector(0.5, 0.1)\nprintln(\"Exact value at $pt:   \", uₑ(pt))\nprintln(\"Approx. value at $pt: \", uₕ(pt))","category":"page"},{"location":"","page":"Home","title":"Home","text":"If we care about the solution on the entire domain, we can visualize it using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Meshes, GLMakie # trigger the loading of some Inti extensions\nxx = yy = range(-2, 2, length = 100)\nfig = Figure()\ninside = x -> Inti.isinside(x, Q) \nopts = (xlabel = \"x\", ylabel = \"y\", aspect = DataAspect())\nax1 = Axis(fig[1, 1]; title = \"Exact solution\", opts...)\nh1 = heatmap!(ax1, xx,yy,(x, y) -> inside((x,y)) ? uₑ((x,y)) : NaN)\nviz!(msh; segmentsize = 3)\ncb = Colorbar(fig[1, 3], h1)\nax2 = Axis(fig[1, 2]; title = \"Approx. solution\", opts...)\nh2 = heatmap!(ax2, xx,yy, (x, y) -> inside((x,y)) ? uₕ((x,y)) : NaN, colorrange = cb.limits[])\nviz!(msh; segmentsize = 3)\nfig # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Formulation of the problem as an integral equation\nGiven a PDE and boundary conditions, there are often many ways to recast the problem as an integral equation, and the choice of formulation plays an important role in the unique solvability, efficiency, and accuracy of the numerical solution. Inti.jl provides a flexible framework for experimenting with different formulations, but it is up to the user to choose the most appropriate one for their problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"While the example above is a simple one, Inti.jl can handle significantly more complex problems involving multiple domains, heterogeneous coefficients, vector-valued PDEs, three-dimensional geometries, and possibly requiring the use of acceleration techniques such as the Fast Multipole Method. The best way to dive deeper into Inti.jl's capabilities is the tutorials section. You can also find more advanced usage in the examples section.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"}]
}

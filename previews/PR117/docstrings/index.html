<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings ¬∑ Inti.jl</title><meta name="title" content="Docstrings ¬∑ Inti.jl"/><meta property="og:title" content="Docstrings ¬∑ Inti.jl"/><meta property="twitter:title" content="Docstrings ¬∑ Inti.jl"/><meta name="description" content="Documentation for Inti.jl."/><meta property="og:description" content="Documentation for Inti.jl."/><meta property="twitter:description" content="Documentation for Inti.jl."/><meta property="og:url" content="https://IntegralEquations.github.io/Inti.jl/docstrings/"/><meta property="twitter:url" content="https://IntegralEquations.github.io/Inti.jl/docstrings/"/><link rel="canonical" href="https://IntegralEquations.github.io/Inti.jl/docstrings/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Inti.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/getting_started/">Getting started</a></li><li><a class="tocitem" href="../tutorials/geo_and_meshes/">Geometry and meshes</a></li><li><a class="tocitem" href="../tutorials/integral_operators/">Integral operators</a></li><li><a class="tocitem" href="../tutorials/layer_potentials/">Layer potentials</a></li><li><a class="tocitem" href="../tutorials/compression_methods/">Compression methods</a></li><li><a class="tocitem" href="../tutorials/correction_methods/">Correction methods</a></li><li><a class="tocitem" href="../tutorials/solvers/">Linear solvers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../pluto-examples/toy_example/">Toy example</a></li><li><a class="tocitem" href="../pluto-examples/helmholtz_scattering/">Helmholtz scattering</a></li><li><a class="tocitem" href="../pluto-examples/poisson/">Poisson problem</a></li><li><a class="tocitem" href="../examples/heat_equation/">Heat equation</a></li><li><a class="tocitem" href="../examples/crack_elasticity/">Elastic crack</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li><li class="is-active"><a class="tocitem" href>Docstrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Docstrings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Docstrings</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl/blob/main/docs/src/docstrings.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Inti" href="#Inti.Inti"><code>Inti.Inti</code></a> ‚Äî <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">module Inti</code></pre><p>Library for solving integral equations using Nystr√∂m methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/Inti.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.COMPRESSION_METHODS" href="#Inti.COMPRESSION_METHODS"><code>Inti.COMPRESSION_METHODS</code></a> ‚Äî <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const COMPRESSION_METHODS = [:none, :hmatrix, :fmm]</code></pre><p>Available compression methods for the dense linear operators in <a href="../#Inti"><code>Inti</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/api.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.CORRECTION_METHODS" href="#Inti.CORRECTION_METHODS"><code>Inti.CORRECTION_METHODS</code></a> ‚Äî <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const CORRECTION_METHODS = [:none, :dim, :adaptive]</code></pre><p>Available correction methods for the singular and nearly-singular integrals in <a href="../#Inti"><code>Inti</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/api.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ENTITIES" href="#Inti.ENTITIES"><code>Inti.ENTITIES</code></a> ‚Äî <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const ENTITIES</code></pre><p>Dictionary mapping <a href="#Inti.EntityKey"><code>EntityKey</code></a> to <a href="#Inti.GeometricEntity"><code>GeometricEntity</code></a>. Contains all entities created in a given session.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/entities.jl#L289-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.SAME_POINT_TOLERANCE" href="#Inti.SAME_POINT_TOLERANCE"><code>Inti.SAME_POINT_TOLERANCE</code></a> ‚Äî <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SAME_POINTS_TOLERANCE</code></pre><p>Two points <code>x</code> and <code>y</code> are considerd the same if <code>norm(x-y) ‚â§ SAME_POINT_TOLERANCE</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L226-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.AbstractDifferentialOperator" href="#Inti.AbstractDifferentialOperator"><code>Inti.AbstractDifferentialOperator</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractDifferentialOperator{N}</code></pre><p>A partial differential operator in dimension <code>N</code>.</p><p><code>AbstractDifferentialOperator</code> types are used to define <a href="#Inti.AbstractKernel"><code>AbstractKernel</code>s</a> related to fundamental solutions of differential operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/kernels.jl#L24-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.AbstractKernel" href="#Inti.AbstractKernel"><code>Inti.AbstractKernel</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractKernel{T}</code></pre><p>A kernel functions <code>K</code> with the signature <code>K(target,source)::T</code>.</p><p>See also: <a href="#Inti.SingleLayerKernel"><code>SingleLayerKernel</code></a>, <a href="#Inti.DoubleLayerKernel"><code>DoubleLayerKernel</code></a>, <a href="#Inti.AdjointDoubleLayerKernel"><code>AdjointDoubleLayerKernel</code></a>, <a href="#Inti.HyperSingularKernel"><code>HyperSingularKernel</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/kernels.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.AbstractMesh" href="#Inti.AbstractMesh"><code>Inti.AbstractMesh</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractMesh{N,T}</code></pre><p>An abstract mesh structure in dimension <code>N</code> with primite data of type <code>T</code> (e.g. <code>Float64</code> for double precision representation).</p><p>Concrete subtypes of <code>AbstractMesh</code> should implement <a href="#Inti.ElementIterator"><code>ElementIterator</code></a> for accessing the mesh elements.</p><p>See also: <a href="#Inti.Mesh"><code>Mesh</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.AdjointDoubleLayerKernel" href="#Inti.AdjointDoubleLayerKernel"><code>Inti.AdjointDoubleLayerKernel</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct AdjointDoubleLayerKernel{T,Op} &lt;: AbstractKernel{T}</code></pre><p>Given an operator <code>Op</code>, construct its free-space adjoint double-layer kernel. This corresponds to the <code>transpose(Œ≥‚ÇÅ,‚Çì[G])</code>, where <code>G</code> is the <a href="#Inti.SingleLayerKernel"><code>SingleLayerKernel</code></a>. For operators such as <a href="#Inti.Laplace-Tuple{}"><code>Laplace</code></a> or <a href="#Inti.Helmholtz-Tuple{}"><code>Helmholtz</code></a>, this is simply the normal derivative of the fundamental solution respect to the target variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/kernels.jl#L78-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.BlockArray" href="#Inti.BlockArray"><code>Inti.BlockArray</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct BlockArray{T&lt;:StaticArray,N,S} &lt;: AbstractMatrix{T,N}</code></pre><p>A struct which behaves like an  <code>Array{T,N}</code>, but with the underlying <code>data</code> stored as a <code>Matrix{S}</code>, where <code>S::Number = eltype(T)</code> is the scalar type associated with <code>T</code>. This allows for the use of many <code>blas</code> routines under-the-hood, while providing a convenient interface for handling arrays over <code>StaticArray</code>s.</p><pre><code class="language-julia hljs">using StaticArrays
T = SMatrix{2,2,Int,4}
B = Inti.BlockArray{T}([i*j for i in 1:4, j in 1:4])

# output

2√ó2 Inti.BlockArray{SMatrix{2, 2, Int64, 4}, 2, Int64, 2}:
 [1 2; 2 4]  [3 4; 6 8]
 [3 6; 4 8]  [9 12; 12 16]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/blockarray.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.DimParameters" href="#Inti.DimParameters"><code>Inti.DimParameters</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DimParameters</code></pre><p>Parameters associated with the density interpolation method used in <a href="#Inti.bdim_correction-Tuple{Any, Any, Inti.Quadrature, Any, Any}"><code>bdim_correction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/bdim.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Domain" href="#Inti.Domain"><code>Inti.Domain</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Domain</code></pre><p>Representation of a geometrical domain formed by a set of entities with the same geometric dimension. For basic set operations on domains are supported (union, intersection, difference, etc), and they all return a new <code>Domain</code> object.</p><p>Calling <code>keys(Œ©)</code> returns the set of <a href="#Inti.EntityKey"><code>EntityKey</code></a>s that make up the domain; given a key, the underlying entities can be accessed with <a href="#Inti.global_get_entity-Tuple{Inti.EntityKey}"><code>global_get_entity(key)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/domain.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Domain-Tuple{Function, Any}" href="#Inti.Domain-Tuple{Function, Any}"><code>Inti.Domain</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Domain([f::Function,] keys)</code></pre><p>Create a domain from a set of <a href="#Inti.EntityKey"><code>EntityKey</code></a>s. Optionally, a filter function <code>f</code> can be passed to filter the entities.</p><p>Note that all entities in a domain must have the same geometric dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/domain.jl#L24-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Domain-Tuple{Function, Inti.AbstractMesh}" href="#Inti.Domain-Tuple{Function, Inti.AbstractMesh}"><code>Inti.Domain</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Domain(f::Function, msh::AbstractMesh)</code></pre><p>Call <code>Domain(f, ents)</code> on <code>ents = entities(msh).</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L645-L649">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.DoubleLayerKernel" href="#Inti.DoubleLayerKernel"><code>Inti.DoubleLayerKernel</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DoubleLayerKernel{T,Op} &lt;: AbstractKernel{T}</code></pre><p>Given an operator <code>Op</code>, construct its free-space double-layer kernel. This corresponds to the <code>Œ≥‚ÇÅ</code> trace of the <a href="#Inti.SingleLayerKernel"><code>SingleLayerKernel</code></a>. For operators such as <a href="#Inti.Laplace-Tuple{}"><code>Laplace</code></a> or <a href="#Inti.Helmholtz-Tuple{}"><code>Helmholtz</code></a>, this is simply the normal derivative of the fundamental solution respect to the source variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/kernels.jl#L61-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Elastostatic" href="#Inti.Elastostatic"><code>Inti.Elastostatic</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Elastostatic{N,T} &lt;: AbstractDifferentialOperator{N}</code></pre><p>Elastostatic operator in <code>N</code> dimensions: -ŒºŒîu - (Œº+Œª)‚àá(‚àá‚ãÖu)</p><p>Note that the displacement <span>$u$</span> is a vector of length <code>N</code> since this is a vectorial problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/kernels.jl#L490-L497">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ElementIterator" href="#Inti.ElementIterator"><code>Inti.ElementIterator</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ElementIterator{E,M} &lt;: AbstractVector{E}</code></pre><p>Structure to lazily access elements of type <code>E</code> in a mesh of type <code>M</code>. This is particularly useful for <a href="#Inti.LagrangeElement"><code>LagrangeElement</code></a>s, where the information to reconstruct the element is stored in the mesh connectivity matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L413-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.EmbeddedQuadrature" href="#Inti.EmbeddedQuadrature"><code>Inti.EmbeddedQuadrature</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct EmbeddedQuadrature{L,H,D} &lt;: ReferenceQuadrature{D}</code></pre><p>A quadrature rule for the reference shape <code>D</code> based on a high-order quadrature of type <code>H</code> and a low-order quadrature of type <code>L</code>. The low-order quadrature rule is <em>embedded</em> in the sense that its <code>n</code> nodes are exactly the first <code>n</code> nodes of the high-order quadrature rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L343-L350">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.EntityKey" href="#Inti.EntityKey"><code>Inti.EntityKey</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EntityKey</code></pre><p>Used to represent the key of a <a href="#Inti.GeometricEntity"><code>GeometricEntity</code></a>, comprised of a <code>dim</code> and a <code>tag</code> field, where <code>dim</code> is the geometrical dimension of the entity, and <code>tag</code> is a unique integer identifying the entity.</p><p>The sign of the <code>tag</code> field is used to distinguish the orientation of the entity, and is ignored when comparing two <a href="#Inti.EntityKey"><code>EntityKey</code></a>s for equality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/entities.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Fejer" href="#Inti.Fejer"><code>Inti.Fejer</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Fejer{N}</code></pre><p><code>N</code>-point Fejer&#39;s first quadrature rule for integrating a function over <code>[0,1]</code>. Exactly integrates all polynomials of degree <code>‚â§ N-1</code>.</p><pre><code class="language-julia hljs">using Inti

q = Inti.Fejer(;order=10)

Inti.integrate(cos,q) ‚âà sin(1) - sin(0)

# output

true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L71-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Gauss" href="#Inti.Gauss"><code>Inti.Gauss</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Gauss{D,N} &lt;: ReferenceQuadrature{D}</code></pre><p>Tabulated <code>N</code>-point symmetric Gauss quadrature rule for integration over <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.GaussLegendre" href="#Inti.GaussLegendre"><code>Inti.GaussLegendre</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GaussLegendre{N,T}</code></pre><p><code>N</code>-point Gauss-Legendre quadrature rule for integrating a function over <code>[0,1]</code>. Exactly integrates all polynomials of degree <code>‚â§ 2N-1</code>.</p><pre><code class="language-julia hljs">using Inti

q = Inti.GaussLegendre(;order=10)

Inti.integrate(cos,q) ‚âà sin(1) - sin(0)

# output

true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L121-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.GeometricEntity" href="#Inti.GeometricEntity"><code>Inti.GeometricEntity</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GeometricEntity</code></pre><p>Geometrical objects such as lines, surfaces, and volumes.</p><p>Geometrical entities are stored in a global <a href="#Inti.ENTITIES"><code>ENTITIES</code></a> dictionary mapping <a href="#Inti.EntityKey"><code>EntityKey</code></a> to the corresponding <code>GeometricEntity</code>, and usually entities are manipulated through their keys.</p><p>A <code>GeometricEntity</code> can also contain a <code>pushforward</code> field used to parametrically represent the entry as the image of a reference domain (<code>pushforward.domain</code>) under some function (<code>pushforward.parametrization</code>).</p><p>Note that entities are manipulated through their keys, and the <code>GeometricEntity</code> constructor returns the key of the created entity; to retrieve the entity, use the <a href="#Inti.global_get_entity-Tuple{Inti.EntityKey}"><code>global_get_entity</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/entities.jl#L47-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.GeometricEntity-Tuple{String}" href="#Inti.GeometricEntity-Tuple{String}"><code>Inti.GeometricEntity</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeometricEntity(shape::String [; translation, rotation, scaling, kwargs...])</code></pre><p>Constructs a geometric entity with the specified shape and optional parameters, and returns its <code>key</code>.</p><p><strong>Arguments</strong></p><ul><li><code>shape::String</code>: The shape of the geometric entity.</li><li><code>translation</code>: The translation vector of the geometric entity. Default is <code>SVector(0, 0, 0)</code>.</li><li><code>rotation</code>: The rotation vector of the geometric entity. Default is <code>SVector(0, 0, 0)</code>.</li><li><code>scaling</code>: The scaling vector of the geometric entity. Default is <code>SVector(1, 1, 1)</code>.</li><li><code>kwargs...</code>: Additional keyword arguments to be passed to the shape constructor.</li></ul><p><strong>Supported shapes</strong></p><ul><li><a href="#Inti.ellipsoid-Tuple{}"><code>ellipsoid</code></a></li><li><a href="#Inti.torus-Tuple{}"><code>torus</code></a></li><li><a href="#Inti.bean-Tuple{}"><code>bean</code></a></li><li><a href="#Inti.acorn-Tuple{}"><code>acorn</code></a></li><li><a href="#Inti.cushion-Tuple{}"><code>cushion</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/simpleshapes.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Helmholtz-Tuple{}" href="#Inti.Helmholtz-Tuple{}"><code>Inti.Helmholtz</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Helmholtz(; k, dim)</code></pre><p>Helmholtz operator in <code>dim</code> dimensions: <code>-Œîu - k¬≤u</code>.</p><p>The parameter <code>k</code> can be a real or complex number. For purely imaginary wavenumbers, consider using the <a href="#Inti.Yukawa-Tuple{}"><code>Yukawa</code></a> kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/kernels.jl#L313-L320">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.HyperRectangle" href="#Inti.HyperRectangle"><code>Inti.HyperRectangle</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct HyperRectangle{N,T} &lt;: ReferenceInterpolant{ReferenceHyperCube{N},T}</code></pre><p>Axis-aligned hyperrectangle in <code>N</code> dimensions given by <code>low_corner::SVector{N,T}</code> and <code>high_corner::SVector{N,T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L140-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.HyperSingularKernel" href="#Inti.HyperSingularKernel"><code>Inti.HyperSingularKernel</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct HyperSingularKernel{T,Op} &lt;: AbstractKernel{T}</code></pre><p>Given an operator <code>Op</code>, construct its free-space hypersingular kernel. This corresponds to the <code>transpose(Œ≥‚ÇÅ,‚ÇìŒ≥‚ÇÅ[G])</code>, where <code>G</code> is the <a href="#Inti.SingleLayerKernel"><code>SingleLayerKernel</code></a>. For operators such as <a href="#Inti.Laplace-Tuple{}"><code>Laplace</code></a> or <a href="#Inti.Helmholtz-Tuple{}"><code>Helmholtz</code></a>, this is simply the normal derivative respect to the target variable of the <code>DoubleLayerKernel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/kernels.jl#L96-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.IntegralOperator" href="#Inti.IntegralOperator"><code>Inti.IntegralOperator</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct IntegralOperator{T} &lt;: AbstractMatrix{T}</code></pre><p>A discrete linear integral operator given by</p><p class="math-container">\[I[u](x) = \int_{\Gamma\_s} K(x,y)u(y) ds_y, x \in \Gamma_{t}\]</p><p>where <span>$\Gamma_s$</span> and <span>$\Gamma_t$</span> are the source and target domains, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/nystrom.jl#L40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.IntegralPotential" href="#Inti.IntegralPotential"><code>Inti.IntegralPotential</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct IntegralPotential</code></pre><p>Represent a potential given by a <code>kernel</code> and a <code>quadrature</code> over which integration is performed.</p><p><code>IntegralPotential</code>s are created using <code>IntegralPotential(kernel, quadrature)</code>.</p><p>Evaluating an integral potential requires a density <code>œÉ</code> (defined over the quadrature nodes of the source mesh) and a point <code>x</code> at which to evaluate the integral</p><p class="math-container">\[\int_{\Gamma} K(oldsymbol{x},oldsymbol{y})\sigma(y) ds_y, x \not \in \Gamma\]</p><p>Assuming <code>ùíÆ</code> is an integral potential and <code>œÉ</code> is a vector of values defined on <code>quadrature</code>, calling <code>ùíÆ[œÉ]</code> creates an anonymous function that can be evaluated at any point <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/nystrom.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.LagrangeCube" href="#Inti.LagrangeCube"><code>Inti.LagrangeCube</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const LagrangeSquare = LagrangeElement{ReferenceSquare}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L336-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.LagrangeElement" href="#Inti.LagrangeElement"><code>Inti.LagrangeElement</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LagrangeElement{D,Np,T} &lt;: ReferenceInterpolant{D,T}</code></pre><p>A polynomial <code>p : D ‚Üí T</code> uniquely defined by its <code>Np</code> values on the <code>Np</code> reference nodes of <code>D</code>.</p><p>The return type <code>T</code> should be a vector space (i.e. support addition and multiplication by scalars). For istance, <code>T</code> could be a number or a vector, but not a <code>Tuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L214-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.LagrangeLine" href="#Inti.LagrangeLine"><code>Inti.LagrangeLine</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const LagrangeLine = LagrangeElement{ReferenceLine}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L297-L299">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.LagrangeSquare" href="#Inti.LagrangeSquare"><code>Inti.LagrangeSquare</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const LagrangeSquare = LagrangeElement{ReferenceSquare}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L326-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.LagrangeTetrahedron" href="#Inti.LagrangeTetrahedron"><code>Inti.LagrangeTetrahedron</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const LagrangeTetrahedron = LagrangeElement{ReferenceTetrahedron}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L321-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.LagrangeTriangle" href="#Inti.LagrangeTriangle"><code>Inti.LagrangeTriangle</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const LagrangeTriangle = LagrangeElement{ReferenceTriangle}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L311-L313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Laplace-Tuple{}" href="#Inti.Laplace-Tuple{}"><code>Inti.Laplace</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Laplace(; dim)</code></pre><p>Laplace&#39;s differential operator in <code>dim</code> dimension: <span>$-Œîu$</span>. ```</p><p>Note the <strong>negative sign</strong> in the definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/kernels.jl#L120-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Mesh" href="#Inti.Mesh"><code>Inti.Mesh</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Mesh{N,T} &lt;: AbstractMesh{N,T}</code></pre><p>Unstructured mesh defined by a set of <code>nodes</code><code>(of type</code>SVector{N,T}`), and a dictionary mapping element types to connectivity matrices. Each columns of a given connectivity matrix stores the integer tags of the nodes in the mesh comprising the element.</p><p>Additionally, the mesh contains a mapping from <a href="#Inti.EntityKey"><code>EntityKey</code></a>s to the tags of the elements composing the entity. This can be used to extract submeshes from a given mesh using e.g. <code>view(msh,Œì)</code> or <code>msh[Œì]</code>, where <code>Œì</code> is a <a href="#Inti.Domain"><code>Domain</code></a>.</p><p>See <a href="#Inti.elements"><code>elements</code></a> for a way to iterate over the elements of a mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L60-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ModifiedHelmholtz" href="#Inti.ModifiedHelmholtz"><code>Inti.ModifiedHelmholtz</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const ModifiedHelmholtz</code></pre><p>Type alias for the <a href="#Inti.Yukawa-Tuple{}"><code>Yukawa</code></a> operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/kernels.jl#L222-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.MultiIndex" href="#Inti.MultiIndex"><code>Inti.MultiIndex</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultiIndex{N}</code></pre><p>Wrapper around <code>NTuple{N,Int}</code> mimicking a multi-index in <code>‚Ñ§‚ÇÄ·¥∫</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L242-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ParametricElement" href="#Inti.ParametricElement"><code>Inti.ParametricElement</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParametricElement{D,T,F} &lt;: ReferenceInterpolant{D,T}</code></pre><p>An element represented through a explicit function <code>f</code> mapping <code>D</code> into the element. For performance reasons, <code>f</code> should take as input a <code>StaticVector</code> and return a <code>StaticVector</code> or <code>StaticArray</code>.</p><p>See also: <a href="#Inti.ReferenceInterpolant"><code>ReferenceInterpolant</code></a>, <a href="#Inti.LagrangeElement"><code>LagrangeElement</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L168-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ParametricElement-Union{Tuple{T}, Tuple{N}, Tuple{Any, Inti.HyperRectangle{N, T}}} where {N, T}" href="#Inti.ParametricElement-Union{Tuple{T}, Tuple{N}, Tuple{Any, Inti.HyperRectangle{N, T}}} where {N, T}"><code>Inti.ParametricElement</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParametricElement(f, d::HyperRectangle)</code></pre><p>Construct the element defined as the image of <code>f</code> over <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L203-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.PolynomialSpace" href="#Inti.PolynomialSpace"><code>Inti.PolynomialSpace</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct PolynomialSpace{D,K}</code></pre><p>The space of all polynomials of degree <code>‚â§K</code>, commonly referred to as <code>‚Ñô‚Çñ</code>.</p><p>The type parameter <code>D</code>, of singleton type, is used to determine the reference domain of the polynomial basis. In particular, when <code>D</code> is a hypercube in <code>d</code> dimensions, the precise definition is <code>‚Ñô‚Çñ = span{ùê±·∂ø : 0‚â§max(Œ∏)‚â§ K}</code>; when <code>D</code> is a <code>d</code>-dimensional simplex, the space is <code>‚Ñô‚Çñ = span{ùê±·∂ø : 0‚â§sum(Œ∏)‚â§ K}</code>, where <code>Œ∏ ‚àà ùêç·µà</code> is a multi-index.</p><p><strong>See also: <a href="#Inti.monomial_basis"><code>monomial_basis</code></a>, <a href="#Inti.lagrange_basis-Tuple{Any, Inti.PolynomialSpace}"><code>lagrange_basis</code></a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/polynomials.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Quadrature" href="#Inti.Quadrature"><code>Inti.Quadrature</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Quadrature{N,T} &lt;: AbstractVector{QuadratureNode{N,T}}</code></pre><p>A collection of <a href="#Inti.QuadratureNode"><code>QuadratureNode</code></a>s used to integrate over an <a href="#Inti.AbstractMesh"><code>AbstractMesh</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/quadrature.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Quadrature-Tuple{Inti.Domain}" href="#Inti.Quadrature-Tuple{Inti.Domain}"><code>Inti.Quadrature</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Quadrature(Œ©::Domain; meshsize, qorder)</code></pre><p>Construct a <code>Quadrature</code> over the domain <code>Œ©</code> with a mesh of size <code>meshsize</code> and quadrature order <code>qorder</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/quadrature.jl#L164-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Quadrature-Union{Tuple{T}, Tuple{N}, Tuple{Inti.AbstractMesh{N, T}, Dict}} where {N, T}" href="#Inti.Quadrature-Union{Tuple{T}, Tuple{N}, Tuple{Inti.AbstractMesh{N, T}, Dict}} where {N, T}"><code>Inti.Quadrature</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Quadrature(msh::AbstractMesh, etype2qrule::Dict)
Quadrature(msh::AbstractMesh, qrule::ReferenceQuadrature)
Quadrature(msh::AbstractMesh; qorder)</code></pre><p>Construct a <code>Quadrature</code> for <code>msh</code>, where for each element type <code>E</code> in <code>msh</code> the reference quadrature <code>q = etype2qrule[E]</code> is used. When a single <code>qrule</code> is passed, it is used for all element types in <code>msh</code>.</p><p>If an <code>order</code> keyword is passed, a default quadrature of the desired order is used for each element type usig <a href="#Inti._qrule_for_reference_shape-Tuple{Any, Any}"><code>_qrule_for_reference_shape</code></a>.</p><p>For co-dimension one elements, the normal vector is also computed and stored in the <a href="#Inti.QuadratureNode"><code>QuadratureNode</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/quadrature.jl#L88-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.QuadratureNode" href="#Inti.QuadratureNode"><code>Inti.QuadratureNode</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuadratureNode{N,T&lt;:Real}</code></pre><p>A point in <code>‚Ñù·¥∫</code> with a <code>weight</code> for performing numerical integration. A <code>QuadratureNode</code> can optionally store a <code>normal</code> vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/quadrature.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceCube" href="#Inti.ReferenceCube"><code>Inti.ReferenceCube</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const ReferenceCube = ReferenceHyperCube{3}</code></pre><p>Singleton type representing the unit cube <code>[0,1]¬≥</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_shapes.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceHyperCube" href="#Inti.ReferenceHyperCube"><code>Inti.ReferenceHyperCube</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ReferenceHyperCube{N} &lt;: ReferenceShape{N}</code></pre><p>Singleton type representing the axis-aligned hypercube in <code>N</code> dimensions with the lower corner at the origin and the upper corner at <code>(1,1,‚Ä¶,1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_shapes.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceInterpolant" href="#Inti.ReferenceInterpolant"><code>Inti.ReferenceInterpolant</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type ReferenceInterpolant{D,T}</code></pre><p>Interpolanting function mapping points on the domain <code>D&lt;:ReferenceShape</code> (of singleton type) to a value of type <code>T</code>.</p><p>Instances <code>el</code> of <code>ReferenceInterpolant</code> are expected to implement:</p><ul><li><code>el(xÃÇ)</code>: evaluate the interpolation scheme at the (reference) coordinate <code>xÃÇ ‚àà D</code>.</li><li><code>jacobian(el,xÃÇ)</code> : evaluate the jacobian matrix of the interpolation at the (reference) coordinate <code>x ‚àà D</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For performance reasons, both <code>el(xÃÇ)</code> and <code>jacobian(el,xÃÇ)</code> should take as input a <code>StaticVector</code> and output a static vector or static array.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceLine" href="#Inti.ReferenceLine"><code>Inti.ReferenceLine</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const ReferenceLine = ReferenceHyperCube{1}</code></pre><p>Singleton type representing the <code>[0,1]</code> segment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_shapes.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceQuadrature" href="#Inti.ReferenceQuadrature"><code>Inti.ReferenceQuadrature</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type ReferenceQuadrature{D}</code></pre><p>A quadrature rule for integrating a function over the domain <code>D &lt;: ReferenceShape</code>.</p><p>Calling <code>x,w = q()</code> returns the nodes <code>x</code>, given as <code>SVector</code>s, and weights <code>w</code>, for performing integration over <code>domain(q)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceShape" href="#Inti.ReferenceShape"><code>Inti.ReferenceShape</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type ReferenceShape</code></pre><p>A fixed reference domain/shape. Used mostly for defining more complex shapes as transformations mapping an <code>ReferenceShape</code> to some region of <code>‚Ñú·¥π</code>.</p><p>See e.g. <a href="#Inti.ReferenceLine"><code>ReferenceLine</code></a> or <a href="#Inti.ReferenceTriangle"><code>ReferenceTriangle</code></a> for some examples of concrete subtypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_shapes.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceSimplex" href="#Inti.ReferenceSimplex"><code>Inti.ReferenceSimplex</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ReferenceSimplex{N}</code></pre><p>Singleton type representing the N-simplex with N+1 vertices <code>(0,...,0),(0,...,0,1),(0,...,0,1,0),(1,0,...,0)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_shapes.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceSquare" href="#Inti.ReferenceSquare"><code>Inti.ReferenceSquare</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const ReferenceSquare = ReferenceHyperCube{2}</code></pre><p>Singleton type representing the unit square <code>[0,1]¬≤</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_shapes.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceTetrahedron" href="#Inti.ReferenceTetrahedron"><code>Inti.ReferenceTetrahedron</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ReferenceTetrahedron</code></pre><p>Singleton type representing the tetrahedron with vertices <code>(0,0,0),(0,0,1),(0,1,0),(1,0,0)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_shapes.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceTriangle" href="#Inti.ReferenceTriangle"><code>Inti.ReferenceTriangle</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ReferenceTriangle</code></pre><p>Singleton type representing the triangle with vertices <code>(0,0),(1,0),(0,1)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_shapes.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.SingleLayerKernel" href="#Inti.SingleLayerKernel"><code>Inti.SingleLayerKernel</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SingleLayerKernel{T,Op} &lt;: AbstractKernel{T}</code></pre><p>The free-space single-layer kernel (i.e. the fundamental solution) of an <code>Op &lt;: AbstractDifferentialOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/kernels.jl#L46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Stokes-Tuple{}" href="#Inti.Stokes-Tuple{}"><code>Inti.Stokes</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Stokes(; Œº, dim)</code></pre><p>Stokes operator in <code>dim</code> dimensions: <span>$[-ŒºŒîu + ‚àáp, ‚àá‚ãÖu]$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/kernels.jl#L423-L427">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.SubMesh" href="#Inti.SubMesh"><code>Inti.SubMesh</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SubMesh{N,T} &lt;: AbstractMesh{N,T}</code></pre><p>View into a <code>parent</code> mesh over a given <code>domain</code>.</p><p>A submesh implements the interface for <code>AbstractMesh</code>; therefore you can iterate over elements of the submesh just like you would with a mesh.</p><p>Construct <code>SubMesh</code>s using <code>view(parent,Œ©::Domain)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L503-L512">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.TensorProductQuadrature" href="#Inti.TensorProductQuadrature"><code>Inti.TensorProductQuadrature</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TensorProductQuadrature{N,Q}</code></pre><p>A tensor-product of one-dimension quadrature rules. Integrates over <code>[0,1]^N</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">qx = Inti.Fejer(10)
qy = Inti.Fejer(15)
q  = Inti.TensorProductQuadrature(qx,qy)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L229-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.VioreanuRokhlin" href="#Inti.VioreanuRokhlin"><code>Inti.VioreanuRokhlin</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct VioreanuRokhlin{D,N} &lt;: ReferenceQuadrature{D}</code></pre><p>Tabulated <code>N</code>-point Vioreanu-Rokhlin quadrature rule for integration over <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L262-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Yukawa-Tuple{}" href="#Inti.Yukawa-Tuple{}"><code>Inti.Yukawa</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Yukawa(; Œª, dim)</code></pre><p>Yukawa operator, also known as modified Helmholtz, in <code>dim</code> dimensions: <span>$-Œîu + Œª¬≤u$</span>.</p><p>The parameter <code>Œª</code> is a positive number. Note the <strong>negative sign</strong> in front of the Laplacian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/kernels.jl#L209-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate" href="#Base.iterate"><code>Base.iterate</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iterate(Œ©::Domain)</code></pre><p>Iterating over a domain means iterating over its entities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/domain.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti._blocksize_normalized-Union{Tuple{Inti.BlockArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#Inti._blocksize_normalized-Union{Tuple{Inti.BlockArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>Inti._blocksize_normalized</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_blocksize_normalized(A::BlockArray)</code></pre><p>Like <a href="#Inti.blocksize-Union{Tuple{Inti.BlockArray{T}}, Tuple{T}} where T"><code>blocksize</code></a>, but appends <code>1</code>s if <code>A</code> is a higher-dimensional.</p><p>For example, a <code>BlockArray{SVector{3,Float64}, 2}</code> has a <code>blocksize</code> of <code>(3,)</code>, but a <code>normalized_blocksize</code> of <code>(3, 1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/blockarray.jl#L53-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti._get_gauss_qcoords_and_qweights-Tuple{Type{&lt;:Inti.ReferenceShape}, Any}" href="#Inti._get_gauss_qcoords_and_qweights-Tuple{Type{&lt;:Inti.ReferenceShape}, Any}"><code>Inti._get_gauss_qcoords_and_qweights</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_gauss_and_qweights(R::Type{&lt;:ReferenceShape{D}}, N) where D</code></pre><p>Returns the <code>N</code>-point symmetric gaussian qnodes and qweights <code>(x, w)</code> for integration over <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti._get_vioreanurokhlin_qcoords_and_qweights-Tuple{Type{&lt;:Inti.ReferenceShape}, Any}" href="#Inti._get_vioreanurokhlin_qcoords_and_qweights-Tuple{Type{&lt;:Inti.ReferenceShape}, Any}"><code>Inti._get_vioreanurokhlin_qcoords_and_qweights</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_vioreanurokhlin_qcoords_and_qweights(R::Type{&lt;:ReferenceShape{D}}, N) where D</code></pre><p>Returns the <code>N</code>-point Vioreanu-Rokhlin qnodes and qweights <code>(x, w)</code> for integration over <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L320-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti._green_multiplier-Tuple{Symbol}" href="#Inti._green_multiplier-Tuple{Symbol}"><code>Inti._green_multiplier</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_green_multiplier(s::Symbol)</code></pre><p>Return <code>-1.0</code> if <code>s == :inside</code>, <code>0.0</code> if <code>s == :outside</code>, and <code>-0.5</code> if <code>s == :on</code>; otherwise, throw an error. The orientation is relative to the normal of the bounding curve/surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/nystrom.jl#L171-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti._green_multiplier-Union{Tuple{N}, Tuple{StaticArraysCore.SVector, Inti.Quadrature{N}}} where N" href="#Inti._green_multiplier-Union{Tuple{N}, Tuple{StaticArraysCore.SVector, Inti.Quadrature{N}}} where N"><code>Inti._green_multiplier</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_green_multiplier(x, quad)</code></pre><p>Helper function to help determine the constant œÉ in the Green identity S[Œ≥‚ÇÅu](x)</p><ul><li>D[Œ≥‚ÇÄu](x) + œÉ*u(x) = 0. This can be used as a predicate to determine whether a</li></ul><p>point is inside a domain or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/nystrom.jl#L153-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti._meshgen-Tuple{Any, Inti.HyperRectangle, NTuple{N, T} where {N, T}}" href="#Inti._meshgen-Tuple{Any, Inti.HyperRectangle, NTuple{N, T} where {N, T}}"><code>Inti._meshgen</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_meshgen(f,d::HyperRectangle,sz)</code></pre><p>Create <code>prod(sz)</code> elements of <a href="#Inti.ParametricElement"><code>ParametricElement</code></a> type representing the push forward of <code>f</code> on each of the subdomains defined by a uniform cartesian mesh of <code>d</code> of size <code>sz</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L371-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti._normal-Union{Tuple{StaticArraysCore.SMatrix{N, M}}, Tuple{M}, Tuple{N}, Tuple{StaticArraysCore.SMatrix{N, M}, Any}} where {N, M}" href="#Inti._normal-Union{Tuple{StaticArraysCore.SMatrix{N, M}}, Tuple{M}, Tuple{N}, Tuple{StaticArraysCore.SMatrix{N, M}, Any}} where {N, M}"><code>Inti._normal</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_normal(jac::SMatrix{M,N}, s = 1)</code></pre><p>Given a an <code>M</code> by <code>N</code> matrix representing the jacobian of a codimension one object, compute the normal vector. If <code>s=-1</code>, the normal vector is flipped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L115-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti._qrule_for_reference_shape-Tuple{Any, Any}" href="#Inti._qrule_for_reference_shape-Tuple{Any, Any}"><code>Inti._qrule_for_reference_shape</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_qrule_for_reference_shape(ref,order)</code></pre><p>Given a <code>ref</code>erence shape and a desired quadrature <code>order</code>, return an appropiate quadrature rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/quadrature.jl#L202-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.acorn-Tuple{}" href="#Inti.acorn-Tuple{}"><code>Inti.acorn</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">acorn(; translation, rotation, scaling, labels)</code></pre><p>Create an acorn entity in 3D, and apply optional transformations. Returns the key.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/simpleshapes.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.adaptive_correction-Tuple{Inti.IntegralOperator}" href="#Inti.adaptive_correction-Tuple{Inti.IntegralOperator}"><code>Inti.adaptive_correction</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adaptive_correction(iop::IntegralOperator; [maxdist, rtol, threads = true, kwargs...])
adaptive_correction(iop::IntegralOperator, maxdist, quads_dict::Dict, threads = true)</code></pre><p>This function computes a sparse correction for the integral operator <code>iop</code>, addressing its singular or nearly singular entries.</p><p>The parameter <code>maxdist</code> specifies the maximum distance between target points  and source elements to be considered for correction (only interactions within this distance are corrected).</p><p>The parameter <code>rtol</code> defines the tolerance for the adaptive quadrature used to compute the corrections for singular or nearly singular entries.</p><p>Additional <code>kwargs</code> arguments are passed to <a href="#Inti.adaptive_quadrature-Tuple{Inti.ReferenceHyperCube{1}}"><code>adaptive_quadrature</code></a>; see its documentation for more information.</p><p>Selecting <code>maxdist</code> and <code>rtol</code> involves balancing accuracy and computational cost. A smaller <code>maxdist</code> reduces the number of corrections but may impact accuracy. Conversely, a smaller <code>rtol</code> improves correction accuracy but increases computational expense. The ideal values for <code>maxdist</code> and <code>rtol</code> depend on the kernel and the mesh/quadrature rule applied.</p><p>By default, <code>maxdist</code> and <code>rtol</code> are estimated using the <a href="#Inti.local_correction_dist_and_tol"><code>local_correction_dist_and_tol</code></a>, but it is often possible to improve performance by manually tunning these parameters.</p><p><strong>Advanced usage</strong></p><p>For finer control, you can provide a dictionary <code>quads_dict</code> that contains quadrature rules for each reference element type present in the mesh of <code>source(iop)</code>. This allows you to fine-tune the quadrature rules for specific element types (e.g. use a fixed quadrature rule instead of an adaptive one).</p><p>The dictionary <code>quads_dict</code> must adhere to the following structure:</p><ul><li><code>quads_dict[E].nearfield_quad</code>: A function that integrates over the nearfield of the reference element type <code>E</code>. Used in the nearly-singular correction.</li><li><code>quads_dict[E].radial_quad</code>: A function that integrates over the radial direction of the reference element type <code>E</code>. Used in the singular correction.</li><li><code>quads_dict[E].angular_quad</code>: A function that integrates over the angular direction of the reference element type <code>E</code>. Used in the singular correction.</li></ul><p>Here is an example of how to implement a custom <code>quads_dict</code> given an <code>iop</code>:</p><pre><code class="language-julia hljs">quads_dict = Dict()
msh = Inti.mesh(source(iop))
for E in Inti.element_types(msh)
    ref_domain = Inti.reference_domain(E)
    quads = (
        nearfield_quad = Inti.adaptive_quadrature(ref_domain; atol),
        radial_quad    = Inti.GaussLegendre(;order=5),
        angular_quad   = Inti.GuassLegendre(;order=20),
    )
    quads_dict[E] = quads
end</code></pre><p>This will use an adaptive quadrature rule for the nearfield and fixed Gauss-Legendre quadrature rules for the radial and angular directions when computing the singular correction in polar coordinates on the reference domain. You can then call <code>adaptive_correction(iop, maxdist, quads_dict)</code> to use the custom quadrature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/adaptive_correction.jl#L1-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.adaptive_quadrature-Tuple{Inti.ReferenceHyperCube{1}}" href="#Inti.adaptive_quadrature-Tuple{Inti.ReferenceHyperCube{1}}"><code>Inti.adaptive_quadrature</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adaptive_quadrature(ref_domain::ReferenceShape; kwargs...)</code></pre><p>Return a function <code>quad</code> callable as <code>quad(f)</code> that integrates the function <code>f</code> over the reference shape <code>ref_domain</code>. The keyword arguments are passed to <code>HAdaptiveIntegration.integrate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L474-L480">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.adj_double_layer_hypersingular-Tuple{}" href="#Inti.adj_double_layer_hypersingular-Tuple{}"><code>Inti.adj_double_layer_hypersingular</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adj_double_layer_hypersingular(; op, target, source, compression,
correction)</code></pre><p>Similar to <code>single_double_layer</code>, but for the adjoint double-layer and hypersingular operators. See the documentation of [<code>single_double_layer</code>] for a description of the arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/api.jl#L184-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ambient_dimension" href="#Inti.ambient_dimension"><code>Inti.ambient_dimension</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ambient_dimension(x)</code></pre><p>Dimension of the ambient space where <code>x</code> lives. For geometrical objects this can differ from its <a href="#Inti.geometric_dimension"><code>geometric_dimension</code></a>; for example a triangle in <code>‚Ñù¬≥</code> has ambient dimension <code>3</code> but geometric dimension <code>2</code>, while a curve in <code>‚Ñù¬≥</code> has ambient dimension 3 but geometric dimension 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L33-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.assemble_fmm-Tuple{Inti.IntegralOperator}" href="#Inti.assemble_fmm-Tuple{Inti.IntegralOperator}"><code>Inti.assemble_fmm</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assemble_fmm(iop; rtol)</code></pre><p>Set up a 2D or 3D FMM for evaluating the discretized integral operator <code>iop</code> associated with the <code>op</code>. In 2D the <code>FMM2D</code> or <code>FMMLIB2D</code> library is used (whichever was most recently loaded) while in 3D <code>FMM3D</code> is used.</p><div class="admonition is-warning"><header class="admonition-header">FMMLIB2D</header><div class="admonition-body"><p>FMMLIB2D does <em>no</em> checking for if the targets and sources coincide, and will return <code>Inf</code> values if <code>iop.target !== iop.source</code>, but there is a point <code>x ‚àà iop.target</code> such that <code>x ‚àà iop.source</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/nystrom.jl#L108-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.assemble_hmatrix-Tuple" href="#Inti.assemble_hmatrix-Tuple"><code>Inti.assemble_hmatrix</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assemble_hmatrix(iop[; atol, rank, rtol, eta])</code></pre><p>Assemble an H-matrix representation of the discretized integral operator <code>iop</code> using the <code>HMatrices.jl</code> library.</p><p>See the documentation of <a href="https://github.com/IntegralEquations/HMatrices.jl"><code>HMatrices</code></a> for more details on usage and other keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/nystrom.jl#L139-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.assemble_matrix-Tuple{Inti.IntegralOperator}" href="#Inti.assemble_matrix-Tuple{Inti.IntegralOperator}"><code>Inti.assemble_matrix</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assemble_matrix(iop::IntegralOperator; threads = true)</code></pre><p>Assemble a dense matrix representation of an <code>IntegralOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/nystrom.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.bdim_correction-Tuple{Any, Any, Inti.Quadrature, Any, Any}" href="#Inti.bdim_correction-Tuple{Any, Any, Inti.Quadrature, Any, Any}"><code>Inti.bdim_correction</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bdim_correction(op,X,Y,S,D; green_multiplier, kwargs...)</code></pre><p>Given a <code>op</code> and a (possibly inaccurate) discretizations of its single and double-layer operators <code>S</code> and <code>D</code> (taking a vector of values on <code>Y</code> and returning a vector on of values on <code>X</code>), compute corrections <code>Œ¥S</code> and <code>Œ¥D</code> such that <code>S + Œ¥S</code> and <code>D + Œ¥D</code> are more accurate approximations of the underlying single- and double-layer integral operators.</p><p>See [<a href="../references/#faria2021general">8</a>] for more details on the method.</p><p><strong>Arguments</strong></p><p><strong>Required:</strong></p><ul><li><code>op</code> must be an <a href="#Inti.AbstractDifferentialOperator"><code>AbstractDifferentialOperator</code></a></li><li><code>Y</code> must be a <a href="../tutorials/getting_started/#Quadrature"><code>Quadrature</code></a> object of a closed surface</li><li><code>X</code> is either inside, outside, or on <code>Y</code></li><li><code>S</code> and <code>D</code> are approximations to the single- and double-layer operators for <code>op</code> taking densities in <code>Y</code> and returning densities in <code>X</code>.</li><li><code>green_multiplier</code> (keyword argument) is a vector with the same length as <code>X</code> storing the value of <code>Œº(x)</code> for <code>x ‚àà X</code> in the Green identity <code>S\[Œ≥‚ÇÅu\](x) - D\[Œ≥‚ÇÄu\](x) + Œº*u(x) = 0</code>. See <a href="#Inti._green_multiplier-Tuple{Symbol}"><code>_green_multiplier</code></a>.</li></ul><p><strong>Optional <code>kwargs</code>:</strong></p><ul><li><code>parameters::DimParameters</code>: parameters associated with the density interpolation method</li><li><code>derivative</code>: if true, compute the correction to the adjoint double-layer and hypersingular operators instead. In this case, <code>S</code> and <code>D</code> should be replaced by a (possibly innacurate) discretization of adjoint double-layer and hypersingular operators, respectively.</li><li><code>maxdist</code>: distance beyond which interactions are considered sufficiently far so that no correction is needed. This is used to determine a threshold for nearly-singular corrections when <code>X</code> and <code>Y</code> are different surfaces. When <code>X === Y</code>, this is not needed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/bdim.jl#L12-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.bean-Tuple{}" href="#Inti.bean-Tuple{}"><code>Inti.bean</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bean(; translation, rotation, scaling, labels)</code></pre><p>Create a bean entity in 3D, and apply optional transformations. Returns the key.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/simpleshapes.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.blocksize-Union{Tuple{Inti.BlockArray{T}}, Tuple{T}} where T" href="#Inti.blocksize-Union{Tuple{Inti.BlockArray{T}}, Tuple{T}} where T"><code>Inti.blocksize</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">blocksize(A::BlockArray)</code></pre><p>The size of an individual entry of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/blockarray.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.boundary-Tuple{Inti.Domain}" href="#Inti.boundary-Tuple{Inti.Domain}"><code>Inti.boundary</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">boundary(Œ©::Domain)</code></pre><p>Return the external boundaries of a domain.</p><p>See also: <a href="#Inti.external_boundary-Tuple{Inti.Domain}"><code>external_boundary</code></a>, <a href="#Inti.internal_boundary-Tuple{Inti.Domain}"><code>internal_boundary</code></a>, <a href="#Inti.skeleton-Tuple{Inti.Domain}"><code>skeleton</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/domain.jl#L113-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.boundary_idxs-Tuple{Inti.LagrangeElement{Inti.ReferenceHyperCube{1}}}" href="#Inti.boundary_idxs-Tuple{Inti.LagrangeElement{Inti.ReferenceHyperCube{1}}}"><code>Inti.boundary_idxs</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">boundary_idxs(el::LagrangeElement)</code></pre><p>The indices of the nodes in <code>el</code> that define the boundary of the element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L360-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.cart2sph-Tuple{Any, Any, Any}" href="#Inti.cart2sph-Tuple{Any, Any, Any}"><code>Inti.cart2sph</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cart2sph(x,y,z)</code></pre><p>Map cartesian coordinates <code>x,y,z</code> to spherical ones <code>r, Œ∏, œÜ</code> representing the radius, elevation, and azimuthal angle respectively. The convention followed is that <code>0 ‚â§ Œ∏ ‚â§ œÄ</code> and <code>-œÄ &lt; œÜ ‚â§ œÄ</code>. Same as the <code>cart2sph</code> function in MATLAB.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L322-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.connectivity-Tuple{Inti.Mesh, DataType}" href="#Inti.connectivity-Tuple{Inti.Mesh, DataType}"><code>Inti.connectivity</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">connectivity(msh::AbstractMesh,E::DataType)</code></pre><p>Return the connectivity matrix for elements of type <code>E</code> in <code>msh</code>. The integer tags in the matrix refer to the points in <code>nodes(msh)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L119-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.coords-Tuple{T} where T" href="#Inti.coords-Tuple{T} where T"><code>Inti.coords</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coords(q)</code></pre><p>Return the spatial coordinates of <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/quadrature.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.cushion-Tuple{}" href="#Inti.cushion-Tuple{}"><code>Inti.cushion</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cushion(; translation, rotation, scaling, labels)</code></pre><p>Create a cushion entity in 3D, and apply optional transformations. Returns the key.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/simpleshapes.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.degree-Union{Tuple{Type{&lt;:Inti.LagrangeElement{D, Np}}}, Tuple{Np}, Tuple{D}} where {D, Np}" href="#Inti.degree-Union{Tuple{Type{&lt;:Inti.LagrangeElement{D, Np}}}, Tuple{Np}, Tuple{D}} where {D, Np}"><code>Inti.degree</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">degree(el::LagrangeElement)
degree(el::Type{&lt;:LagrangeElement})</code></pre><p>The polynomial degree <code>el</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L526-L531">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.dimension-Union{Tuple{Type{Inti.PolynomialSpace{D, K}}}, Tuple{K}, Tuple{D}} where {D, K}" href="#Inti.dimension-Union{Tuple{Type{Inti.PolynomialSpace{D, K}}}, Tuple{K}, Tuple{D}} where {D, K}"><code>Inti.dimension</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dimension(space)</code></pre><p>The length of a basis for <code>space</code>; i.e. the number of linearly independent elements required to span <code>space</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/polynomials.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.dom2elt-Tuple{Inti.AbstractMesh, Inti.Domain, DataType}" href="#Inti.dom2elt-Tuple{Inti.AbstractMesh, Inti.Domain, DataType}"><code>Inti.dom2elt</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dom2elt(m::Mesh,Œ©,E)::Vector{Int}</code></pre><p>Compute the element indices <code>idxs</code> of the elements of type <code>E</code> composing <code>Œ©</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.dom2qtags-Tuple{Inti.Quadrature, Inti.Domain}" href="#Inti.dom2qtags-Tuple{Inti.Quadrature, Inti.Domain}"><code>Inti.dom2qtags</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dom2qtags(Q::Quadrature, dom::Domain)</code></pre><p>Given a domain, return the indices of the quadratures nodes in <code>Q</code> associated to its quadrature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/quadrature.jl#L185-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.domain" href="#Inti.domain"><code>Inti.domain</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">domain(f)</code></pre><p>Given a function-like object <code>f: Œ© ‚Üí R</code>, return <code>Œ©</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.domain-Tuple{Inti.AbstractMesh}" href="#Inti.domain-Tuple{Inti.AbstractMesh}"><code>Inti.domain</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">domain(msh::AbstractMesh)</code></pre><p>Return a [<code>Domain</code>] containing of all entities covered by the mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.domain-Tuple{Inti.Quadrature}" href="#Inti.domain-Tuple{Inti.Quadrature}"><code>Inti.domain</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">domain(Q::Quadrature)</code></pre><p>The <a href="#Inti.Domain"><code>Domain</code></a> over which <code>Q</code> performs integration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/quadrature.jl#L176-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.domain-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D" href="#Inti.domain-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D"><code>Inti.domain</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">domain(q::ReferenceQuadrature)</code></pre><p>The domain of integratino for quadrature rule <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.element_types" href="#Inti.element_types"><code>Inti.element_types</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">element_types(msh::AbstractMesh)</code></pre><p>Return the element types present in the <code>msh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.elements" href="#Inti.elements"><code>Inti.elements</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">elements(msh::AbstractMesh [, E::DataType])</code></pre><p>Return the elements of a <code>msh</code>. Passing and element type <code>E</code> will restricts to elements of that type.</p><p>A common pattern to avoid type-instabilies in performance critical parts of the code is to use a <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#kernel-functions">function barrier</a>, as illustrated below:</p><pre><code class="language-julia hljs">for E in element_types(msh)
    _long_computation(elements(msh, E), args...)
end

@noinline function _long_computation(iter, args...)
    for el in iter # the type of el is known at compile time
        # do something with el
    end
end</code></pre><p>where a dynamic dispatch is performed only on the element types (typically small for a given mesh).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L25-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ellipsoid-Tuple{}" href="#Inti.ellipsoid-Tuple{}"><code>Inti.ellipsoid</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ellipsoid(; translation, rotation, scaling, labels)</code></pre><p>Create an ellipsoid entity in 3D, and apply optional transformations. Returns the key of the created entity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/simpleshapes.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ent2etags-Tuple{Inti.Mesh}" href="#Inti.ent2etags-Tuple{Inti.Mesh}"><code>Inti.ent2etags</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ent2etags(msh::AbstractMesh)</code></pre><p>Return a dictionary mapping entities to a dictionary of element types to element tags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L109-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.entities-Tuple{Inti.Domain}" href="#Inti.entities-Tuple{Inti.Domain}"><code>Inti.entities</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">entities(Œ©::Domain)</code></pre><p>Return all entities making up a domain (as a set of <a href="#Inti.EntityKey"><code>EntityKey</code></a>s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/domain.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.etype_to_nearest_points-Tuple{Any, Inti.Quadrature}" href="#Inti.etype_to_nearest_points-Tuple{Any, Inti.Quadrature}"><code>Inti.etype_to_nearest_points</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">etype_to_nearest_points(X,Y::Quadrature; maxdist)</code></pre><p>For each element <code>el</code> in <code>Y.mesh</code>, return a list with the indices of all points in <code>X</code> for which <code>el</code> is the nearest element. Ignore indices for which the distance exceeds <code>maxdist</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/quadrature.jl#L242-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.external_boundary-Tuple{Inti.Domain}" href="#Inti.external_boundary-Tuple{Inti.Domain}"><code>Inti.external_boundary</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">external_boundary(Œ©::Domain)</code></pre><p>Return the external boundaries inside a domain. These are entities in the skeleton of Œ© which are not in the internal boundaries of Œ©.</p><p>See also: <a href="#Inti.internal_boundary-Tuple{Inti.Domain}"><code>internal_boundary</code></a>, <a href="#Inti.skeleton-Tuple{Inti.Domain}"><code>skeleton</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/domain.jl#L101-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.fibonnaci_points_sphere-Tuple{Any, Any, Any}" href="#Inti.fibonnaci_points_sphere-Tuple{Any, Any, Any}"><code>Inti.fibonnaci_points_sphere</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fibonnaci_points_sphere(N,r,c)</code></pre><p>Return <code>N</code> points distributed (roughly) in a uniform manner on the sphere of radius <code>r</code> centered at <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L152-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.flip_normal-Tuple{Inti.QuadratureNode}" href="#Inti.flip_normal-Tuple{Inti.QuadratureNode}"><code>Inti.flip_normal</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flip_normal(q::QuadratureNode)</code></pre><p>Return a new <code>QuadratureNode</code> with the normal vector flipped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/quadrature.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.gauss_curvature-Tuple{Inti.Quadrature}" href="#Inti.gauss_curvature-Tuple{Inti.Quadrature}"><code>Inti.gauss_curvature</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gauss_curvature(Q::Quadrature)</code></pre><p>Compute the <code>gauss_curvature</code> at each quadrature node in <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/quadrature.jl#L324-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.gauss_curvature-Tuple{Inti.ReferenceInterpolant, Any}" href="#Inti.gauss_curvature-Tuple{Inti.ReferenceInterpolant, Any}"><code>Inti.gauss_curvature</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gauss_curvature(œÑ, xÃÇ)</code></pre><p>Calculate the <a href="https://en.wikipedia.org/wiki/Gaussian_curvature">Gaussian curvature</a> of the element <code>œÑ</code> at the parametric coordinate <code>xÃÇ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L93-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.geometric_dimension" href="#Inti.geometric_dimension"><code>Inti.geometric_dimension</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geometric_dimension(x)</code></pre><p>NNumber of degrees of freedom necessary to locally represent the geometrical object. For example, lines have geometric dimension of 1 (whether in <code>‚Ñù¬≤</code> or in <code>‚Ñù¬≥</code>), while surfaces have geometric dimension of 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.global_get_entity-Tuple{Inti.EntityKey}" href="#Inti.global_get_entity-Tuple{Inti.EntityKey}"><code>Inti.global_get_entity</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">global_get_entity(k::EntityKey)</code></pre><p>Retrieve the <a href="#Inti.GeometricEntity"><code>GeometricEntity</code></a> corresponding to the <a href="#Inti.EntityKey"><code>EntityKey</code></a> <code>k</code> from the global <code>ENTITIES</code> dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/entities.jl#L307-L312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.gmsh_curve-Tuple" href="#Inti.gmsh_curve-Tuple"><code>Inti.gmsh_curve</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gmsh_curve(f::Function, a, b; npts=100, meshsize = 0, tag=-1)</code></pre><p>Create a curve in the current <code>gmsh</code> model given by <code>{f(t) : t ‚àà (a,b) }</code> where <code>f</code> is a function from <code>‚Ñù</code> to <code>‚Ñù^3</code>. The curve is approximated by C¬≤ b-splines passing through <code>npts</code> equispaced in parameter space. If a <code>meshsize</code> is given, <code>gmsh</code> will use it when meshing the curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/gmsh_api.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.hessian-Tuple{Inti.ReferenceInterpolant, Any}" href="#Inti.hessian-Tuple{Inti.ReferenceInterpolant, Any}"><code>Inti.hessian</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hesssian(el,x)</code></pre><p>Given a (possibly vector-valued) functor <code>f : ùêë·µê ‚Üí ùêÖ‚Åø</code>, return the <code>n √ó m √ó m</code> matrix <code>A·µ¢‚±º‚±º = ‚àÇ¬≤f·µ¢/‚àÇx‚±º‚àÇx‚±º</code>. By default <code>ForwardDiff</code> is used to compute the hessian, but you should overload this method for specific <code>f</code> if better performance and/or precision is required.</p><p>Note: both <code>x</code> and <code>f(x)</code> are expected to be of <code>SVector</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L41-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.image" href="#Inti.image"><code>Inti.image</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">image(f)</code></pre><p>Given a function-like object <code>f: Œ© ‚Üí R</code>, return <code>f(Œ©)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.import_mesh-Tuple" href="#Inti.import_mesh-Tuple"><code>Inti.import_mesh</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">import_mesh(filename = nothing; dim=3)</code></pre><p>Open <code>filename</code> and create a <a href="#Inti.Mesh"><code>Mesh</code></a> from the <code>gmsh</code> model in it.</p><p>If <code>filename</code> is <code>nothing</code>, the current <code>gmsh</code> model is used. Note that this assumes that the <em>Gmsh</em> API has been initialized through <code>gmsh.initialize</code>.</p><p>Passing <code>dim=2</code> will create a two-dimensional mesh by projecting the original mesh onto the <code>x,y</code> plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/gmsh_api.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.integrate-Tuple{Any, Inti.Quadrature}" href="#Inti.integrate-Tuple{Any, Inti.Quadrature}"><code>Inti.integrate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate(f,quad::Quadrature)</code></pre><p>Compute <code>‚àë·µ¢ f(q·µ¢)w·µ¢</code>, where the <code>q·µ¢</code> are the quadrature nodes of <code>quad</code>, and <code>w·µ¢</code> are the quadrature weights.</p><p>Note that you must define <code>f(::QuadratureNode)</code>: use <code>q.coords</code> and <code>q.normal</code> if you need to access the coordinate or normal vector at que quadrature node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/quadrature.jl#L229-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.integrate-Tuple{Any, Inti.ReferenceQuadrature}" href="#Inti.integrate-Tuple{Any, Inti.ReferenceQuadrature}"><code>Inti.integrate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate(f,q::ReferenceQuadrature)
integrate(f,x,w)</code></pre><p>Integrate the function <code>f</code> using the quadrature rule <code>q</code>. This is simply <code>sum(f.(x) .* w)</code>, where <code>x</code> and <code>w</code> are the quadrature nodes and weights, respectively.</p><p>The function <code>f</code> should take an <code>SVector</code> as input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L38-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.integrate_with_error_estimate" href="#Inti.integrate_with_error_estimate"><code>Inti.integrate_with_error_estimate</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate_with_error_estimate(f, quad::EmbeddedQuadrature, norm = LinearAlgebra.norm)</code></pre><p>Return <code>I, E</code> where <code>I</code> is the estimated integral of <code>f</code> over <code>domain(quad)</code> using the high-order quadrature and <code>E</code> is the error estimate obtained by taking the <code>norm</code> of the difference between the high and low-order quadratures in <code>quad</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L367-L374">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.integration_measure-Tuple{Any, Any}" href="#Inti.integration_measure-Tuple{Any, Any}"><code>Inti.integration_measure</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integration_measure(f, xÃÇ)</code></pre><p>Given the Jacobian matrix <code>J</code> of a transformation <code>f : ‚Ñù·¥π ‚Üí ‚Ñù·¥∫</code> compute the integration measure <code>‚àödet(J·µÄJ)</code> at the parametric coordinate <code>xÃÇ</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.interface_method-Tuple{DataType}" href="#Inti.interface_method-Tuple{DataType}"><code>Inti.interface_method</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interface_method(x)</code></pre><p>A method of an <code>abstract type</code> for which concrete subtypes are expected to provide an implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.internal_boundary-Tuple{Inti.Domain}" href="#Inti.internal_boundary-Tuple{Inti.Domain}"><code>Inti.internal_boundary</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">internal_boundary(Œ©::Domain)</code></pre><p>Return the internal boundaries of a <code>Domain</code>. These are entities in <code>skeleton(Œ©)</code> which appear at least twice as a boundary of entities in <code>Œ©</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/domain.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.interpolation_order-Tuple{Inti.ReferenceQuadrature{Inti.ReferenceHyperCube{1}}}" href="#Inti.interpolation_order-Tuple{Inti.ReferenceQuadrature{Inti.ReferenceHyperCube{1}}}"><code>Inti.interpolation_order</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolation_order(qrule::ReferenceQuadrature)</code></pre><p>The interpolation order of a quadrature rule is defined as the the smallest <code>k</code> such that there exists a unique polynomial in <code>PolynomialSpace{D,k}</code> that minimizes the error in approximating the function <code>f</code> at the quadrature nodes.</p><p>For an <code>N</code>-point Gauss quadrature rule on the segment, the interpolation order is <code>N-1</code> since <code>N</code> points uniquely determine a polynomial of degree <code>N-1</code>.</p><p>For a triangular reference domain, the interpolation order is more difficult to define. An unisolvent three-node quadrature on the triangular, for example, has an interpolation order <code>k=1</code> since the three nodes uniquely determine a linear polynomial, but a four-node quadrature may also have an interpolation order <code>k=1</code> since for <code>k=2</code> there are multiple polynomials that pass through the four nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L428-L445">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.jacobian-Tuple{Any, Any}" href="#Inti.jacobian-Tuple{Any, Any}"><code>Inti.jacobian</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobian(f,x)</code></pre><p>Given a (possibly vector-valued) functor <code>f : ùêë·µê ‚Üí ùêÖ‚Åø</code>, return the <code>n √ó m</code> matrix <code>A·µ¢‚±º = ‚àÇf·µ¢/‚àÇx‚±º</code>. By default <code>ForwardDiff</code> is used to compute the jacobian, but you should overload this method for specific <code>f</code> if better performance and/or precision is required.</p><p>Note: both <code>x</code> and <code>f(x)</code> are expected to be of <code>SVector</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L26-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.kress_change_of_variables-Tuple{Any}" href="#Inti.kress_change_of_variables-Tuple{Any}"><code>Inti.kress_change_of_variables</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kress_change_of_variables(P)</code></pre><p>Return a change of variables mapping <code>[0,1]</code> to <code>[0,1]</code> with the property that the first <code>P-1</code> derivatives of the transformation vanish at <code>x=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L372-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.kress_change_of_variables_periodic-Tuple{Any}" href="#Inti.kress_change_of_variables_periodic-Tuple{Any}"><code>Inti.kress_change_of_variables_periodic</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kress_change_of_variables_periodic(P)</code></pre><p>Like <a href="#Inti.kress_change_of_variables-Tuple{Any}"><code>kress_change_of_variables</code></a>, this change of variables maps the interval <code>[0,1]</code> onto itself, but the first <code>P</code> derivatives of the transformation vanish at <strong>both</strong> endpoints (thus making it a periodic function).</p><p>This change of variables can be used to <em>periodize</em> integrals over the interval <code>[0,1]</code> by mapping the integrand into a new integrand that vanishes (to order P) at both endpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L383-L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.lagrange_basis-Tuple{Any, Inti.PolynomialSpace}" href="#Inti.lagrange_basis-Tuple{Any, Inti.PolynomialSpace}"><code>Inti.lagrange_basis</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lagrange_basis(nodes,[sp::AbstractPolynomialSpace])</code></pre><p>Return the set of <code>n</code> polynomials in <code>sp</code> taking the value of <code>1</code> on node <code>i</code> and <code>0</code> on nodes <code>j ‚âÇÃ∏ i</code> for <code>1 ‚â§ i ‚â§ n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/polynomials.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.lagrange_basis-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D" href="#Inti.lagrange_basis-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D"><code>Inti.lagrange_basis</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lagrange_basis(qrule::ReferenceQuadrature)</code></pre><p>Return a function <code>L : ‚Ñù·¥∫ ‚Üí ‚Ñù·µñ</code> where <code>N</code> is the dimension of the domain of <code>qrule</code>, and <code>p</code> is the number of nodes in <code>qrule</code>. The function <code>L</code> is a polynomial in <a href="#Inti.polynomial_space-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D"><code>polynomial_space(qrule)</code></a>, and <code>L(x‚±º)[i] = Œ¥·µ¢‚±º</code> (i.e. the <code>i</code>th component of <code>L</code> is the <code>i</code>th Lagrange basis).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L402-L409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.lagrange_basis-Union{Tuple{Type{Inti.LagrangeElement{D, N, T}}}, Tuple{T}, Tuple{N}, Tuple{D}} where {D, N, T}" href="#Inti.lagrange_basis-Union{Tuple{Type{Inti.LagrangeElement{D, N, T}}}, Tuple{T}, Tuple{N}, Tuple{D}} where {D, N, T}"><code>Inti.lagrange_basis</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lagrange_basis(E::Type{&lt;:LagrangeElement})</code></pre><p>Return the Lagrange basis <code>B</code> for the element <code>E</code>. Evaluating <code>B(x)</code> yields the value of each basis function at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L550-L555">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.laurent_coefficients-Tuple{Any, Any, Val{-2}}" href="#Inti.laurent_coefficients-Tuple{Any, Any, Val{-2}}"><code>Inti.laurent_coefficients</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">laurent_coefficients(f, h, order) --&gt; f‚Çã‚ÇÇ, f‚Çã‚ÇÅ, f‚ÇÄ</code></pre><p>Given a one-dimensional function <code>f</code>, return <code>f‚Çã‚ÇÇ, f‚Çã‚ÇÅ, f‚ÇÄ</code> such that <code>f(x) = f‚Çã‚ÇÇ / x^2 + f‚Çã‚ÇÅ / x + f‚ÇÄ + ùí™(x)</code> as <code>x -&gt; 0</code>, where we assume that <code>f‚Çô = 0</code> for <code>n &lt; N</code>.</p><p>The <code>order</code> argument is an integer that indicates the order of the singularity at the origin:</p><ul><li><code>Val{-2}</code>: The function has a singularity of order <code>-2</code> at the origin.</li><li><code>Val{-1}</code>: The function has a singularity of order <code>-1</code> at the origin, so <code>f‚Çã‚ÇÇ = 0</code>.</li><li><code>Val{0}</code>: The function has a finite part at the origin, so <code>f‚Çã‚ÇÇ = f‚Çã‚ÇÅ = 0</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/adaptive_correction.jl#L390-L401">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.line-Tuple{Any, Any}" href="#Inti.line-Tuple{Any, Any}"><code>Inti.line</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">line(a,b)</code></pre><p>Create a [<code>GeometricEntity</code>] representing a straight line connecting points <code>a</code> and <code>b</code>. The points <code>a</code> and <code>b</code> can be either <code>SVector</code>s or a <code>Tuple</code>.</p><p>The parametrization of the line is given by <code>f(u) = a + u(b - a)</code>, where <code>0 ‚â§ u ‚â§ 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/entities.jl#L166-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.local_correction_dist_and_tol" href="#Inti.local_correction_dist_and_tol"><code>Inti.local_correction_dist_and_tol</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">local_correction_dist_and_tol(iop::IntegralOperator, kmax = 10, ratio = 8)</code></pre><p>Try to estimate resonable <code>maxdist</code> and <code>rtol</code> parameters for the <a href="#Inti.adaptive_correction-Tuple{Inti.IntegralOperator}"><code>adaptive_correction</code></a> function, where <code>maxdist</code> is at most <code>kmax</code> times the radius of the largest element in the source mesh of <code>iop</code>. See the Extended help for more details.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is a heuristic and may not be accurate/efficient in all cases. It is recommended to test different values of <code>maxdist</code> and <code>rtol</code> to find the optimal values for your problem.</p></div></div><p><strong>Extended help</strong></p><p>The heuristic works as follows, where we let <code>K = kernel(iop)</code> and <code>msh = mesh(source(iop))</code>:</p><ol><li>Pick the largest element in <code>msh</code></li><li>Let <code>h</code> be the radius of <code>el</code></li><li>For <code>k</code> between <code>1</code> and <code>kmax</code>, estimate the (relative) quadrature error when integrating <code>y -&gt; K(x,y)</code> for <code>x</code> at a distance <code>k * h</code> from the center of the element using a regular quadrature rule</li><li>Find a <code>k</code> such that ratio between errors at distances <code>k * h</code> and <code>(k + 1) * h</code> is below <code>ratio</code>. This indicates stagnation in the error, and suggests that little is gained by increasing the distance.</li><li>Return <code>maxdist = k * h</code> and <code>rtol</code> as the error at distance <code>k * h</code>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/adaptive_correction.jl#L438-L464">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.mean_curvature-Tuple{Inti.Quadrature}" href="#Inti.mean_curvature-Tuple{Inti.Quadrature}"><code>Inti.mean_curvature</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mean_curvature(Q::Quadrature)</code></pre><p>Compute the <code>mean_curvature</code> at each quadrature node in <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/quadrature.jl#L317-L321">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.mean_curvature-Tuple{Inti.ReferenceInterpolant, Any}" href="#Inti.mean_curvature-Tuple{Inti.ReferenceInterpolant, Any}"><code>Inti.mean_curvature</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mean_curvature(œÑ, xÃÇ)</code></pre><p>Calculate the <a href="https://en.wikipedia.org/wiki/Mean_curvature">mean curvature</a> of the element <code>œÑ</code> at the parametric coordinate <code>xÃÇ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.measure" href="#Inti.measure"><code>Inti.measure</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measure(k::EntityKey, rtol)</code></pre><p>Compute the length/area/volume of the entity <code>k</code> using an adaptive quadrature with a relative tolerance <code>rtol</code>. Assumes that the entity has an explicit parametrization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/entities.jl#L141-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.meshgen!-Tuple{Inti.Mesh, Inti.Domain, Int64}" href="#Inti.meshgen!-Tuple{Inti.Mesh, Inti.Domain, Int64}"><code>Inti.meshgen!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">meshgen!(mesh,Œ©,sz)</code></pre><p>Similar to <a href="#Inti.meshgen-Tuple{Inti.Domain, Vararg{Any}}"><code>meshgen</code></a>, but append entries to <code>mesh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L266-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.meshgen-Tuple{Inti.Domain, Vararg{Any}}" href="#Inti.meshgen-Tuple{Inti.Domain, Vararg{Any}}"><code>Inti.meshgen</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">meshgen(Œ©, n; T = Float64)
meshgen(Œ©, n_dict; T = Float64)
meshgen(Œ©; meshsize, T = Float64)</code></pre><p>Generate a <code>Mesh</code> for the domain <code>Œ©</code> where each curve is meshed using <code>n</code> elements. Passing a dictionary allows for a finer control; in such cases, <code>n_dict[ent]</code> should return an integer for each entity <code>ent</code> in <code>Œ©</code> of <code>geometric_dimension</code> one.</p><p>Alternatively, a <code>meshsize</code> can be passed, in which case, the number of elements is computed as so as to obtain an <em>average</em> mesh size of <code>meshsize</code>. Note that the actual mesh size may vary significantly for each element if the parametrization is far from uniform.</p><p>The mesh is created with primitive data of type <code>T</code>.</p><p>This function requires the entities forming <code>Œ©</code> to have an explicit parametrization.</p><div class="admonition is-warning"><header class="admonition-header">Mesh quality</header><div class="admonition-body"><p>The quality of the generated mesh created using <code>meshgen</code> depends on the quality of the underlying parametrization. For complex surfaces, you are better off using a proper mesher such as <code>gmsh</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L229-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.monomial_basis" href="#Inti.monomial_basis"><code>Inti.monomial_basis</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">monomial_basis(sp::PolynomialSpace)</code></pre><p>Return a function <code>f : ‚Ñù·¥∫ ‚Üí ‚Ñù·µà</code>, where <code>N</code> is the dimension of the domain of <code>sp</code>     containing a basis of monomials <code>ùê±·∂ø</code> spanning the polynomial space <a href="#Inti.PolynomialSpace"><code>PolynomialSpace</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/polynomials.jl#L47-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.near_interaction_list-Union{Tuple{N}, Tuple{AbstractVector{&lt;:StaticArraysCore.SVector{N}}, Inti.AbstractMesh{N}}} where N" href="#Inti.near_interaction_list-Union{Tuple{N}, Tuple{AbstractVector{&lt;:StaticArraysCore.SVector{N}}, Inti.AbstractMesh{N}}} where N"><code>Inti.near_interaction_list</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">near_interaction_list(X,Y::AbstractMesh; tol)</code></pre><p>For each element <code>el</code> of type <code>E</code> in <code>Y</code>, return the indices of the points in <code>X</code> which are closer than <code>tol</code> to the <code>center</code> of <code>el</code>.</p><p>This function returns a dictionary where e.g. <code>dict[E][5] --&gt; Vector{Int}</code> gives the indices of points in <code>X</code> which are closer than <code>tol</code> to the center of the fifth element of type <code>E</code>.</p><p>If <code>tol</code> is a <code>Dict</code>, then <code>tol[E]</code> is the tolerance for elements of type <code>E</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L610-L621">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.new_tag-Tuple{Integer}" href="#Inti.new_tag-Tuple{Integer}"><code>Inti.new_tag</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">new_tag(dim)</code></pre><p>Return a new tag for an entity of dimension <code>dim</code> so that <code>EntityKey(dim, tag)</code> is not already in <code>ENTITIES</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/entities.jl#L317-L322">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.nodes-Tuple{Inti.SubMesh}" href="#Inti.nodes-Tuple{Inti.SubMesh}"><code>Inti.nodes</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nodes(msh::SubMesh)</code></pre><p>A view of the nodes of the parent mesh belonging to the submesh. The ordering is given by the <a href="#Inti.nodetags-Tuple{Inti.SubMesh}"><code>nodetags</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L591-L596">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.nodetags-Tuple{Inti.SubMesh}" href="#Inti.nodetags-Tuple{Inti.SubMesh}"><code>Inti.nodetags</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nodetags(msh::SubMesh)</code></pre><p>Return the tags of the nodes in the parent mesh belonging to the submesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L577-L581">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.normal-Tuple{Any, Any}" href="#Inti.normal-Tuple{Any, Any}"><code>Inti.normal</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normal(el, xÃÇ)</code></pre><p>Return the normal vector of <code>el</code> at the parametric coordinate <code>xÃÇ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.normal-Tuple{T} where T" href="#Inti.normal-Tuple{T} where T"><code>Inti.normal</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normal(q)</code></pre><p>Return the normal vector of <code>q</code>, if it exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/quadrature.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.notimplemented-Tuple{}" href="#Inti.notimplemented-Tuple{}"><code>Inti.notimplemented</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">notimplemented()</code></pre><p>Things which should probably be implemented at some point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.order-Union{Tuple{Inti.Fejer{N}}, Tuple{N}} where N" href="#Inti.order-Union{Tuple{Inti.Fejer{N}}, Tuple{N}} where N"><code>Inti.order</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">order(q::ReferenceQuadrature)</code></pre><p>A quadrature of order <code>p</code> (sometimes called degree of precision) integrates all polynomials of degree <code>‚â§ p</code> but not <code>‚â§ p + 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.order-Union{Tuple{Type{&lt;:Inti.LagrangeElement{D, Np}}}, Tuple{Np}, Tuple{D}} where {D, Np}" href="#Inti.order-Union{Tuple{Type{&lt;:Inti.LagrangeElement{D, Np}}}, Tuple{Np}, Tuple{D}} where {D, Np}"><code>Inti.order</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">order(el::LagrangeElement)</code></pre><p>The order of the element&#39;s interpolating polynomial (e.g. a <code>LagrangeLine</code> with <code>2</code> nodes defines a linear polynomial, and thus has order <code>1</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L262-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.orientation-Tuple{Inti.AbstractMesh, DataType}" href="#Inti.orientation-Tuple{Inti.AbstractMesh, DataType}"><code>Inti.orientation</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orientation(msh::AbstractMesh,E::DataType)</code></pre><p>Return the orientation of the elements of type <code>E</code> in <code>msh</code> (<code>1</code> if normal and <code>-1</code> if inverted).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/mesh.jl#L127-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.parametric_curve-Union{Tuple{F}, Tuple{F, Real, Real}} where F" href="#Inti.parametric_curve-Union{Tuple{F}, Tuple{F, Real, Real}} where F"><code>Inti.parametric_curve</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parametric_curve(f, a::Real, b::Real)</code></pre><p>Create a [<code>GeometricEntity</code>] representing a parametric curve defined by the <code>{f(t) | a ‚â§ t ‚â§ b}</code>. The function <code>f</code> should map a scalar to an <code>SVector</code>.</p><p>Flipping the orientation is supported by passing <code>a &gt; b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/entities.jl#L182-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.parametric_surface" href="#Inti.parametric_surface"><code>Inti.parametric_surface</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    parametric_surface(f, lc, hc, boundary = nothing; kwargs...)</code></pre><p>Create a parametric surface defined by the function <code>f</code> over the rectangular domain defined by the lower corner <code>lc</code> and the upper corner <code>hc</code>. The optional <code>boundary</code> argument can be used to specify the boundary curves of the surface.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: A function that takes two arguments <code>x</code> and <code>y</code> and returns a tuple <code>(u, v)</code>   representing the parametric coordinates of the surface at <code>(x, y)</code>.</li><li><code>lc</code>: A 2-element array representing the lower corner of the rectangular domain.</li><li><code>hc</code>: A 2-element array representing the upper corner of the rectangular domain.</li><li><code>boundary</code>: An optional array of boundary curves that define the surface.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>kwargs</code>: Additional keyword arguments that can be passed to the <code>GeometricEntity</code>   constructor.</li></ul><p><strong>Returns</strong></p><ul><li>The key of the created <code>GeometricEntity</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/entities.jl#L252-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.polar_decomposition-Tuple{Inti.ReferenceHyperCube{2}, StaticArraysCore.SVector{2, &lt;:Number}}" href="#Inti.polar_decomposition-Tuple{Inti.ReferenceHyperCube{2}, StaticArraysCore.SVector{2, &lt;:Number}}"><code>Inti.polar_decomposition</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">polar_decomposition(shape::ReferenceSquare, xÃÇ::SVector{2,Float64})</code></pre><p>Decompose the square <code>[0,1] √ó [0,1]</code> into four triangles, and return four tuples of the form <code>Œ∏‚Çõ, Œ∏‚Çë, œÅ</code> where <code>Œ∏‚Çõ</code> and <code>Œ∏‚Çë</code> are the initial and final angles of the triangle, and <code>œÅ</code> is the function that gives the distance from <code>xÃÇ</code> to the border of the square in the direction <code>Œ∏</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/adaptive_correction.jl#L215-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.polar_decomposition-Tuple{Inti.ReferenceSimplex{2}, StaticArraysCore.SVector{2, &lt;:Number}}" href="#Inti.polar_decomposition-Tuple{Inti.ReferenceSimplex{2}, StaticArraysCore.SVector{2, &lt;:Number}}"><code>Inti.polar_decomposition</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">polar_decomposition(shape::ReferenceTriangle, xÃÇ::SVector{2,Float64})</code></pre><p>Decompose the triangle <code>{x,y ‚â• 0, x + y ‚â§ 1}</code> into three triangles, and return three tuples of the form <code>Œ∏‚Çõ, Œ∏‚Çë, œÅ</code> where <code>Œ∏‚Çõ</code> and <code>Œ∏‚Çë</code> are the initial and final angles of the triangle, and <code>œÅ</code> is the function that gives the distance from <code>xÃÇ</code> to the border of the triangle in the direction <code>Œ∏</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/adaptive_correction.jl#L238-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.polynomial_solutions_vdim" href="#Inti.polynomial_solutions_vdim"><code>Inti.polynomial_solutions_vdim</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">polynomial_solutions_vdim(op, order[, center])</code></pre><p>For every monomial term <code>p‚Çô</code> of degree <code>order</code>, compute a polynomial <code>P‚Çô</code> such that <code>‚Ñí[P‚Çô] = p‚Çô</code>, where <code>‚Ñí</code> is the differential operator associated with <code>op</code>. This function returns <code>{p‚Çô,P‚Çô,Œ≥‚ÇÅP‚Çô}</code>, where <code>Œ≥‚ÇÅP‚Çô</code> is the generalized Neumann trace of <code>P‚Çô</code>.</p><p>Passing a point <code>center</code> will shift the monomials and solutions accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/vdim.jl#L297-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.polynomial_space-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D" href="#Inti.polynomial_space-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D"><code>Inti.polynomial_space</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">polynomial_space(qrule::ReferenceQuadrature)</code></pre><p>Return a <a href="#Inti.PolynomialSpace"><code>PolynomialSpace</code></a> associated with the <a href="#Inti.interpolation_order-Tuple{Inti.ReferenceQuadrature{Inti.ReferenceHyperCube{1}}}"><code>interpolation_order</code></a> of the quadrature nodes of <code>qrule</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L417-L422">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.qcoords-Tuple{Inti.ReferenceQuadrature}" href="#Inti.qcoords-Tuple{Inti.ReferenceQuadrature}"><code>Inti.qcoords</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qcoords(q)</code></pre><p>Return the coordinate of the quadrature nodes associated with <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.quadrature_to_node_vals-Tuple{Inti.Quadrature, AbstractVector}" href="#Inti.quadrature_to_node_vals-Tuple{Inti.Quadrature, AbstractVector}"><code>Inti.quadrature_to_node_vals</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quadrature_to_node_vals(Q::Quadrature, qvals::AbstractVector)</code></pre><p>Given a vector <code>qvals</code> of scalar values at the quadrature nodes of <code>Q</code>, return a vector <code>ivals</code> of scalar values at the interpolation nodes of <code>Q.mesh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/quadrature.jl#L288-L293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.qweights-Tuple{Inti.ReferenceQuadrature}" href="#Inti.qweights-Tuple{Inti.ReferenceQuadrature}"><code>Inti.qweights</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qweights(q)</code></pre><p>Return the quadrature weights associated with <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_integration.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.reference_nodes-Tuple{Inti.LagrangeElement}" href="#Inti.reference_nodes-Tuple{Inti.LagrangeElement}"><code>Inti.reference_nodes</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reference_nodes(el::LagrangeElement)
reference_nodes(::Type{&lt;:LagrangeElement})</code></pre><p>Return the reference nodes on <code>domain(el)</code> used for the polynomial interpolation. The function values on these nodes completely determines the interpolating polynomial.</p><p>We use the same convention as <code>gmsh</code> for defining the reference nodes and their order (see <a href="https://gmsh.info/doc/texinfo/gmsh.html#Node-ordering">node ordering</a> on <code>gmsh</code> documentation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L230-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.return_type-Tuple{Any, Vararg{Any}}" href="#Inti.return_type-Tuple{Any, Vararg{Any}}"><code>Inti.return_type</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">return_type(f[,args...])</code></pre><p>The type returned by <code>f(args...)</code>, where <code>args</code> is a tuple of types. Falls back to <code>Base.promote_op</code> by default.</p><p>A functors of type <code>T</code> with a knonw return type should extend <code>return_type(::T,args...)</code> to avoid relying on <code>promote_op</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L52-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.rotation_matrix-Tuple{Any}" href="#Inti.rotation_matrix-Tuple{Any}"><code>Inti.rotation_matrix</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotation_matrix(rot)</code></pre><p>Constructs a rotation matrix given the rotation angles around the x, y, and z axes.</p><p><strong>Arguments</strong></p><ul><li><code>rot</code>: A tuple or vector containing the rotation angles in radians for each axis.</li></ul><p><strong>Returns</strong></p><ul><li><code>R::SMatrix</code>: The resulting rotation matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L337-L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.single_double_layer-Tuple{}" href="#Inti.single_double_layer-Tuple{}"><code>Inti.single_double_layer</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">single_double_layer(; op, target, source::Quadrature, compression,
correction, derivative = false)</code></pre><p>Construct a discrete approximation to the single- and double-layer integral operators for <code>op</code>, mapping values defined on the quadrature nodes of <code>source</code> to values defined on the nodes of <code>target</code>. If <code>derivative = true</code>, return instead the adjoint double-layer and hypersingular operators (which are the generalized Neumann trace of the single- and double-layer, respectively).</p><p>For finer control, you must choose a <code>compression</code> method and a <code>correction</code> method, as described below.</p><p><strong>Compression</strong></p><p>The <code>compression</code> argument is a named tuple with a <code>method</code> field followed by method-specific fields. It specifies how the dense linear operators should be compressed. The available options are:</p><ul><li><code>(method = :none, )</code>: no compression is performed, the resulting matrices are dense. This is the default, but not recommended for large problems.</li><li><code>(method =:hmatrix, tol)</code>: the resulting operators are compressed using hierarchical matrices with an absolute tolerance <code>tol</code> (defaults to <code>1e-8</code>).</li><li><code>(method = :fmm, tol)</code>: the resulting operators are compressed using the fast multipole method with an absolute tolerance <code>tol</code> (defaults to <code>1e-8</code>).</li></ul><p><strong>Correction</strong></p><p>The <code>correction</code> argument is a named tuple with a <code>method</code> field followed by method-specific fields. It specifies how the singular and nearly-singular integrals should be computed. The available options are:</p><ul><li><code>(method = :none, )</code>: no correction is performed. This is not recommended, as the resulting approximation will be inaccurate if the kernel is singular and source and target are not sufficiently far from each other.</li><li><code>(method = :adaptive, maxdist, tol)</code>: correct interactions corresponding to entries of <code>target</code> and elements of <code>source</code> that are within <code>maxdist</code> of each other. The singular (including finite part) interactions are computed in polar coordinates, while the near-singular interactions are computing using an adaptive quadrature rule. The <code>tol</code> argument specifies the tolerance of the adaptive integration. See <a href="#Inti.adaptive_correction-Tuple{Inti.IntegralOperator}"><code>adaptive_correction</code></a> for more details.</li><li><code>(method = :dim, maxdist, target_location)</code>: use the density interpolation method to compute the correction. <code>maxdist</code> specifies the distance between source and target points above which no correction is performed (defaults to <code>Inf</code>). <code>target_location</code> should be either <code>:inside</code>, <code>:outside</code>, or <code>:on</code>, and specifies where the <code>target</code><code>points lie relative to the to the</code>source<code>curve/surface (which is assumed to be closed). When</code>target === source<code>,</code>target<em>location<code>is not needed. See [</code>bdim</em>correction<code>](@ref) and [</code>vdim_correction`] for more details.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/api.jl#L16-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.single_double_layer_potential-Tuple{}" href="#Inti.single_double_layer_potential-Tuple{}"><code>Inti.single_double_layer_potential</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">single_double_layer_potential(; op, source)</code></pre><p>Return the single- and double-layer potentials for <code>op</code> as <a href="#Inti.IntegralPotential"><code>IntegralPotential</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/api.jl#L209-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.singularity_order-Tuple{Any}" href="#Inti.singularity_order-Tuple{Any}"><code>Inti.singularity_order</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">singularity_order(K)</code></pre><p>Given a kernel <code>K</code> with signature <code>K(target,source)::T</code>, return the order of the singularity of <code>K</code> at <code>target = source</code>. Order <code>n</code> means that <code>K(x,y) ‚àº (x - y)^n</code> as <code>x -&gt; y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/kernels.jl#L16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.skeleton-Tuple{Inti.Domain}" href="#Inti.skeleton-Tuple{Inti.Domain}"><code>Inti.skeleton</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">skeleton(Œ©::Domain)</code></pre><p>Return all the boundaries of the domain, i.e. the domain&#39;s skeleton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/domain.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.stack_weakdeps_env!-Tuple{}" href="#Inti.stack_weakdeps_env!-Tuple{}"><code>Inti.stack_weakdeps_env!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stack_weakdeps_env!(; verbose = false, update = false)</code></pre><p>Push to the load stack an environment providing the weak dependencies of Inti.jl. This allows benefiting from additional functionalities of Inti.jl which are powered by weak dependencies without having to manually install them in your environment.</p><p>Set <code>update=true</code> if you want to update the <code>weakdeps</code> environment.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Calling this function can take quite some time, especially the first time around, if packages have to be installed or precompiled. Run in <code>verbose</code> mode to see what is happening.</p></div></div><p><strong>Examples:</strong></p><pre><code class="language-example hljs">Inti.stack_weakdeps_env!()
using HMatrices</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L278-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.standard_basis_vector-Union{Tuple{N}, Tuple{Any, Val{N}}} where N" href="#Inti.standard_basis_vector-Union{Tuple{N}, Tuple{Any, Val{N}}} where N"><code>Inti.standard_basis_vector</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">standard_basis_vector(k, ::Val{N})</code></pre><p>Create an <code>SVector</code> of length N with a 1 in the kth position and zeros elsewhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.svector-Union{Tuple{F}, Tuple{F, Any}} where F" href="#Inti.svector-Union{Tuple{F}, Tuple{F, Any}} where F"><code>Inti.svector</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svector(f,n)</code></pre><p>Create an <code>SVector</code> of length n, computing each element as f(i), where i is the index of the element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.torus-Tuple{}" href="#Inti.torus-Tuple{}"><code>Inti.torus</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">torus(; r, R, translation, rotation, scaling, labels)</code></pre><p>Create a torus entity in 3D, and apply optional transformations. Returns the key. The parameters <code>r</code> and <code>R</code> are the inner and outer radii of the torus.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/simpleshapes.jl#L91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.uniform_points_circle-Tuple{Any, Any, Any}" href="#Inti.uniform_points_circle-Tuple{Any, Any, Any}"><code>Inti.uniform_points_circle</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uniform_points_circle(N,r,c)</code></pre><p>Return <code>N</code> points uniformly distributed on a circle of radius <code>r</code> centered at <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/utils.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.vdim_correction-Union{Tuple{SHIFT}, Tuple{Any, Any, Inti.Quadrature, Inti.Quadrature, Any, Any, Any}} where SHIFT" href="#Inti.vdim_correction-Union{Tuple{SHIFT}, Tuple{Any, Any, Inti.Quadrature, Inti.Quadrature, Any, Any, Any}} where SHIFT"><code>Inti.vdim_correction</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vdim_correction(op,X,Y,Y_boundary,S,D,V; green_multiplier, kwargs...)</code></pre><p>Compute a correction to the volume potential <code>V : Y ‚Üí X</code> such that <code>V + Œ¥V</code> is a more accurate approximation of the underlying volume potential operator. The correction is computed using the (volume) density interpolation method.</p><p>This function requires a <code>op::AbstractDifferentialOperator</code>, a target set <code>X</code>, a source quadrature <code>Y</code>, a boundary quadrature <code>Y_boundary</code>, approximations <code>S : Y_boundary -&gt; X</code> and <code>D : Y_boundary -&gt; X</code> to the single- and double-layer potentials (correctly handling nearly-singular integrals), and a naive approximation of the volume potential <code>V</code>. The <code>green_multiplier</code> is a vector of the same length as <code>X</code> storing the value of <code>Œº(x)</code> for <code>x ‚àà X</code> in the Green identity (see <a href="#Inti._green_multiplier-Tuple{Symbol}"><code>_green_multiplier</code></a>).</p><p>See [<a href="../references/#anderson2024fast">10</a>] for more details on the method.</p><p><strong>Optional <code>kwargs</code>:</strong></p><ul><li><code>interpolation_order</code>: the order of the polynomial interpolation. By default, the maximum order of the quadrature rules is used.</li><li><code>maxdist</code>: distance beyond which interactions are considered sufficiently far so that no correction is needed. This is used to determine a threshold for nearly-singular corrections.</li><li><code>center</code>: the center of the basis functions. By default, the basis functions are centered at the origin.</li><li><code>shift</code>: a boolean indicating whether the basis functions should be shifted and rescaled to each element.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/vdim.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.vdim_mesh_center-Tuple{Inti.AbstractMesh}" href="#Inti.vdim_mesh_center-Tuple{Inti.AbstractMesh}"><code>Inti.vdim_mesh_center</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vdim_mesh_center(msh)</code></pre><p>Point <code>x</code> which minimizes ‚àë (x-x‚±º)¬≤/r¬≤‚±º, where x‚±º and r‚±º are the circumcenter and circumradius of the elements of <code>msh</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/vdim.jl#L275-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.vertices-Tuple{Inti.LagrangeElement}" href="#Inti.vertices-Tuple{Inti.LagrangeElement}"><code>Inti.vertices</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertices(el::LagrangeElement)</code></pre><p>Coordinates of the vertices of <code>el</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L353-L357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.vertices_idxs-Tuple{Type{&lt;:Inti.LagrangeElement{Inti.ReferenceHyperCube{1}}}}" href="#Inti.vertices_idxs-Tuple{Type{&lt;:Inti.LagrangeElement{Inti.ReferenceHyperCube{1}}}}"><code>Inti.vertices_idxs</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertices_idxs(el::LagrangeElement)</code></pre><p>The indices of the nodes in <code>el</code> that define the vertices of the element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/reference_interpolation.jl#L341-L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.volume_potential-Tuple{}" href="#Inti.volume_potential-Tuple{}"><code>Inti.volume_potential</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">volume_potential(; op, target, source::Quadrature, compression, correction)</code></pre><p>Compute the volume potential operator for a given PDE.</p><p><strong>Arguments</strong></p><ul><li><code>op</code>: The PDE (Partial Differential Equation) to solve.</li><li><code>target</code>: The target domain where the potential is computed.</li><li><code>source</code>: The source domain where the potential is generated.</li><li><code>compression</code>: The compression method to use for the potential operator.</li><li><code>correction</code>: The correction method to use for the potential operator.</li></ul><p><strong>Returns</strong></p><p>The volume potential operator <code>V</code> that represents the interaction between the target and source domains.</p><p><strong>Compression</strong></p><p>The <code>compression</code> argument is a named tuple with a <code>method</code> field followed by method-specific fields. It specifies how the dense linear operators should be compressed. The available options are:</p><ul><li><code>(method = :none, )</code>: no compression is performed, the resulting matrices are dense.</li><li><code>(method =:hmatrix, tol)</code>: the resulting operators are compressed using hierarchical matrices with an absolute tolerance <code>tol</code> (defaults to <code>1e-8</code>).</li><li><code>(method = :fmm, tol)</code>: the resulting operators are compressed using the fast multipole method with an absolute tolerance <code>tol</code> (defaults to <code>1e-8</code>).</li></ul><p><strong>Correction</strong></p><p>The <code>correction</code> argument is a named tuple with a <code>method</code> field followed by method-specific fields. It specifies how the singular and nearly-singular integrals should be computed. The available options are:</p><ul><li><code>(method = :none, )</code>: no correction is performed. This is not recommented, as the resulting approximation will be inaccurate if the source and target are not sufficiently far apart.</li><li><code>(method = :dim, maxdist, target_location)</code>: use the density interpolation method to compute the correction. <code>maxdist</code> specifies the distance between source and target points above which no correction is performed (defaults to <code>Inf</code>). <code>target_location</code> should be either <code>:inside</code>, <code>:outside</code>, or <code>:on</code>, and specifies where the <code>target</code><code>points lie relative to the to the</code>source<code>&#39;s boundary. When</code>target === source<code>,</code>target_location` is not needed.</li></ul><p><strong>Details</strong></p><p>The volume potential operator is computed by assembling the integral operator <code>V</code> using the single-layer kernel <code>G</code>. The operator <code>V</code> is then compressed using the specified compression method. If no compression is specified, the operator is returned as is. If a correction method is specified, the correction is computed and added to the compressed operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/71401fd9556ef0b36788b64436322cd6c803fe52/src/api.jl#L223-L276">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../references/">¬´ References</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Thursday 1 May 2025 08:52">Thursday 1 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Heat equation · Inti.jl</title><meta name="title" content="Heat equation · Inti.jl"/><meta property="og:title" content="Heat equation · Inti.jl"/><meta property="twitter:title" content="Heat equation · Inti.jl"/><meta name="description" content="Documentation for Inti.jl."/><meta property="og:description" content="Documentation for Inti.jl."/><meta property="twitter:description" content="Documentation for Inti.jl."/><meta property="og:url" content="https://IntegralEquations.github.io/Inti.jl/examples/heat_equation/"/><meta property="twitter:url" content="https://IntegralEquations.github.io/Inti.jl/examples/heat_equation/"/><link rel="canonical" href="https://IntegralEquations.github.io/Inti.jl/examples/heat_equation/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Inti.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/getting_started/">Getting started</a></li><li><a class="tocitem" href="../../tutorials/geo_and_meshes/">Geometry and meshes</a></li><li><a class="tocitem" href="../../tutorials/integral_operators/">Integral operators</a></li><li><a class="tocitem" href="../../tutorials/layer_potentials/">Layer potentials</a></li><li><a class="tocitem" href="../../tutorials/compression_methods/">Compression methods</a></li><li><a class="tocitem" href="../../tutorials/correction_methods/">Correction methods</a></li><li><a class="tocitem" href="../../tutorials/solvers/">Linear solvers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../pluto-examples/toy_example/">Toy example</a></li><li><a class="tocitem" href="../../pluto-examples/helmholtz_scattering/">Helmholtz scattering</a></li><li><a class="tocitem" href="../../pluto-examples/poisson/">Poisson problem</a></li><li class="is-active"><a class="tocitem" href>Heat equation</a><ul class="internal"><li><a class="tocitem" href="#Problem-description"><span>Problem description</span></a></li><li><a class="tocitem" href="#Solution-approach"><span>Solution approach</span></a></li><li><a class="tocitem" href="#Spatial-discretization"><span>Spatial discretization</span></a></li><li><a class="tocitem" href="#Constructing-integral-operators"><span>Constructing integral operators</span></a></li><li><a class="tocitem" href="#Time-evolution"><span>Time evolution</span></a></li><li><a class="tocitem" href="#Summary-and-extensions"><span>Summary and extensions</span></a></li></ul></li><li><a class="tocitem" href="../stokes_drag/">Stokes drag</a></li><li><a class="tocitem" href="../crack_elasticity/">Elastic crack</a></li><li><a class="tocitem" href="../pep/">Plasmonic eigenvalues</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../docstrings/">Docstrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Heat equation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Heat equation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl/blob/main/docs/src/examples/heat_equation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Heat-equation"><a class="docs-heading-anchor" href="#Heat-equation">Heat equation</a><a id="Heat-equation-1"></a><a class="docs-heading-anchor-permalink" href="#Heat-equation" title="Permalink"></a></h1><div class="admonition is-info" id="Important-points-covered-in-this-example-aacd979f015e3acd"><header class="admonition-header">Important points covered in this example<a class="admonition-anchor" href="#Important-points-covered-in-this-example-aacd979f015e3acd" title="Permalink"></a></header><div class="admonition-body"><ul><li>Using Rothe&#39;s method to solve a time-dependent PDE</li><li>Combining volume and boundary integral equations for efficient solution</li><li>Handling complex domains with holes</li><li>Animating the solution evolution using <code>Makie</code></li></ul></div></div><h2 id="Problem-description"><a class="docs-heading-anchor" href="#Problem-description">Problem description</a><a id="Problem-description-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-description" title="Permalink"></a></h2><p>In this example, we&#39;ll solve the heat equation in a domain <span>$\Omega$</span> with Dirichlet boundary conditions on <span>$\Gamma := \partial \Omega$</span>.</p><p class="math-container">\[\begin{align*}
    \partial_t u(x,t) - \Delta u(x,t)  &amp;= f(x,t,u), \quad &amp;&amp; x \in \Omega, \quad t \in [0,T]\\
    u(x,t) &amp;= g(x,t) \quad &amp;&amp; x \in \Gamma, \quad t \in [0,T]\\
    u(x, t = 0) &amp;= u_0(x) \quad &amp;&amp; x \in \Omega\\ \tag{Heat equation}
\end{align*}\]</p><p>where:</p><ul><li><span>$u(x,t)$</span> represents temperature at position <span>$x$</span> and time <span>$t$</span></li><li><span>$f(x,t,u)$</span> is a source/sink term (can depend on the solution itself for nonlinear problems)</li><li><span>$g(x,t)$</span> specifies the Dirichlet boundary condition (prescribed temperature at the boundary)</li><li><span>$u_0(x)$</span> is the initial temperature distribution</li></ul><p>The heat equation is a parabolic PDE, and we will solve it using Rothe&#39;s method (also known as the method of lines transpose). This approach first discretizes in time, reducing the problem to a sequence of elliptic PDEs which we then solve using integral equations. This contrasts with the method of lines, which discretizes in space first and solves the resulting ODEs.</p><h2 id="Solution-approach"><a class="docs-heading-anchor" href="#Solution-approach">Solution approach</a><a id="Solution-approach-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-approach" title="Permalink"></a></h2><h3 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h3><p>Our solution strategy follows these key steps:</p><ol><li><strong>Time discretization</strong>: Apply backward Euler to convert the time-dependent PDE into a sequence of Yukawa equations</li><li><strong>Solution splitting</strong>: Decompose the solution into particular and homogeneous parts</li><li><strong>Integral formulation</strong>: Use volume potentials for the particular solution and boundary integrals for the homogeneous solution</li><li><strong>Discretization</strong>: Apply numerical quadrature to the integral operators</li><li><strong>Time stepping</strong>: Solve the sequence of spatial problems to march forward in time</li></ol><h3 id="Time-discretization-(Rothe&#39;s-method)"><a class="docs-heading-anchor" href="#Time-discretization-(Rothe&#39;s-method)">Time discretization (Rothe&#39;s method)</a><a id="Time-discretization-(Rothe&#39;s-method)-1"></a><a class="docs-heading-anchor-permalink" href="#Time-discretization-(Rothe&#39;s-method)" title="Permalink"></a></h3><p>Following these <a href="https://perso.univ-rennes1.fr/martin.costabel/publis/Co_ECM.pdf">lecture notes</a> by Costabel, we first discretize time using an implicit scheme (backward Euler for simplicity):</p><p class="math-container">\[\begin{align*}
u^{n} - \tau\Delta u^n  &amp;= \tau f^{n-1} + u^{n-1}, \quad &amp;&amp; \text{in } \Omega\\
u^n &amp;= g^n, \quad &amp;&amp; \text{on } \partial\Omega
\end{align*}\]</p><p>where <span>$\tau$</span> is the time step and an <span>$n$</span> superscript denotes the function value at time <span>$t = n\tau$</span> (e.g. <span>$u^n(x) = u(x, t = n\tau)$</span>). </p><h3 id="Converting-to-a-Yukawa-equation"><a class="docs-heading-anchor" href="#Converting-to-a-Yukawa-equation">Converting to a Yukawa equation</a><a id="Converting-to-a-Yukawa-equation-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-to-a-Yukawa-equation" title="Permalink"></a></h3><p>Dividing both sides by <span>$\tau$</span> we get a Yukawa (or modified Helmholtz) equation for the function <span>$u^n$</span>:</p><p class="math-container">\[\begin{align*}
-\Delta u^n + \frac{1}{\tau}u^n  &amp;= f^{n-1} + \frac{u^{n-1}}{\tau}, \quad &amp;&amp; \text{in } \Omega\\
u^n &amp;= g^n, \quad &amp;&amp; \text{on } \partial\Omega \tag{Yukawa equation}
\end{align*}\]</p><h3 id="Solution-decomposition"><a class="docs-heading-anchor" href="#Solution-decomposition">Solution decomposition</a><a id="Solution-decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-decomposition" title="Permalink"></a></h3><p>This is now amenable to an integral equation formulation. To do so we split the solution into a particular solution <span>$u^n_p$</span> and a homogeneous solution <span>$u^n_h$</span>:</p><p class="math-container">\[u^n = u^n_p + u^n_h\]</p><h4 id="The-particular-solution"><a class="docs-heading-anchor" href="#The-particular-solution">The particular solution</a><a id="The-particular-solution-1"></a><a class="docs-heading-anchor-permalink" href="#The-particular-solution" title="Permalink"></a></h4><p>The function <span>$u^n_p$</span> is given as a volume potential:</p><p class="math-container">\[u^n_p(x) = \int_{\Omega} G(x, y) \left( f(y,t^{n-1}, u^{n-1}) + \frac{u^{n-1}(y)}{\tau} \right) \; \mathrm{d}\Omega(y) \tag{Particular solution}\]</p><p>where <span>$G(x,y)$</span> is the fundamental solution of the Yukawa operator.</p><h4 id="The-homogeneous-solution"><a class="docs-heading-anchor" href="#The-homogeneous-solution">The homogeneous solution</a><a id="The-homogeneous-solution-1"></a><a class="docs-heading-anchor-permalink" href="#The-homogeneous-solution" title="Permalink"></a></h4><p>As for the homogeneous solution <span>$u^n_h$</span>, it satisfies:</p><p class="math-container">\[\begin{align*}
-\Delta u^n_h + \frac{1}{\tau} u^n_h &amp;= 0,  \quad &amp;&amp;\text{in } \quad \Omega, \\
u^n_h &amp;= g^n - u^n_p,  \quad &amp;&amp;\text{on } \; \partial\Omega, \tag{Homogenous problem}
\end{align*}\]</p><h3 id="Boundary-integral-formulation"><a class="docs-heading-anchor" href="#Boundary-integral-formulation">Boundary integral formulation</a><a id="Boundary-integral-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-integral-formulation" title="Permalink"></a></h3><p>We&#39;ll use an indirect double-layer formulation, where we seek <span>$u^n_h$</span> in the form:</p><p class="math-container">\[u^n_h(r) = \mathcal{D}[\sigma](r), \quad r \in \Omega,\]</p><p>with <span>$\mathcal{D}$</span> the double-layer potential associated with the Yukawa equation, and <span>$\sigma$</span> the unknown density. Taking the interior Dirichlet trace (for a smooth boundary) yields:</p><p class="math-container">\[\frac{-\sigma(x)}{2} + D[\sigma](x) = g^n(x) - u^n_p(x), \quad x \in \partial\Omega, \tag{BIE}\]</p><p>This boundary integral equation (BIE) allows us to solve for the density <span>$\sigma$</span> on the boundary.</p><h3 id="Summary-of-the-solution-strategy"><a class="docs-heading-anchor" href="#Summary-of-the-solution-strategy">Summary of the solution strategy</a><a id="Summary-of-the-solution-strategy-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-of-the-solution-strategy" title="Permalink"></a></h3><p>The steps outlined above reduce the time-dependent heat equation to a sequence of forced Yukawa equations which can be solved using the same techniques as in the <a href="../../pluto-examples/poisson/#Poisson-Problem">Poisson problem tutorial</a>. For each time step:</p><ol><li>Use the volume potential to compute the particular solution <span>$u^n_p$</span></li><li>Solve the BIE to find the density <span>$\sigma$</span></li><li>Apply the double-layer potential to compute the homogeneous solution <span>$u^n_h$</span></li><li>Combine the solutions: <span>$u^n = u^n_p + u^n_h$</span></li></ol><h2 id="Spatial-discretization"><a class="docs-heading-anchor" href="#Spatial-discretization">Spatial discretization</a><a id="Spatial-discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-discretization" title="Permalink"></a></h2><p>We now proceed to discretize the inhomogeneous Yukawa equation. We will use Gmsh to create a disk with a few holes in it, representing a domain with inclusions where heat can flow around but not through.</p><h3 id="Creating-the-mesh"><a class="docs-heading-anchor" href="#Creating-the-mesh">Creating the mesh</a><a id="Creating-the-mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-the-mesh" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Inti
using Gmsh
function create_mesh(meshsize, meshorder=2)
	gmsh.initialize()
	gmsh.option.setNumber(&quot;General.Verbosity&quot;, 2)
	gmsh.option.setNumber(&quot;Mesh.MeshSizeMax&quot;, meshsize)
	disk = gmsh.model.occ.addDisk(0, 0, 0, 1, 1)
	ell1 = gmsh.model.occ.addDisk(.5, 0, 0, 0.2, 0.1)
	ell2 = gmsh.model.occ.addDisk(-.5, 0.3, 0, 0.3, 0.2)
	gmsh.model.occ.rotate([(2,ell2)], 0, 0, 0, 0, 0, 1, -π/3)
	ell3 = gmsh.model.occ.addDisk(-.5, -0.5, 0, 0.2, 0.15)
	gmsh.model.occ.rotate([(2,ell3)], 0, 0, 0, 0, 0, 1, π/3)
	gmsh.model.occ.cut([(2,disk)], [(2,ell1), (2,ell2), (2,ell3)])
	gmsh.model.occ.synchronize()
	gmsh.model.mesh.generate(2)
	gmsh.model.mesh.setOrder(meshorder)
	msh = Inti.import_mesh(; dim = 2)
	gmsh.finalize()
	return msh
end
meshsize = 0.1
meshorder = 2
tau       = 2π / 40
msh = create_mesh(meshsize, meshorder)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Inti.Mesh{2, Float64} containing:
	 101 elements of type Inti.LagrangeElement{Inti.ReferenceHyperCube{1}, 3, StaticArraysCore.SVector{2, Float64}}
	 743 elements of type Inti.LagrangeElement{Inti.ReferenceSimplex{2}, 6, StaticArraysCore.SVector{2, Float64}}
	 4 elements of type StaticArraysCore.SVector{2, Float64}</code></pre><div class="admonition is-info" id="Mesh-structure-bfda07f4cf0953f8"><header class="admonition-header">Mesh structure<a class="admonition-anchor" href="#Mesh-structure-bfda07f4cf0953f8" title="Permalink"></a></header><div class="admonition-body"><p>Note that <code>msh</code> contains <strong>all</strong> the elements of the generated mesh, including the boundary segments and any point entities that Gmsh may have created. To properly index into our mesh elements, we must use <code>Domain</code>s, which are simply a collection of geometric entities.</p></div></div><h3 id="Extracting-domain-and-boundary"><a class="docs-heading-anchor" href="#Extracting-domain-and-boundary">Extracting domain and boundary</a><a id="Extracting-domain-and-boundary-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-domain-and-boundary" title="Permalink"></a></h3><p>Since we will need to work with <span>$\Omega$</span> and <span>$\Gamma$</span> separately, we will extract those domains and their corresponding (sub)meshes:</p><pre><code class="language-julia hljs">Ω = Inti.Domain(e -&gt; Inti.geometric_dimension(e) == 2, msh)
Γ = Inti.boundary(Ω)
Ω_msh = @views msh[Ω]
Γ_msh = @views msh[Γ]</code></pre><h3 id="Visualizing-the-geometry"><a class="docs-heading-anchor" href="#Visualizing-the-geometry">Visualizing the geometry</a><a id="Visualizing-the-geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizing-the-geometry" title="Permalink"></a></h3><p>Let&#39;s visualize the mesh to confirm our domain setup. The red outline shows the boundary <span>$\Gamma$</span>, which consists of both the outer boundary and the boundaries of the interior holes:</p><pre><code class="language-julia hljs">using Meshes
using GLMakie
fig = viz(
    Ω_msh;
    segmentsize = 1,
    showsegments = true,
    axis = (aspect = DataAspect(),),
    figure = (; size = (500, 400)),
)
viz!(Γ_msh; color = :red, segmentsize = 4)</code></pre><img src="b5902c8c.png" alt="Example block output"/><h3 id="Setting-up-numerical-quadrature"><a class="docs-heading-anchor" href="#Setting-up-numerical-quadrature">Setting up numerical quadrature</a><a id="Setting-up-numerical-quadrature-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-numerical-quadrature" title="Permalink"></a></h3><p>Now we create quadrature rules for both <span>$\Omega$</span> and <span>$\Gamma$</span>, which will be used to  accurately integrate our kernel functions over the domain and boundary:</p><pre><code class="language-julia hljs">Ω_quad = Inti.Quadrature(Ω_msh; qorder = 3)
Γ_quad = Inti.Quadrature(Γ_msh; qorder = 3)</code></pre><h2 id="Constructing-integral-operators"><a class="docs-heading-anchor" href="#Constructing-integral-operators">Constructing integral operators</a><a id="Constructing-integral-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-integral-operators" title="Permalink"></a></h2><h3 id="The-Yukawa-operator"><a class="docs-heading-anchor" href="#The-Yukawa-operator">The Yukawa operator</a><a id="The-Yukawa-operator-1"></a><a class="docs-heading-anchor-permalink" href="#The-Yukawa-operator" title="Permalink"></a></h3><p>First, we define the Yukawa operator with parameter <span>$λ = 1/\sqrt{\tau}$</span>, which arises from our time discretization:</p><pre><code class="language-julia hljs">λ = 1/sqrt(tau)
op = Inti.Yukawa(; dim = 2, λ)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Yukawa operator in 2 dimensions: -Δu + λ²u</code></pre><h3 id="Creating-the-integral-operators"><a class="docs-heading-anchor" href="#Creating-the-integral-operators">Creating the integral operators</a><a id="Creating-the-integral-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-the-integral-operators" title="Permalink"></a></h3><p>Next, we construct four key integral operators needed to solve our problem:</p><table><tr><th style="text-align: right">Operator</th><th style="text-align: right">Type</th><th style="text-align: right">Purpose</th></tr><tr><td style="text-align: right"><span>$\mathcal{V}_{\Omega \to \Omega}$</span></td><td style="text-align: right">Volume potential</td><td style="text-align: right">Computes the particular solution in the domain</td></tr><tr><td style="text-align: right"><span>$\mathcal{V}_{\Omega \to \Gamma}$</span></td><td style="text-align: right">Volume potential</td><td style="text-align: right">Computes the trace of the particular solution on the boundary</td></tr><tr><td style="text-align: right"><span>$\mathcal{D}_{\Gamma \to \Gamma}$</span></td><td style="text-align: right">Double-layer operator</td><td style="text-align: right">Solves for the density on the boundary</td></tr><tr><td style="text-align: right"><span>$\mathcal{D}_{\Gamma \to \Omega}$</span></td><td style="text-align: right">Double-layer potential</td><td style="text-align: right">Computes the homogeneous solution in the domain</td></tr></table><h3 id="Setting-operator-parameters"><a class="docs-heading-anchor" href="#Setting-operator-parameters">Setting operator parameters</a><a id="Setting-operator-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-operator-parameters" title="Permalink"></a></h3><p>For each operator, we specify compression and correction parameters:</p><pre><code class="language-julia hljs"># using HMatrices
# compression = (method = :hmatrix, atol = 1e-8)
correction = (
    method = :adaptive,
    threads = true,
    maxdist = 3 * meshsize,
    atol = 1e-6,
    maxsubdiv = 10_000,
)
compression = (method = :none,)</code></pre><div class="admonition is-success" id="Performance-optimization-80ded5607bd4ed4f"><header class="admonition-header">Performance optimization<a class="admonition-anchor" href="#Performance-optimization-80ded5607bd4ed4f" title="Permalink"></a></header><div class="admonition-body"><p>Instead of using a dense matrix representation of the integral operators, you would typically enable HMatrix compression for larger problems. The commented code shows how to configure it with appropriate tolerance parameters.</p></div></div><h3 id="Building-the-operators"><a class="docs-heading-anchor" href="#Building-the-operators">Building the operators</a><a id="Building-the-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Building-the-operators" title="Permalink"></a></h3><p>Let&#39;s create our operators:</p><pre><code class="language-julia hljs">V_d2b = Inti.volume_potential(;
	op,
	target = Γ_quad,
	source = Ω_quad,
	compression,
	correction,
)
_, D_b2b = Inti.single_double_layer(;
	op,
	target = Γ_quad,
	source = Γ_quad,
	compression,
	correction
)
V_d2d = Inti.volume_potential(;
	op,
	target = Ω_quad,
	source = Ω_quad,
	compression,
	correction,
)
_, D_b2d = Inti.single_double_layer(;
	op,
	target = Ω_quad,
	source = Γ_quad,
	compression,
	correction
)</code></pre><h2 id="Time-evolution"><a class="docs-heading-anchor" href="#Time-evolution">Time evolution</a><a id="Time-evolution-1"></a><a class="docs-heading-anchor-permalink" href="#Time-evolution" title="Permalink"></a></h2><h3 id="Factoring-the-boundary-integral-operator"><a class="docs-heading-anchor" href="#Factoring-the-boundary-integral-operator">Factoring the boundary integral operator</a><a id="Factoring-the-boundary-integral-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Factoring-the-boundary-integral-operator" title="Permalink"></a></h3><p>Since our domain remains fixed throughout the simulation, we can factor the boundary integral operator to improve computational efficiency:</p><pre><code class="language-julia hljs">using LinearAlgebra
L = -I/2 + D_b2b
F = lu(L)</code></pre><h3 id="Verification-with-a-manufactured-solution"><a class="docs-heading-anchor" href="#Verification-with-a-manufactured-solution">Verification with a manufactured solution</a><a id="Verification-with-a-manufactured-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Verification-with-a-manufactured-solution" title="Permalink"></a></h3><p>To verify our implementation, we&#39;ll first use the method of manufactured solutions. We choose a  known analytical solution <span>$u_e(x,t)$</span> and derive the corresponding source term and boundary conditions:</p><pre><code class="language-julia hljs">uₑ = (x, t) -&gt; sin(x[1]) * sin(x[2]) * cos(t)
f  = (x, t) -&gt; 2 * uₑ(x, t) - sin(t) * sin(x[1]) * sin(x[2])
g = (x, t) -&gt; uₑ(x, t) # boundary values</code></pre><h3 id="Time-stepping-algorithm"><a class="docs-heading-anchor" href="#Time-stepping-algorithm">Time-stepping algorithm</a><a id="Time-stepping-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Time-stepping-algorithm" title="Permalink"></a></h3><p>Now we perform the time-stepping loop for one full period (<span>$T = 2\pi$</span>):</p><pre><code class="language-julia hljs">nsteps = round(Int, 2π/tau)
uⁿ⁻¹ = map(q -&gt; uₑ(q.coords, 0), Ω_quad) # initial condition
uⁿ   = zero(uⁿ⁻¹)
t    = Ref(0.0)
for n in 1:nsteps
	# 1. Evaluate source term at current time
	fⁿ  = map(q -&gt; f(q.coords, t[] + tau), Ω_quad)

	# 2. Compute the particular solution
	uₚⁿ = V_d2d*(fⁿ + uⁿ⁻¹/tau)

	# 3. Evaluate boundary conditions
	gⁿ  = map(q -&gt; g(q.coords, t[] + tau), Γ_quad)

	# 4. Solve BIE and compute homogeneous solution
	uₕⁿ = D_b2d * (F \ (gⁿ - V_d2b * (fⁿ + uⁿ⁻¹ / tau)))

	# 5. Combine solutions and update for next time step
	uⁿ .= uₚⁿ + uₕⁿ
	uⁿ⁻¹ .= uⁿ
	t[] += tau
end</code></pre><p>Let&#39;s check the accuracy of our solution by comparing with the exact solution:</p><pre><code class="language-julia hljs">uref = map(q -&gt; uₑ(q.coords, t[]), Ω_quad) # reference solution
er = norm(uⁿ - uref, Inf) / norm(uref, Inf)
er</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0018429871071135823</code></pre><p>A relative error of this magnitude confirms that our implementation is working correctly.</p><div class="admonition is-info" id="Convergence-ddb7819db3bf5ca0"><header class="admonition-header">Convergence<a class="admonition-anchor" href="#Convergence-ddb7819db3bf5ca0" title="Permalink"></a></header><div class="admonition-body"><p>Testing that the error is &quot;small&quot; is just a basic verification. For rigorous validation, we should analyze the convergence order as we refine both spatial and temporal discretizations. For this example, the error is primarily determined by the first-order backward Euler scheme. Try halving the time step and observe how the error reduces approximately by a factor of 2!</p></div></div><p>Now let&#39;s explore a more interesting scenario: heat flow in a domain with inclusions. We&#39;ll set the  temperature to zero at the outer boundary and apply a time-varying temperature of <span>$\sin^2(t)$</span> at  the boundaries of the inclusions:</p><pre><code class="language-julia hljs">f  = (x, t) -&gt; 0.0
g  = (x, t) -&gt; norm(x) &gt; 0.9 ? 0.0 : (sin(t))^2
u⁰ = zeros(length(Ω_quad))</code></pre><p>This physical setup models a scenario where the outer surface is kept at a constant cold temperature, while the inclusions have a periodically varying temperature - similar to heat sources that turn on and off.</p><h3 id="Visualizing-the-temperature-evolution"><a class="docs-heading-anchor" href="#Visualizing-the-temperature-evolution">Visualizing the temperature evolution</a><a id="Visualizing-the-temperature-evolution-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizing-the-temperature-evolution" title="Permalink"></a></h3><p>Here&#39;s the animation of the temperature distribution evolving over time:</p><pre><code class="language-julia hljs">fig = Figure()
ax = Axis(fig[1, 1]; aspect = DataAspect())
colorrange = (0.0, 1.0)
record(fig, joinpath(@__DIR__,&quot;heat.gif&quot;)) do io
	nsteps = round(Int, 2π/tau)
	uⁿ⁻¹ = u⁰
	uⁿ   = zero(uⁿ⁻¹)
	t    = 0.0
	for n in 1:nsteps
		# Convert quadrature values to node values for visualization
		u_nodes = Inti.quadrature_to_node_vals(Ω_quad, uⁿ⁻¹)

		# Setup visualization for current frame
		ax.title = &quot;Temperature at t = $(round(t, digits = 2))&quot;
		viz!(Ω_quad.mesh; showsegments = true, color = u_nodes, colorrange)
		viz!(Γ_msh; color = :black, segmentsize = 4)
		Colorbar(fig[1, 2]; colorrange = colorrange, label = &quot;Temperature&quot;)

		# Record current frame
		recordframe!(io)

		# Solve for next time step
		fⁿ  = map(q -&gt; f(q.coords, t + tau), Ω_quad)
		uₚⁿ = V_d2d*(fⁿ + uⁿ⁻¹/tau)
		gⁿ  = map(q -&gt; g(q.coords, t + tau), Γ_quad)
		uₕⁿ = D_b2d * (F \ (gⁿ - V_d2b * (fⁿ + uⁿ⁻¹ / tau)))
		uⁿ = uₚⁿ + uₕⁿ
		uⁿ⁻¹ = uⁿ
		t += tau
	end
end</code></pre><p><img src="../heat.gif" alt="Heat equation"/></p><h2 id="Summary-and-extensions"><a class="docs-heading-anchor" href="#Summary-and-extensions">Summary and extensions</a><a id="Summary-and-extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-and-extensions" title="Permalink"></a></h2><p>We&#39;ve demonstrated how to solve the heat equation using Rothe&#39;s method combined with boundary integral equations. This approach effectively handles complex geometries and provides accurate solutions with reasonable computational cost.</p><div class="admonition is-success" id="Going-further-f9c5744435166c7a"><header class="admonition-header">Going further<a class="admonition-anchor" href="#Going-further-f9c5744435166c7a" title="Permalink"></a></header><div class="admonition-body"><p>To extend this example, consider:</p><ul><li>Implementing a second-order time scheme (e.g., Crank-Nicolson) for improved accuracy</li><li>Utilizing hierarchical matrix compression (<code>HMatrix</code>) for larger domains</li><li>Exploring more complex geometries or physical scenarios</li><li>Adding nonlinear terms to model more complex physical phenomena</li></ul></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../pluto-examples/poisson/">« Poisson problem</a><a class="docs-footer-nextpage" href="../stokes_drag/">Stokes drag »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 12 July 2025 00:37">Saturday 12 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

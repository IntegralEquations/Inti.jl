<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Inti.jl</title><meta name="title" content="Docstrings · Inti.jl"/><meta property="og:title" content="Docstrings · Inti.jl"/><meta property="twitter:title" content="Docstrings · Inti.jl"/><meta name="description" content="Documentation for Inti.jl."/><meta property="og:description" content="Documentation for Inti.jl."/><meta property="twitter:description" content="Documentation for Inti.jl."/><meta property="og:url" content="https://IntegralEquations.github.io/Inti.jl/docstrings/"/><meta property="twitter:url" content="https://IntegralEquations.github.io/Inti.jl/docstrings/"/><link rel="canonical" href="https://IntegralEquations.github.io/Inti.jl/docstrings/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Inti.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/getting_started/">Getting started</a></li><li><a class="tocitem" href="../tutorials/geo_and_meshes/">Geometry and meshes</a></li><li><a class="tocitem" href="../tutorials/integral_operators/">Boundary integral operators</a></li><li><a class="tocitem" href="../tutorials/layer_potentials/">Layer potentials</a></li><li><a class="tocitem" href="../tutorials/compression_methods/">Compression methods</a></li><li><a class="tocitem" href="../tutorials/correction_methods/">Correction methods</a></li><li><a class="tocitem" href="../tutorials/solvers/">Linear solvers</a></li></ul></li><li><span class="tocitem">Notebooks</span><ul><li><a class="tocitem" href="../pluto-examples/toy_example/">Toy example</a></li><li><a class="tocitem" href="../pluto-examples/helmholtz_scattering/">Helmholtz scattering</a></li><li><a class="tocitem" href="../pluto-examples/poisson/">Poisson problem</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li><li class="is-active"><a class="tocitem" href>Docstrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Docstrings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Docstrings</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl/blob/main/docs/src/docstrings.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Inti" href="#Inti.Inti"><code>Inti.Inti</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">module Inti</code></pre><p>Library for solving integral equations using Nyström methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/Inti.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.COMPRESSION_METHODS" href="#Inti.COMPRESSION_METHODS"><code>Inti.COMPRESSION_METHODS</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const COMPRESSION_METHODS = [:none, :hmatrix, :fmm]</code></pre><p>Available compression methods for the dense linear operators in <a href="../#Inti"><code>Inti</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/api.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.CORRECTION_METHODS" href="#Inti.CORRECTION_METHODS"><code>Inti.CORRECTION_METHODS</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const CORRECTION_METHODS = [:none, :dim, :hcubature]</code></pre><p>Available correction methods for the singular and nearly-singular integrals in <a href="../#Inti"><code>Inti</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/api.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ENTITIES" href="#Inti.ENTITIES"><code>Inti.ENTITIES</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const ENTITIES</code></pre><p>Dictionary mapping <a href="#Inti.EntityKey"><code>EntityKey</code></a> to <a href="#Inti.GeometricEntity"><code>GeometricEntity</code></a>. Contains all entities created in a given session.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/entities.jl#L288-L293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.SAME_POINT_TOLERANCE" href="#Inti.SAME_POINT_TOLERANCE"><code>Inti.SAME_POINT_TOLERANCE</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SAME_POINTS_TOLERANCE</code></pre><p>Two points <code>x</code> and <code>y</code> are considerd the same if <code>norm(x-y) ≤ SAME_POINT_TOLERANCE</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L266-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.AbstractDifferentialOperator" href="#Inti.AbstractDifferentialOperator"><code>Inti.AbstractDifferentialOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractDifferentialOperator{N}</code></pre><p>A partial differential operator in dimension <code>N</code>.</p><p><code>AbstractDifferentialOperator</code> types are used to define <a href="#Inti.AbstractKernel"><code>AbstractKernel</code>s</a> related to fundamental solutions of differential operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/kernels.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.AbstractKernel" href="#Inti.AbstractKernel"><code>Inti.AbstractKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractKernel{T}</code></pre><p>A kernel functions <code>K</code> with the signature <code>K(target,source)::T</code>.</p><p>See also: <a href="#Inti.SingleLayerKernel"><code>SingleLayerKernel</code></a>, <a href="#Inti.DoubleLayerKernel"><code>DoubleLayerKernel</code></a>, <a href="#Inti.AdjointDoubleLayerKernel"><code>AdjointDoubleLayerKernel</code></a>, <a href="#Inti.HyperSingularKernel"><code>HyperSingularKernel</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/kernels.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.AbstractMesh" href="#Inti.AbstractMesh"><code>Inti.AbstractMesh</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractMesh{N,T}</code></pre><p>An abstract mesh structure in dimension <code>N</code> with primite data of type <code>T</code> (e.g. <code>Float64</code> for double precision representation).</p><p>Concrete subtypes of <code>AbstractMesh</code> should implement <a href="#Inti.ElementIterator"><code>ElementIterator</code></a> for accessing the mesh elements.</p><p>See also: <a href="#Inti.Mesh"><code>Mesh</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/mesh.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.AdjointDoubleLayerKernel" href="#Inti.AdjointDoubleLayerKernel"><code>Inti.AdjointDoubleLayerKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct AdjointDoubleLayerKernel{T,Op} &lt;: AbstractKernel{T}</code></pre><p>Given an operator <code>Op</code>, construct its free-space adjoint double-layer kernel. This corresponds to the <code>transpose(γ₁,ₓ[G])</code>, where <code>G</code> is the <a href="#Inti.SingleLayerKernel"><code>SingleLayerKernel</code></a>. For operators such as <a href="#Inti.Laplace-Tuple{}"><code>Laplace</code></a> or <a href="#Inti.Helmholtz-Tuple{}"><code>Helmholtz</code></a>, this is simply the normal derivative of the fundamental solution respect to the target variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/kernels.jl#L58-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.BlockArray" href="#Inti.BlockArray"><code>Inti.BlockArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct BlockArray{T&lt;:StaticArray,N,S} &lt;: AbstractMatrix{T,N}</code></pre><p>A struct which behaves like an  <code>Array{T,N}</code>, but with the underlying <code>data</code> stored as a <code>Matrix{S}</code>, where <code>S::Number = eltype(T)</code> is the scalar type associated with <code>T</code>. This allows for the use of <code>blas</code> routines under-the-hood, while providing a convenient interface for handling matrices over <code>StaticArray</code>s.</p><pre><code class="language-julia hljs">using StaticArrays
T = SMatrix{2,2,Int,4}
B = Inti.BlockArray{T}([i*j for i in 1:4, j in 1:4])

# output

2×2 Inti.BlockArray{SMatrix{2, 2, Int64, 4}, 2, Int64}:
 [1 2; 2 4]  [3 4; 6 8]
 [3 6; 4 8]  [9 12; 12 16]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/blockarray.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.DimParameters" href="#Inti.DimParameters"><code>Inti.DimParameters</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DimParameters</code></pre><p>Parameters associated with the density interpolation method used in <a href="#Inti.bdim_correction-Tuple{Any, Any, Inti.Quadrature, Any, Any}"><code>bdim_correction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/bdim.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Domain" href="#Inti.Domain"><code>Inti.Domain</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Domain</code></pre><p>Representation of a geometrical domain formed by a set of entities with the same geometric dimension. For basic set operations on domains are supported (union, intersection, difference, etc), and they all return a new <code>Domain</code> object.</p><p>Calling <code>keys(Ω)</code> returns the set of <a href="#Inti.EntityKey"><code>EntityKey</code></a>s that make up the domain; given a key, the underlying entities can be accessed with <a href="#Inti.global_get_entity-Tuple{Inti.EntityKey}"><code>global_get_entity(key)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/domain.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Domain-Tuple{Function, Any}" href="#Inti.Domain-Tuple{Function, Any}"><code>Inti.Domain</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Domain([f::Function,] keys)</code></pre><p>Create a domain from a set of <a href="#Inti.EntityKey"><code>EntityKey</code></a>s. Optionally, a filter function <code>f</code> can be passed to filter the entities.</p><p>Note that all entities in a domain must have the same geometric dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/domain.jl#L24-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Domain-Tuple{Function, Inti.AbstractMesh}" href="#Inti.Domain-Tuple{Function, Inti.AbstractMesh}"><code>Inti.Domain</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Domain(f::Function, msh::AbstractMesh)</code></pre><p>Call <code>Domain(f, ents)</code> on <code>ents = entities(msh).</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/mesh.jl#L608-L612">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.DoubleLayerKernel" href="#Inti.DoubleLayerKernel"><code>Inti.DoubleLayerKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DoubleLayerKernel{T,Op} &lt;: AbstractKernel{T}</code></pre><p>Given an operator <code>Op</code>, construct its free-space double-layer kernel. This corresponds to the <code>γ₁</code> trace of the <a href="#Inti.SingleLayerKernel"><code>SingleLayerKernel</code></a>. For operators such as <a href="#Inti.Laplace-Tuple{}"><code>Laplace</code></a> or <a href="#Inti.Helmholtz-Tuple{}"><code>Helmholtz</code></a>, this is simply the normal derivative of the fundamental solution respect to the source variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/kernels.jl#L46-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Elastostatic" href="#Inti.Elastostatic"><code>Inti.Elastostatic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Elastostatic{N,T} &lt;: AbstractDifferentialOperator{N}</code></pre><p>Elastostatic operator in <code>N</code> dimensions: -μΔu - (μ+λ)∇(∇⋅u)</p><p>Note that the displacement <span>$u$</span> is a vector of length <code>N</code> since this is a vectorial problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/kernels.jl#L461-L468">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ElementIterator" href="#Inti.ElementIterator"><code>Inti.ElementIterator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ElementIterator{E,M} &lt;: AbstractVector{E}</code></pre><p>Structure to lazily access elements of type <code>E</code> in a mesh of type <code>M</code>. This is particularly useful for <a href="#Inti.LagrangeElement"><code>LagrangeElement</code></a>s, where the information to reconstruct the element is stored in the mesh connectivity matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/mesh.jl#L380-L386">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.EmbeddedQuadrature" href="#Inti.EmbeddedQuadrature"><code>Inti.EmbeddedQuadrature</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct EmbeddedQuadrature{L,H,D} &lt;: ReferenceQuadrature{D}</code></pre><p>A quadrature rule for the reference shape <code>D</code> based on a high-order quadrature of type <code>H</code> and a low-order quadrature of type <code>L</code>. The low-order quadrature rule is <em>embedded</em> in the sense that its <code>n</code> nodes are exactly the first <code>n</code> nodes of the high-order quadrature rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L336-L343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.EntityKey" href="#Inti.EntityKey"><code>Inti.EntityKey</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EntityKey</code></pre><p>Used to represent the key of a <a href="#Inti.GeometricEntity"><code>GeometricEntity</code></a>, comprised of a <code>dim</code> and a <code>tag</code> field, where <code>dim</code> is the geometrical dimension of the entity, and <code>tag</code> is a unique integer identifying the entity.</p><p>The sign of the <code>tag</code> field is used to distinguish the orientation of the entity, and is ignored when comparing two <a href="#Inti.EntityKey"><code>EntityKey</code></a>s for equality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/entities.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Fejer" href="#Inti.Fejer"><code>Inti.Fejer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Fejer{N}</code></pre><p><code>N</code>-point Fejer&#39;s first quadrature rule for integrating a function over <code>[0,1]</code>. Exactly integrates all polynomials of degree <code>≤ N-1</code>.</p><pre><code class="language-julia hljs">using Inti

q = Inti.Fejer(;order=10)

Inti.integrate(cos,q) ≈ sin(1) - sin(0)

# output

true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L64-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Gauss" href="#Inti.Gauss"><code>Inti.Gauss</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Gauss{D,N} &lt;: ReferenceQuadrature{D}</code></pre><p>Tabulated <code>N</code>-point symmetric Gauss quadrature rule for integration over <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.GaussLegendre" href="#Inti.GaussLegendre"><code>Inti.GaussLegendre</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GaussLegendre{N,T}</code></pre><p><code>N</code>-point Gauss-Legendre quadrature rule for integrating a function over <code>[0,1]</code>. Exactly integrates all polynomials of degree <code>≤ 2N-1</code>.</p><pre><code class="language-julia hljs">using Inti

q = Inti.GaussLegendre(;order=10)

Inti.integrate(cos,q) ≈ sin(1) - sin(0)

# output

true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L114-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.GeometricEntity" href="#Inti.GeometricEntity"><code>Inti.GeometricEntity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GeometricEntity</code></pre><p>Geometrical objects such as lines, surfaces, and volumes.</p><p>Geometrical entities are stored in a global <a href="#Inti.ENTITIES"><code>ENTITIES</code></a> dictionary mapping <a href="#Inti.EntityKey"><code>EntityKey</code></a> to the corresponding <code>GeometricEntity</code>, and usually entities are manipulated through their keys.</p><p>A <code>GeometricEntity</code> can also contain a <code>pushforward</code> field used to parametrically represent the entry as the image of a reference domain (<code>pushforward.domain</code>) under some function (<code>pushforward.parametrization</code>).</p><p>Note that entities are manipulated through their keys, and the <code>GeometricEntity</code> constructor returns the key of the created entity; to retrieve the entity, use the <a href="#Inti.global_get_entity-Tuple{Inti.EntityKey}"><code>global_get_entity</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/entities.jl#L47-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.GeometricEntity-Tuple{String}" href="#Inti.GeometricEntity-Tuple{String}"><code>Inti.GeometricEntity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeometricEntity(shape::String [; translation, rotation, scaling, kwargs...])</code></pre><p>Constructs a geometric entity with the specified shape and optional parameters, and returns its <code>key</code>.</p><p><strong>Arguments</strong></p><ul><li><code>shape::String</code>: The shape of the geometric entity.</li><li><code>translation</code>: The translation vector of the geometric entity. Default is <code>SVector(0, 0, 0)</code>.</li><li><code>rotation</code>: The rotation vector of the geometric entity. Default is <code>SVector(0, 0, 0)</code>.</li><li><code>scaling</code>: The scaling vector of the geometric entity. Default is <code>SVector(1, 1, 1)</code>.</li><li><code>kwargs...</code>: Additional keyword arguments to be passed to the shape constructor.</li></ul><p><strong>Supported shapes</strong></p><ul><li><a href="#Inti.ellipsoid-Tuple{}"><code>ellipsoid</code></a></li><li><a href="#Inti.torus-Tuple{}"><code>torus</code></a></li><li><a href="#Inti.bean-Tuple{}"><code>bean</code></a></li><li><a href="#Inti.acorn-Tuple{}"><code>acorn</code></a></li><li><a href="#Inti.cushion-Tuple{}"><code>cushion</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/simpleshapes.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Helmholtz-Tuple{}" href="#Inti.Helmholtz-Tuple{}"><code>Inti.Helmholtz</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Helmholtz(; k, dim)</code></pre><p>Helmholtz operator in <code>dim</code> dimensions: <code>-Δu - k²u</code>.</p><p>The parameter <code>k</code> can be a real or complex number. For purely imaginary wavenumbers, consider using the <a href="#Inti.Yukawa-Tuple{}"><code>Yukawa</code></a> kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/kernels.jl#L284-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.HyperRectangle" href="#Inti.HyperRectangle"><code>Inti.HyperRectangle</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct HyperRectangle{N,T} &lt;: ReferenceInterpolant{ReferenceHyperCube{N},T}</code></pre><p>Axis-aligned hyperrectangle in <code>N</code> dimensions given by <code>low_corner::SVector{N,T}</code> and <code>high_corner::SVector{N,T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L136-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.HyperSingularKernel" href="#Inti.HyperSingularKernel"><code>Inti.HyperSingularKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct HyperSingularKernel{T,Op} &lt;: AbstractKernel{T}</code></pre><p>Given an operator <code>Op</code>, construct its free-space hypersingular kernel. This corresponds to the <code>transpose(γ₁,ₓγ₁[G])</code>, where <code>G</code> is the <a href="#Inti.SingleLayerKernel"><code>SingleLayerKernel</code></a>. For operators such as <a href="#Inti.Laplace-Tuple{}"><code>Laplace</code></a> or <a href="#Inti.Helmholtz-Tuple{}"><code>Helmholtz</code></a>, this is simply the normal derivative respect to the target variable of the <code>DoubleLayerKernel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/kernels.jl#L71-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.IntegralOperator" href="#Inti.IntegralOperator"><code>Inti.IntegralOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct IntegralOperator{T} &lt;: AbstractMatrix{T}</code></pre><p>A discrete linear integral operator given by</p><p class="math-container">\[I[u](x) = \int_{\Gamma\_s} K(x,y)u(y) ds_y, x \in \Gamma_{t}\]</p><p>where <span>$\Gamma_s$</span> and <span>$\Gamma_t$</span> are the source and target domains, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/nystrom.jl#L40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.IntegralPotential" href="#Inti.IntegralPotential"><code>Inti.IntegralPotential</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct IntegralPotential</code></pre><p>Represent a potential given by a <code>kernel</code> and a <code>quadrature</code> over which integration is performed.</p><p><code>IntegralPotential</code>s are created using <code>IntegralPotential(kernel, quadrature)</code>.</p><p>Evaluating an integral potential requires a density <code>σ</code> (defined over the quadrature nodes of the source mesh) and a point <code>x</code> at which to evaluate the integral</p><p class="math-container">\[\int_{\Gamma} K(oldsymbol{x},oldsymbol{y})\sigma(y) ds_y, x \not \in \Gamma\]</p><p>Assuming <code>𝒮</code> is an integral potential and <code>σ</code> is a vector of values defined on <code>quadrature</code>, calling <code>𝒮[σ]</code> creates an anonymous function that can be evaluated at any point <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/nystrom.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Kronrod" href="#Inti.Kronrod"><code>Inti.Kronrod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Kronrod{D,N} &lt;: ReferenceQuadrature{D}</code></pre><p><code>N</code>-point Kronrod rule obtained by adding <code>n+1</code> points to a Gauss quadrature containing <code>n</code> points. The order is either <code>3n + 1</code> for <code>n</code> even or <code>3n + 2</code> for <code>n</code> odd.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L500-L506">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.LagrangeCube" href="#Inti.LagrangeCube"><code>Inti.LagrangeCube</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const LagrangeSquare = LagrangeElement{ReferenceSquare}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L332-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.LagrangeElement" href="#Inti.LagrangeElement"><code>Inti.LagrangeElement</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LagrangeElement{D,Np,T} &lt;: ReferenceInterpolant{D,T}</code></pre><p>A polynomial <code>p : D → T</code> uniquely defined by its <code>Np</code> values on the <code>Np</code> reference nodes of <code>D</code>.</p><p>The return type <code>T</code> should be a vector space (i.e. support addition and multiplication by scalars). For istance, <code>T</code> could be a number or a vector, but not a <code>Tuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L210-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.LagrangeLine" href="#Inti.LagrangeLine"><code>Inti.LagrangeLine</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const LagrangeLine = LagrangeElement{ReferenceLine}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L293-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.LagrangeSquare" href="#Inti.LagrangeSquare"><code>Inti.LagrangeSquare</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const LagrangeSquare = LagrangeElement{ReferenceSquare}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L322-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.LagrangeTetrahedron" href="#Inti.LagrangeTetrahedron"><code>Inti.LagrangeTetrahedron</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const LagrangeTetrahedron = LagrangeElement{ReferenceTetrahedron}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L317-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.LagrangeTriangle" href="#Inti.LagrangeTriangle"><code>Inti.LagrangeTriangle</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const LagrangeTriangle = LagrangeElement{ReferenceTriangle}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L307-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Laplace-Tuple{}" href="#Inti.Laplace-Tuple{}"><code>Inti.Laplace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Laplace(; dim)</code></pre><p>Laplace&#39;s differential operator in <code>dim</code> dimension: <span>$-Δu$</span>. ```</p><p>Note the <strong>negative sign</strong> in the definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/kernels.jl#L90-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Mesh" href="#Inti.Mesh"><code>Inti.Mesh</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Mesh{N,T} &lt;: AbstractMesh{N,T}</code></pre><p>Unstructured mesh defined by a set of <code>nodes</code><code>(of type</code>SVector{N,T}`), and a dictionary mapping element types to connectivity matrices. Each columns of a given connectivity matrix stores the integer tags of the nodes in the mesh comprising the element.</p><p>Additionally, the mesh contains a mapping from <a href="#Inti.EntityKey"><code>EntityKey</code></a>s to the tags of the elements composing the entity. This can be used to extract submeshes from a given mesh using e.g. <code>view(msh,Γ)</code> or <code>msh[Γ]</code>, where <code>Γ</code> is a <a href="#Inti.Domain"><code>Domain</code></a>.</p><p>See <a href="#Inti.elements"><code>elements</code></a> for a way to iterate over the elements of a mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/mesh.jl#L60-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ModifiedHelmholtz" href="#Inti.ModifiedHelmholtz"><code>Inti.ModifiedHelmholtz</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const ModifiedHelmholtz</code></pre><p>Type alias for the <a href="#Inti.Yukawa-Tuple{}"><code>Yukawa</code></a> operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/kernels.jl#L192-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.MultiIndex" href="#Inti.MultiIndex"><code>Inti.MultiIndex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultiIndex{N}</code></pre><p>Wrapper around <code>NTuple{N,Int}</code> mimicking a multi-index in <code>ℤ₀ᴺ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L282-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ParametricElement" href="#Inti.ParametricElement"><code>Inti.ParametricElement</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParametricElement{D,T,F} &lt;: ReferenceInterpolant{D,T}</code></pre><p>An element represented through a explicit function <code>f</code> mapping <code>D</code> into the element. For performance reasons, <code>f</code> should take as input a <code>StaticVector</code> and return a <code>StaticVector</code> or <code>StaticArray</code>.</p><p>See also: <a href="#Inti.ReferenceInterpolant"><code>ReferenceInterpolant</code></a>, <a href="#Inti.LagrangeElement"><code>LagrangeElement</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L164-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ParametricElement-Union{Tuple{T}, Tuple{N}, Tuple{Any, Inti.HyperRectangle{N, T}}} where {N, T}" href="#Inti.ParametricElement-Union{Tuple{T}, Tuple{N}, Tuple{Any, Inti.HyperRectangle{N, T}}} where {N, T}"><code>Inti.ParametricElement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParametricElement(f, d::HyperRectangle)</code></pre><p>Construct the element defined as the image of <code>f</code> over <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L199-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.PolynomialSpace" href="#Inti.PolynomialSpace"><code>Inti.PolynomialSpace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct PolynomialSpace{D,K}</code></pre><p>The space of all polynomials of degree <code>≤K</code>, commonly referred to as <code>ℙₖ</code>.</p><p>The type parameter <code>D</code>, of singleton type, is used to determine the reference domain of the polynomial basis. In particular, when <code>D</code> is a hypercube in <code>d</code> dimensions, the precise definition is <code>ℙₖ = span{𝐱ᶿ : 0≤max(θ)≤ K}</code>; when <code>D</code> is a <code>d</code>-dimensional simplex, the space is <code>ℙₖ = span{𝐱ᶿ : 0≤sum(θ)≤ K}</code>, where <code>θ ∈ 𝐍ᵈ</code> is a multi-index.</p><p><strong>See also: <a href="#Inti.monomial_basis"><code>monomial_basis</code></a>, <a href="#Inti.lagrange_basis-Tuple{Any, Inti.PolynomialSpace}"><code>lagrange_basis</code></a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/polynomials.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Quadrature" href="#Inti.Quadrature"><code>Inti.Quadrature</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Quadrature{N,T} &lt;: AbstractVector{QuadratureNode{N,T}}</code></pre><p>A collection of <a href="#Inti.QuadratureNode"><code>QuadratureNode</code></a>s used to integrate over an <a href="#Inti.AbstractMesh"><code>AbstractMesh</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/quadrature.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Quadrature-Tuple{Inti.Domain}" href="#Inti.Quadrature-Tuple{Inti.Domain}"><code>Inti.Quadrature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Quadrature(Ω::Domain; meshsize, qorder)</code></pre><p>Construct a <code>Quadrature</code> over the domain <code>Ω</code> with a mesh of size <code>meshsize</code> and quadrature order <code>qorder</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/quadrature.jl#L172-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Quadrature-Union{Tuple{T}, Tuple{N}, Tuple{Inti.AbstractMesh{N, T}, Dict}} where {N, T}" href="#Inti.Quadrature-Union{Tuple{T}, Tuple{N}, Tuple{Inti.AbstractMesh{N, T}, Dict}} where {N, T}"><code>Inti.Quadrature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Quadrature(msh::AbstractMesh, etype2qrule::Dict)
Quadrature(msh::AbstractMesh, qrule::ReferenceQuadrature)
Quadrature(msh::AbstractMesh; qorder)</code></pre><p>Construct a <code>Quadrature</code> for <code>msh</code>, where for each element type <code>E</code> in <code>msh</code> the reference quadrature <code>q = etype2qrule[E]</code> is used. When a single <code>qrule</code> is passed, it is used for all element types in <code>msh</code>.</p><p>If an <code>order</code> keyword is passed, a default quadrature of the desired order is used for each element type usig <a href="#Inti._qrule_for_reference_shape-Tuple{Any, Any}"><code>_qrule_for_reference_shape</code></a>.</p><p>For co-dimension one elements, the normal vector is also computed and stored in the <a href="#Inti.QuadratureNode"><code>QuadratureNode</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/quadrature.jl#L88-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.QuadratureNode" href="#Inti.QuadratureNode"><code>Inti.QuadratureNode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuadratureNode{N,T&lt;:Real}</code></pre><p>A point in <code>ℝᴺ</code> with a <code>weight</code> for performing numerical integration. A <code>QuadratureNode</code> can optionally store a <code>normal</code> vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/quadrature.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceCube" href="#Inti.ReferenceCube"><code>Inti.ReferenceCube</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const ReferenceCube = ReferenceHyperCube{3}</code></pre><p>Singleton type representing the unit cube <code>[0,1]³</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_shapes.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceHyperCube" href="#Inti.ReferenceHyperCube"><code>Inti.ReferenceHyperCube</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ReferenceHyperCube{N} &lt;: ReferenceShape{N}</code></pre><p>Singleton type representing the axis-aligned hypercube in <code>N</code> dimensions with the lower corner at the origin and the upper corner at <code>(1,1,…,1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_shapes.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceInterpolant" href="#Inti.ReferenceInterpolant"><code>Inti.ReferenceInterpolant</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type ReferenceInterpolant{D,T}</code></pre><p>Interpolanting function mapping points on the domain <code>D&lt;:ReferenceShape</code> (of singleton type) to a value of type <code>T</code>.</p><p>Instances <code>el</code> of <code>ReferenceInterpolant</code> are expected to implement:</p><ul><li><code>el(x̂)</code>: evaluate the interpolation scheme at the (reference) coordinate <code>x̂ ∈ D</code>.</li><li><code>jacobian(el,x̂)</code> : evaluate the jacobian matrix of the interpolation at the (reference) coordinate <code>x ∈ D</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For performance reasons, both <code>el(x̂)</code> and <code>jacobian(el,x̂)</code> should take as input a <code>StaticVector</code> and output a static vector or static array.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceLine" href="#Inti.ReferenceLine"><code>Inti.ReferenceLine</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const ReferenceLine = ReferenceHyperCube{1}</code></pre><p>Singleton type representing the <code>[0,1]</code> segment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_shapes.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceQuadrature" href="#Inti.ReferenceQuadrature"><code>Inti.ReferenceQuadrature</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type ReferenceQuadrature{D}</code></pre><p>A quadrature rule for integrating a function over the domain <code>D &lt;: ReferenceShape</code>.</p><p>Calling <code>x,w = q()</code> returns the nodes <code>x</code>, given as <code>SVector</code>s, and weights <code>w</code>, for performing integration over <code>domain(q)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceShape" href="#Inti.ReferenceShape"><code>Inti.ReferenceShape</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type ReferenceShape</code></pre><p>A fixed reference domain/shape. Used mostly for defining more complex shapes as transformations mapping an <code>ReferenceShape</code> to some region of <code>ℜᴹ</code>.</p><p>See e.g. <a href="#Inti.ReferenceLine"><code>ReferenceLine</code></a> or <a href="#Inti.ReferenceTriangle"><code>ReferenceTriangle</code></a> for some examples of concrete subtypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_shapes.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceSimplex" href="#Inti.ReferenceSimplex"><code>Inti.ReferenceSimplex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ReferenceSimplex{N}</code></pre><p>Singleton type representing the N-simplex with N+1 vertices <code>(0,...,0),(0,...,0,1),(0,...,0,1,0),(1,0,...,0)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_shapes.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceSquare" href="#Inti.ReferenceSquare"><code>Inti.ReferenceSquare</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const ReferenceSquare = ReferenceHyperCube{2}</code></pre><p>Singleton type representing the unit square <code>[0,1]²</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_shapes.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceTetrahedron" href="#Inti.ReferenceTetrahedron"><code>Inti.ReferenceTetrahedron</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ReferenceTetrahedron</code></pre><p>Singleton type representing the tetrahedron with vertices <code>(0,0,0),(0,0,1),(0,1,0),(1,0,0)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_shapes.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ReferenceTriangle" href="#Inti.ReferenceTriangle"><code>Inti.ReferenceTriangle</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ReferenceTriangle</code></pre><p>Singleton type representing the triangle with vertices <code>(0,0),(1,0),(0,1)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_shapes.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.SingleLayerKernel" href="#Inti.SingleLayerKernel"><code>Inti.SingleLayerKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SingleLayerKernel{T,Op} &lt;: AbstractKernel{T}</code></pre><p>The free-space single-layer kernel (i.e. the fundamental solution) of an <code>Op &lt;: AbstractDifferentialOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/kernels.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Stokes-Tuple{}" href="#Inti.Stokes-Tuple{}"><code>Inti.Stokes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Stokes(; μ, dim)</code></pre><p>Stokes operator in <code>dim</code> dimensions: <span>$[-μΔu + ∇p, ∇⋅u]$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/kernels.jl#L394-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.SubMesh" href="#Inti.SubMesh"><code>Inti.SubMesh</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SubMesh{N,T} &lt;: AbstractMesh{N,T}</code></pre><p>View into a <code>parent</code> mesh over a given <code>domain</code>.</p><p>A submesh implements the interface for <code>AbstractMesh</code>; therefore you can iterate over elements of the submesh just like you would with a mesh.</p><p>Construct <code>SubMesh</code>s using <code>view(parent,Ω::Domain)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/mesh.jl#L469-L478">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.TensorProductQuadrature" href="#Inti.TensorProductQuadrature"><code>Inti.TensorProductQuadrature</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TensorProductQuadrature{N,Q}</code></pre><p>A tensor-product of one-dimension quadrature rules. Integrates over <code>[0,1]^N</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">qx = Inti.Fejer(10)
qy = Inti.Fejer(15)
q  = Inti.TensorProductQuadrature(qx,qy)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L222-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.VioreanuRokhlin" href="#Inti.VioreanuRokhlin"><code>Inti.VioreanuRokhlin</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct VioreanuRokhlin{D,N} &lt;: ReferenceQuadrature{D}</code></pre><p>Tabulated <code>N</code>-point Vioreanu-Rokhlin quadrature rule for integration over <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.Yukawa-Tuple{}" href="#Inti.Yukawa-Tuple{}"><code>Inti.Yukawa</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Yukawa(; λ, dim)</code></pre><p>Yukawa operator, also known as modified Helmholtz, in <code>dim</code> dimensions: <span>$-Δu + λ²u$</span>.</p><p>The parameter <code>λ</code> is a positive number. Note the <strong>negative sign</strong> in front of the Laplacian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/kernels.jl#L179-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate" href="#Base.iterate"><code>Base.iterate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iterate(Ω::Domain)</code></pre><p>Iterating over a domain means iterating over its entities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/domain.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti._copyto!-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:StaticArraysCore.SMatrix}}" href="#Inti._copyto!-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:StaticArraysCore.SMatrix}}"><code>Inti._copyto!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_copyto!(target,source)</code></pre><p>Defaults to <code>Base.copyto!</code>, but includes some specialized methods to copy from a <code>Matrix</code> of <code>SMatrix</code> to a <code>Matrix</code> of <code>Number</code>s and viceversa.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L171-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti._get_gauss_qcoords_and_qweights-Tuple{Type{&lt;:Inti.ReferenceShape}, Any}" href="#Inti._get_gauss_qcoords_and_qweights-Tuple{Type{&lt;:Inti.ReferenceShape}, Any}"><code>Inti._get_gauss_qcoords_and_qweights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_gauss_and_qweights(R::Type{&lt;:ReferenceShape{D}}, N) where D</code></pre><p>Returns the <code>N</code>-point symmetric gaussian qnodes and qweights <code>(x, w)</code> for integration over <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L199-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti._get_vioreanurokhlin_qcoords_and_qweights-Tuple{Type{&lt;:Inti.ReferenceShape}, Any}" href="#Inti._get_vioreanurokhlin_qcoords_and_qweights-Tuple{Type{&lt;:Inti.ReferenceShape}, Any}"><code>Inti._get_vioreanurokhlin_qcoords_and_qweights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_get_vioreanurokhlin_qcoords_and_qweights(R::Type{&lt;:ReferenceShape{D}}, N) where D</code></pre><p>Returns the <code>N</code>-point Vioreanu-Rokhlin qnodes and qweights <code>(x, w)</code> for integration over <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L313-L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti._green_multiplier-Tuple{Symbol}" href="#Inti._green_multiplier-Tuple{Symbol}"><code>Inti._green_multiplier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_green_multiplier(s::Symbol)</code></pre><p>Return <code>-1.0</code> if <code>s == :inside</code>, <code>0.0</code> if <code>s == :outside</code>, and <code>-0.5</code> if <code>s == :on</code>; otherwise, throw an error. The orientation is relative to the normal of the bounding curve/surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/nystrom.jl#L171-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti._green_multiplier-Union{Tuple{N}, Tuple{StaticArraysCore.SVector, Inti.Quadrature{N}}} where N" href="#Inti._green_multiplier-Union{Tuple{N}, Tuple{StaticArraysCore.SVector, Inti.Quadrature{N}}} where N"><code>Inti._green_multiplier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_green_multiplier(x, quad)</code></pre><p>Helper function to help determine the constant σ in the Green identity S[γ₁u](x)</p><ul><li>D[γ₀u](x) + σ*u(x) = 0. This can be used as a predicate to determine whether a</li></ul><p>point is inside a domain or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/nystrom.jl#L153-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti._meshgen-Tuple{Any, Inti.HyperRectangle, NTuple{N, T} where {N, T}}" href="#Inti._meshgen-Tuple{Any, Inti.HyperRectangle, NTuple{N, T} where {N, T}}"><code>Inti._meshgen</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_meshgen(f,d::HyperRectangle,sz)</code></pre><p>Create <code>prod(sz)</code> elements of <a href="#Inti.ParametricElement"><code>ParametricElement</code></a> type representing the push forward of <code>f</code> on each of the subdomains defined by a uniform cartesian mesh of <code>d</code> of size <code>sz</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/mesh.jl#L338-L344">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti._normal-Union{Tuple{StaticArraysCore.SMatrix{N, M}}, Tuple{M}, Tuple{N}} where {N, M}" href="#Inti._normal-Union{Tuple{StaticArraysCore.SMatrix{N, M}}, Tuple{M}, Tuple{N}} where {N, M}"><code>Inti._normal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_normal(jac::SMatrix{M,N})</code></pre><p>Given a an <code>M</code> by <code>N</code> matrix representing the jacobian of a codimension one object, compute the normal vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti._qrule_for_reference_shape-Tuple{Any, Any}" href="#Inti._qrule_for_reference_shape-Tuple{Any, Any}"><code>Inti._qrule_for_reference_shape</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_qrule_for_reference_shape(ref,order)</code></pre><p>Given a <code>ref</code>erence shape and a desired quadrature <code>order</code>, return an appropiate quadrature rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/quadrature.jl#L210-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.acorn-Tuple{}" href="#Inti.acorn-Tuple{}"><code>Inti.acorn</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">acorn(; translation, rotation, scaling, labels)</code></pre><p>Create an acorn entity in 3D, and apply optional transformations. Returns the key.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/simpleshapes.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.adaptive_correction-Tuple{Inti.IntegralOperator}" href="#Inti.adaptive_correction-Tuple{Inti.IntegralOperator}"><code>Inti.adaptive_correction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adaptive_correction(iop::IntegralOperator; tol, maxdist = farfield_distance(iop; atol), maxsplit = 1000])</code></pre><p>Given an integral operator <code>iop</code>, this function provides a sparse correction to <code>iop</code> for the entries <code>i,j</code> such that the distance between the <code>i</code>-th target and the <code>j</code>-th source is less than <code>maxdist</code>.</p><p>Choosing <code>maxdist</code> is a trade-off between accuracy and efficiency. The smaller the value, the fewer corrections are needed, but this may compromise the accuracy. For a <em>fixed</em> quadrature, the size of <code>maxdist</code> has to grow as the tolerance <code>tol</code> decreases. The default <code>[farfield_distance(iop; tol)](@ref) provides a heuristic to determine a suitable</code>maxdist`.</p><p>The correction is computed by using the <a href="#Inti.adaptive_integration-Tuple{Any, Inti.EmbeddedQuadrature}"><code>adaptive_integration</code></a> routine, with a tolerance <code>atol</code> and a maximum number of subdivisions <code>maxsplit</code>; see <a href="#Inti.adaptive_integration-Tuple{Any, Inti.EmbeddedQuadrature}"><code>adaptive_integration</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/adaptive.jl#L16-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.adaptive_integration-Tuple{Any, Inti.EmbeddedQuadrature}" href="#Inti.adaptive_integration-Tuple{Any, Inti.EmbeddedQuadrature}"><code>Inti.adaptive_integration</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adaptive_integration(f, τ̂::RefernceShape; kwargs...)
adaptive_integration(f, qrule::EmbeddedQuadrature; kwargs...)</code></pre><p>Use an adaptive procedure to estimate the integral of <code>f</code> over <code>τ̂ = domain(qrule)</code>. The following optional keyword arguments are available:</p><ul><li><code>atol::Real=0.0</code>: absolute tolerance for the integral estimate</li><li><code>rtol::Real=0.0</code>: relative tolerance for the integral estimate</li><li><code>maxsplit::Int=1000</code>: maximum number of times to split the domain</li><li><code>norm::Function=LinearAlgebra.norm</code>: norm to use for error estimates</li><li><code>buffer::BinaryHeap</code>: a pre-allocated buffer to use for the adaptive procedure (see <a href="#Inti.allocate_buffer-Tuple{Any, Inti.EmbeddedQuadrature}">allocate_buffer</a>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L395-L407">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.adaptive_integration_singular-Tuple{Any, Inti.ReferenceHyperCube{1}, Any}" href="#Inti.adaptive_integration_singular-Tuple{Any, Inti.ReferenceHyperCube{1}, Any}"><code>Inti.adaptive_integration_singular</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adaptive_integration_singular(f, τ̂, x̂ₛ; kwargs...)</code></pre><p>Similar to <a href="#Inti.adaptive_integration-Tuple{Any, Inti.EmbeddedQuadrature}"><code>adaptive_integration</code></a>, but indicates that <code>f</code> has an isolated (integrable) singularity at <code>x̂ₛ ∈ x̂ₛ</code>.</p><p>The integration is performed by splitting <code>τ̂</code> so that <code>x̂ₛ</code> is a fixed vertex, guaranteeing that <code>f</code> is never evaluated at <code>x̂ₛ</code>. Aditionally, a suitable change of variables may be applied to alleviate the singularity and improve the rate of convergence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/adaptive.jl#L150-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.adj_double_layer_hypersingular-Tuple{}" href="#Inti.adj_double_layer_hypersingular-Tuple{}"><code>Inti.adj_double_layer_hypersingular</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adj_double_layer_hypersingular(; op, target, source, compression,
correction)</code></pre><p>Similar to <code>single_double_layer</code>, but for the adjoint double-layer and hypersingular operators. See the documentation of [<code>single_double_layer</code>] for a description of the arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/api.jl#L184-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.allocate_buffer-Tuple{Any, Inti.EmbeddedQuadrature}" href="#Inti.allocate_buffer-Tuple{Any, Inti.EmbeddedQuadrature}"><code>Inti.allocate_buffer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allocate_buffer(f, quad::EmbeddedQuadrature)</code></pre><p>Create the <code>buffer</code> needed for the call <a href="#Inti.adaptive_integration-Tuple{Any, Inti.EmbeddedQuadrature}"><code>adaptive_integration(f, τ̂; buffer, ...)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L458-L463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ambient_dimension" href="#Inti.ambient_dimension"><code>Inti.ambient_dimension</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ambient_dimension(x)</code></pre><p>Dimension of the ambient space where <code>x</code> lives. For geometrical objects this can differ from its <a href="#Inti.geometric_dimension"><code>geometric_dimension</code></a>; for example a triangle in <code>ℝ³</code> has ambient dimension <code>3</code> but geometric dimension <code>2</code>, while a curve in <code>ℝ³</code> has ambient dimension 3 but geometric dimension 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L33-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.assemble_fmm-Tuple{Inti.IntegralOperator, Vararg{Any}}" href="#Inti.assemble_fmm-Tuple{Inti.IntegralOperator, Vararg{Any}}"><code>Inti.assemble_fmm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assemble_fmm(iop; atol)</code></pre><p>Set up a 2D or 3D FMM for evaluating the discretized integral operator <code>iop</code> associated with the <code>op</code>. In 2D the <code>FMM2D</code> or <code>FMMLIB2D</code> library is used (whichever was most recently loaded) while in 3D <code>FMM3D</code> is used.</p><div class="admonition is-warning"><header class="admonition-header">FMMLIB2D</header><div class="admonition-body"><p>FMMLIB2D does <em>no</em> checking for if the targets and sources coincide, and will return <code>Inf</code> values if <code>iop.target !== iop.source</code>, but there is a point <code>x ∈ iop.target</code> such that <code>x ∈ iop.source</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/nystrom.jl#L108-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.assemble_hmatrix-Tuple" href="#Inti.assemble_hmatrix-Tuple"><code>Inti.assemble_hmatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assemble_hmatrix(iop[; atol, rank, rtol, eta])</code></pre><p>Assemble an H-matrix representation of the discretized integral operator <code>iop</code> using the <code>HMatrices.jl</code> library.</p><p>See the documentation of <a href="https://github.com/IntegralEquations/HMatrices.jl"><code>HMatrices</code></a> for more details on usage and other keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/nystrom.jl#L139-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.assemble_matrix-Tuple{Inti.IntegralOperator}" href="#Inti.assemble_matrix-Tuple{Inti.IntegralOperator}"><code>Inti.assemble_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assemble_matrix(iop::IntegralOperator; threads = true)</code></pre><p>Assemble a dense matrix representation of an <code>IntegralOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/nystrom.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.bdim_correction-Tuple{Any, Any, Inti.Quadrature, Any, Any}" href="#Inti.bdim_correction-Tuple{Any, Any, Inti.Quadrature, Any, Any}"><code>Inti.bdim_correction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bdim_correction(op,X,Y,S,D; green_multiplier, kwargs...)</code></pre><p>Given a <code>op</code> and a (possibly innacurate) discretizations of its single and double-layer operators <code>S</code> and <code>D</code> (taking a vector of values on <code>Y</code> and returning a vector on of values on <code>X</code>), compute corrections <code>δS</code> and <code>δD</code> such that <code>S + δS</code> and <code>D + δD</code> are more accurate approximations of the underlying single- and double-layer integral operators.</p><p>See [<a href="../references/#faria2021general">7</a>] for more details on the method.</p><p><strong>Arguments</strong></p><p><strong>Required:</strong></p><ul><li><code>op</code> must be an <a href="#Inti.AbstractDifferentialOperator"><code>AbstractDifferentialOperator</code></a></li><li><code>Y</code> must be a <a href="../tutorials/getting_started/#Quadrature"><code>Quadrature</code></a> object of a closed surface</li><li><code>X</code> is either inside, outside, or on <code>Y</code></li><li><code>S</code> and <code>D</code> are approximations to the single- and double-layer operators for <code>op</code> taking densities in <code>Y</code> and returning densities in <code>X</code>.</li><li><code>green_multiplier</code> (keyword argument) is a vector with the same length as <code>X</code> storing the value of <code>μ(x)</code> for <code>x ∈ X</code> in the Green identity <code>S\[γ₁u\](x) - D\[γ₀u\](x) + μ*u(x) = 0</code>. See <a href="#Inti._green_multiplier-Tuple{Symbol}"><code>_green_multiplier</code></a>.</li></ul><p><strong>Optional <code>kwargs</code>:</strong></p><ul><li><code>parameters::DimParameters</code>: parameters associated with the density interpolation method</li><li><code>derivative</code>: if true, compute the correction to the adjoint double-layer and hypersingular operators instead. In this case, <code>S</code> and <code>D</code> should be replaced by a (possibly innacurate) discretization of adjoint double-layer and hypersingular operators, respectively.</li><li><code>maxdist</code>: distance beyond which interactions are considered sufficiently far so that no correction is needed. This is used to determine a threshold for nearly-singular corrections when <code>X</code> and <code>Y</code> are different surfaces. When <code>X === Y</code>, this is not needed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/bdim.jl#L12-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.bean-Tuple{}" href="#Inti.bean-Tuple{}"><code>Inti.bean</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bean(; translation, rotation, scaling, labels)</code></pre><p>Create a bean entity in 3D, and apply optional transformations. Returns the key.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/simpleshapes.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.boundary-Tuple{Inti.Domain}" href="#Inti.boundary-Tuple{Inti.Domain}"><code>Inti.boundary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">boundary(Ω::Domain)</code></pre><p>Return the external boundaries of a domain.</p><p>See also: <a href="#Inti.external_boundary-Tuple{Inti.Domain}"><code>external_boundary</code></a>, <a href="#Inti.internal_boundary-Tuple{Inti.Domain}"><code>internal_boundary</code></a>, <a href="#Inti.skeleton-Tuple{Inti.Domain}"><code>skeleton</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/domain.jl#L113-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.boundary_idxs-Tuple{Inti.LagrangeElement{Inti.ReferenceHyperCube{1}}}" href="#Inti.boundary_idxs-Tuple{Inti.LagrangeElement{Inti.ReferenceHyperCube{1}}}"><code>Inti.boundary_idxs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">boundary_idxs(el::LagrangeElement)</code></pre><p>The indices of the nodes in <code>el</code> that define the boundary of the element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L356-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.cart2sph-Tuple{Any, Any, Any}" href="#Inti.cart2sph-Tuple{Any, Any, Any}"><code>Inti.cart2sph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cart2sph(x,y,z)</code></pre><p>Map cartesian coordinates <code>x,y,z</code> to spherical ones <code>r, θ, φ</code> representing the radius, elevation, and azimuthal angle respectively. The convention followed is that <code>0 ≤ θ ≤ π</code> and <code>-π &lt; φ ≤ π</code>. Same as the <code>cart2sph</code> function in MATLAB.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L362-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.connectivity-Tuple{Inti.Mesh, DataType}" href="#Inti.connectivity-Tuple{Inti.Mesh, DataType}"><code>Inti.connectivity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">connectivity(msh::AbstractMesh,E::DataType)</code></pre><p>Return the connectivity matrix for elements of type <code>E</code> in <code>msh</code>. The integer tags in the matrix refer to the points in <code>nodes(msh)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/mesh.jl#L116-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.coords-Tuple{T} where T" href="#Inti.coords-Tuple{T} where T"><code>Inti.coords</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coords(q)</code></pre><p>Return the spatial coordinates of <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/quadrature.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.cushion-Tuple{}" href="#Inti.cushion-Tuple{}"><code>Inti.cushion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cushion(; translation, rotation, scaling, labels)</code></pre><p>Create a cushion entity in 3D, and apply optional transformations. Returns the key.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/simpleshapes.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.decompose" href="#Inti.decompose"><code>Inti.decompose</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decompose(s::ReferenceShape,x)</code></pre><p>Decompose an <a href="#Inti.ReferenceShape"><code>ReferenceShape</code></a> into <a href="#Inti.LagrangeElement"><code>LagrangeElement</code></a>s so that <code>x</code> is a fixed vertex of the children elements.</p><p>The decomposed elements may be oriented differently than the parent, and thus care has to be taken regarding e.g. normal vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/adaptive.jl#L179-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.degree-Union{Tuple{Type{&lt;:Inti.LagrangeElement{D, Np}}}, Tuple{Np}, Tuple{D}} where {D, Np}" href="#Inti.degree-Union{Tuple{Type{&lt;:Inti.LagrangeElement{D, Np}}}, Tuple{Np}, Tuple{D}} where {D, Np}"><code>Inti.degree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">degree(el::LagrangeElement)
degree(el::Type{&lt;:LagrangeElement})</code></pre><p>The polynomial degree <code>el</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L522-L527">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.dimension-Union{Tuple{Type{Inti.PolynomialSpace{D, K}}}, Tuple{K}, Tuple{D}} where {D, K}" href="#Inti.dimension-Union{Tuple{Type{Inti.PolynomialSpace{D, K}}}, Tuple{K}, Tuple{D}} where {D, K}"><code>Inti.dimension</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dimension(space)</code></pre><p>The length of a basis for <code>space</code>; i.e. the number of linearly independent elements required to span <code>space</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/polynomials.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.dom2elt-Tuple{Inti.AbstractMesh, Inti.Domain, DataType}" href="#Inti.dom2elt-Tuple{Inti.AbstractMesh, Inti.Domain, DataType}"><code>Inti.dom2elt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dom2elt(m::Mesh,Ω,E)::Vector{Int}</code></pre><p>Compute the element indices <code>idxs</code> of the elements of type <code>E</code> composing <code>Ω</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/mesh.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.dom2qtags-Tuple{Inti.Quadrature, Inti.Domain}" href="#Inti.dom2qtags-Tuple{Inti.Quadrature, Inti.Domain}"><code>Inti.dom2qtags</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dom2qtags(Q::Quadrature, dom::Domain)</code></pre><p>Given a domain, return the indices of the quadratures nodes in <code>Q</code> associated to its quadrature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/quadrature.jl#L193-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.domain" href="#Inti.domain"><code>Inti.domain</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">domain(f)</code></pre><p>Given a function-like object <code>f: Ω → R</code>, return <code>Ω</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.domain-Tuple{Inti.AbstractMesh}" href="#Inti.domain-Tuple{Inti.AbstractMesh}"><code>Inti.domain</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">domain(msh::AbstractMesh)</code></pre><p>Return a [<code>Domain</code>] containing of all entities covered by the mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/mesh.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.domain-Tuple{Inti.Quadrature}" href="#Inti.domain-Tuple{Inti.Quadrature}"><code>Inti.domain</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">domain(Q::Quadrature)</code></pre><p>The <a href="#Inti.Domain"><code>Domain</code></a> over which <code>Q</code> performs integration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/quadrature.jl#L184-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.domain-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D" href="#Inti.domain-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D"><code>Inti.domain</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">domain(q::ReferenceQuadrature)</code></pre><p>The domain of integratino for quadrature rule <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.element_types" href="#Inti.element_types"><code>Inti.element_types</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">element_types(msh::AbstractMesh)</code></pre><p>Return the element types present in the <code>msh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/mesh.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.elements" href="#Inti.elements"><code>Inti.elements</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">elements(msh::AbstractMesh [, E::DataType])</code></pre><p>Return the elements of a <code>msh</code>. Passing and element type <code>E</code> will restricts to elements of that type.</p><p>A common pattern to avoid type-instabilies in performance critical parts of the code is to use a <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#kernel-functions">function barrier</a>, as illustrated below:</p><pre><code class="language-julia hljs">for E in element_types(msh)
    _long_computation(elements(msh, E), args...)
end

@noinline function _long_computation(iter, args...)
    for el in iter # the type of el is known at compile time
        # do something with el
    end
end</code></pre><p>where a dynamic dispatch is performed only on the element types (typically small for a given mesh).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/mesh.jl#L25-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ellipsoid-Tuple{}" href="#Inti.ellipsoid-Tuple{}"><code>Inti.ellipsoid</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ellipsoid(; translation, rotation, scaling, labels)</code></pre><p>Create an ellipsoid entity in 3D, and apply optional transformations. Returns the key of the created entity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/simpleshapes.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.ent2etags-Tuple{Inti.Mesh}" href="#Inti.ent2etags-Tuple{Inti.Mesh}"><code>Inti.ent2etags</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ent2etags(msh::AbstractMesh)</code></pre><p>Return a dictionary mapping entities to a dictionary of element types to element tags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/mesh.jl#L106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.entities-Tuple{Inti.Domain}" href="#Inti.entities-Tuple{Inti.Domain}"><code>Inti.entities</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">entities(Ω::Domain)</code></pre><p>Return all entities making up a domain (as a set of <a href="#Inti.EntityKey"><code>EntityKey</code></a>s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/domain.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.etype_to_nearest_points-Tuple{Any, Inti.Quadrature}" href="#Inti.etype_to_nearest_points-Tuple{Any, Inti.Quadrature}"><code>Inti.etype_to_nearest_points</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">etype_to_nearest_points(X,Y::Quadrature; maxdist)</code></pre><p>For each element <code>el</code> in <code>Y.mesh</code>, return a list with the indices of all points in <code>X</code> for which <code>el</code> is the nearest element. Ignore indices for which the distance exceeds <code>maxdist</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/quadrature.jl#L250-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.external_boundary-Tuple{Inti.Domain}" href="#Inti.external_boundary-Tuple{Inti.Domain}"><code>Inti.external_boundary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">external_boundary(Ω::Domain)</code></pre><p>Return the external boundaries inside a domain. These are entities in the skeleton of Ω which are not in the internal boundaries of Ω.</p><p>See also: <a href="#Inti.internal_boundary-Tuple{Inti.Domain}"><code>internal_boundary</code></a>, <a href="#Inti.skeleton-Tuple{Inti.Domain}"><code>skeleton</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/domain.jl#L101-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.farfield_distance-Tuple{Inti.IntegralOperator}" href="#Inti.farfield_distance-Tuple{Inti.IntegralOperator}"><code>Inti.farfield_distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">farfield_distance(iop::IntegralOperator; tol, maxiter = 10)
farfield_distance(K, Q::Quadrature; tol, maxiter = 10)</code></pre><p>Return an estimate of the distance <code>d</code> such that the (absolute) quadrature error of the integrand <code>y -&gt; K(x,y)</code> is below <code>tol</code> for <code>x</code> at a distance <code>d</code> from the center of the largest element in <code>Q</code>; when an integral operator is passed, we have <code>Q::Quadrature = source(iop)</code> and <code>K = kernel(iop)</code>.</p><p>The estimate is computed by finding the first integer <code>n</code> such that the quadrature error on the largest element <code>τ</code> lies below <code>tol</code> for points <code>x</code> satisfying <code>dist(x,center(τ)) = n*radius(τ)</code>.</p><p>Note that the desired tolerance may not be achievable if the quadrature rule is not accurate enough, or if <code>τ</code> is not sufficiently small, and therefore a maximum number of iterations <code>maxiter</code> is provided to avoid an infinite loops. In such cases, it is recommended that you either increase the quadrature order, or decrease the mesh size.</p><p><strong>Note</strong>: this is obviously a heuristic, and may not be accurate in all cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/nystrom.jl#L201-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.fibonnaci_points_sphere-Tuple{Any, Any, Any}" href="#Inti.fibonnaci_points_sphere-Tuple{Any, Any, Any}"><code>Inti.fibonnaci_points_sphere</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fibonnaci_points_sphere(N,r,c)</code></pre><p>Return <code>N</code> points distributed (roughly) in a uniform manner on the sphere of radius <code>r</code> centered at <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L150-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.flip_normal-Tuple{Inti.QuadratureNode}" href="#Inti.flip_normal-Tuple{Inti.QuadratureNode}"><code>Inti.flip_normal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flip_normal(q::QuadratureNode)</code></pre><p>Return a new <code>QuadratureNode</code> with the normal vector flipped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/quadrature.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.gauss_curvature-Tuple{Inti.Quadrature}" href="#Inti.gauss_curvature-Tuple{Inti.Quadrature}"><code>Inti.gauss_curvature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gauss_curvature(Q::Quadrature)</code></pre><p>Compute the <code>gauss_curvature</code> at each quadrature node in <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/quadrature.jl#L329-L333">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.gauss_curvature-Tuple{Inti.ReferenceInterpolant, Any}" href="#Inti.gauss_curvature-Tuple{Inti.ReferenceInterpolant, Any}"><code>Inti.gauss_curvature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gauss_curvature(τ, x̂)</code></pre><p>Calculate the <a href="https://en.wikipedia.org/wiki/Gaussian_curvature">Gaussian curvature</a> of the element <code>τ</code> at the parametric coordinate <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L93-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.geometric_dimension" href="#Inti.geometric_dimension"><code>Inti.geometric_dimension</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geometric_dimension(x)</code></pre><p>NNumber of degrees of freedom necessary to locally represent the geometrical object. For example, lines have geometric dimension of 1 (whether in <code>ℝ²</code> or in <code>ℝ³</code>), while surfaces have geometric dimension of 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.global_get_entity-Tuple{Inti.EntityKey}" href="#Inti.global_get_entity-Tuple{Inti.EntityKey}"><code>Inti.global_get_entity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">global_get_entity(k::EntityKey)</code></pre><p>Retrieve the <a href="#Inti.GeometricEntity"><code>GeometricEntity</code></a> corresponding to the <a href="#Inti.EntityKey"><code>EntityKey</code></a> <code>k</code> from the global <code>ENTITIES</code> dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/entities.jl#L306-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.gmsh_curve-Tuple" href="#Inti.gmsh_curve-Tuple"><code>Inti.gmsh_curve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gmsh_curve(f::Function, a, b; npts=100, meshsize = 0, tag=-1)</code></pre><p>Create a curve in the current <code>gmsh</code> model given by <code>{f(t) : t ∈ (a,b) }</code> where <code>f</code> is a function from <code>ℝ</code> to <code>ℝ^3</code>. The curve is approximated by C² b-splines passing through <code>npts</code> equispaced in parameter space. If a <code>meshsize</code> is given, <code>gmsh</code> will use it when meshing the curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/gmsh_api.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.hessian-Tuple{Inti.ReferenceInterpolant, Any}" href="#Inti.hessian-Tuple{Inti.ReferenceInterpolant, Any}"><code>Inti.hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hesssian(el,x)</code></pre><p>Given a (possibly vector-valued) functor <code>f : 𝐑ᵐ → 𝐅ⁿ</code>, return the <code>n × m × m</code> matrix <code>Aᵢⱼⱼ = ∂²fᵢ/∂xⱼ∂xⱼ</code>. By default <code>ForwardDiff</code> is used to compute the hessian, but you should overload this method for specific <code>f</code> if better performance and/or precision is required.</p><p>Note: both <code>x</code> and <code>f(x)</code> are expected to be of <code>SVector</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L41-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.image" href="#Inti.image"><code>Inti.image</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">image(f)</code></pre><p>Given a function-like object <code>f: Ω → R</code>, return <code>f(Ω)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.import_mesh-Tuple" href="#Inti.import_mesh-Tuple"><code>Inti.import_mesh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">import_mesh(filename = nothing; dim=3)</code></pre><p>Open <code>filename</code> and create a <a href="#Inti.Mesh"><code>Mesh</code></a> from the <code>gmsh</code> model in it.</p><p>If <code>filename</code> is <code>nothing</code>, the current <code>gmsh</code> model is used. Note that this assumes that the <em>Gmsh</em> API has been initialized through <code>gmsh.initialize</code>.</p><p>Passing <code>dim=2</code> will create a two-dimensional mesh by projecting the original mesh onto the <code>x,y</code> plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/gmsh_api.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.integrate-Tuple{Any, Inti.Quadrature}" href="#Inti.integrate-Tuple{Any, Inti.Quadrature}"><code>Inti.integrate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate(f,quad::Quadrature)</code></pre><p>Compute <code>∑ᵢ f(qᵢ)wᵢ</code>, where the <code>qᵢ</code> are the quadrature nodes of <code>quad</code>, and <code>wᵢ</code> are the quadrature weights.</p><p>Note that you must define <code>f(::QuadratureNode)</code>: use <code>q.coords</code> and <code>q.normal</code> if you need to access the coordinate or normal vector at que quadrature node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/quadrature.jl#L237-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.integrate-Tuple{Any, Inti.ReferenceQuadrature}" href="#Inti.integrate-Tuple{Any, Inti.ReferenceQuadrature}"><code>Inti.integrate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate(f,q::ReferenceQuadrature)
integrate(f,x,w)</code></pre><p>Integrate the function <code>f</code> using the quadrature rule <code>q</code>. This is simply <code>sum(f.(x) .* w)</code>, where <code>x</code> and <code>w</code> are the quadrature nodes and weights, respectively.</p><p>The function <code>f</code> should take an <code>SVector</code> as input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L38-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.integrate_with_error_estimate" href="#Inti.integrate_with_error_estimate"><code>Inti.integrate_with_error_estimate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate_with_error_estimate(f, quad::EmbeddedQuadrature, norm = LinearAlgebra.norm)</code></pre><p>Return <code>I, E</code> where <code>I</code> is the estimated integral of <code>f</code> over <code>domain(quad)</code> using the high-order quadrature and <code>E</code> is the error estimate obtained by taking the <code>norm</code> of the difference between the high and low-order quadratures in <code>quad</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L360-L367">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.integration_measure-Tuple{Any, Any}" href="#Inti.integration_measure-Tuple{Any, Any}"><code>Inti.integration_measure</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integration_measure(f, x̂)</code></pre><p>Given the Jacobian matrix <code>J</code> of a transformation <code>f : ℝᴹ → ℝᴺ</code> compute the integration measure <code>√det(JᵀJ)</code> at the parametric coordinate <code>x̂</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.interface_method-Tuple{DataType}" href="#Inti.interface_method-Tuple{DataType}"><code>Inti.interface_method</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interface_method(x)</code></pre><p>A method of an <code>abstract type</code> for which concrete subtypes are expected to provide an implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.internal_boundary-Tuple{Inti.Domain}" href="#Inti.internal_boundary-Tuple{Inti.Domain}"><code>Inti.internal_boundary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">internal_boundary(Ω::Domain)</code></pre><p>Return the internal boundaries of a <code>Domain</code>. These are entities in <code>skeleton(Ω)</code> which appear at least twice as a boundary of entities in <code>Ω</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/domain.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.interpolation_order-Tuple{Inti.ReferenceQuadrature{Inti.ReferenceHyperCube{1}}}" href="#Inti.interpolation_order-Tuple{Inti.ReferenceQuadrature{Inti.ReferenceHyperCube{1}}}"><code>Inti.interpolation_order</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolation_order(qrule::ReferenceQuadrature)</code></pre><p>The interpolation order of a quadrature rule is defined as the the smallest <code>k</code> such that there exists a unique polynomial in <code>PolynomialSpace{D,k}</code> that minimizes the error in approximating the function <code>f</code> at the quadrature nodes.</p><p>For an <code>N</code>-point Gauss quadrature rule on the segment, the interpolation order is <code>N-1</code> since <code>N</code> points uniquely determine a polynomial of degree <code>N-1</code>.</p><p>For a triangular reference domain, the interpolation order is more difficult to define. An unisolvent three-node quadrature on the triangular, for example, has an interpolation order <code>k=1</code> since the three nodes uniquely determine a linear polynomial, but a four-node quadrature may also have an interpolation order <code>k=1</code> since for <code>k=2</code> there are multiple polynomials that pass through the four nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L543-L560">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.jacobian-Tuple{Any, Any}" href="#Inti.jacobian-Tuple{Any, Any}"><code>Inti.jacobian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobian(f,x)</code></pre><p>Given a (possibly vector-valued) functor <code>f : 𝐑ᵐ → 𝐅ⁿ</code>, return the <code>n × m</code> matrix <code>Aᵢⱼ = ∂fᵢ/∂xⱼ</code>. By default <code>ForwardDiff</code> is used to compute the jacobian, but you should overload this method for specific <code>f</code> if better performance and/or precision is required.</p><p>Note: both <code>x</code> and <code>f(x)</code> are expected to be of <code>SVector</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L26-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.kress_change_of_variables-Tuple{Any}" href="#Inti.kress_change_of_variables-Tuple{Any}"><code>Inti.kress_change_of_variables</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kress_change_of_variables(P)</code></pre><p>Return a change of variables mapping <code>[0,1]</code> to <code>[0,1]</code> with the property that the first <code>P-1</code> derivatives of the transformation vanish at <code>x=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L412-L417">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.kress_change_of_variables_periodic-Tuple{Any}" href="#Inti.kress_change_of_variables_periodic-Tuple{Any}"><code>Inti.kress_change_of_variables_periodic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kress_change_of_variables_periodic(P)</code></pre><p>Like <a href="#Inti.kress_change_of_variables-Tuple{Any}"><code>kress_change_of_variables</code></a>, this change of variables maps the interval <code>[0,1]</code> onto itself, but the first <code>P</code> derivatives of the transformation vanish at <strong>both</strong> endpoints (thus making it a periodic function).</p><p>This change of variables can be used to <em>periodize</em> integrals over the interval <code>[0,1]</code> by mapping the integrand into a new integrand that vanishes (to order P) at both endpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L423-L433">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.lagrange_basis-Tuple{Any, Inti.PolynomialSpace}" href="#Inti.lagrange_basis-Tuple{Any, Inti.PolynomialSpace}"><code>Inti.lagrange_basis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lagrange_basis(nodes,[sp::AbstractPolynomialSpace])</code></pre><p>Return the set of <code>n</code> polynomials in <code>sp</code> taking the value of <code>1</code> on node <code>i</code> and <code>0</code> on nodes <code>j ≂̸ i</code> for <code>1 ≤ i ≤ n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/polynomials.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.lagrange_basis-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D" href="#Inti.lagrange_basis-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D"><code>Inti.lagrange_basis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lagrange_basis(qrule::ReferenceQuadrature)</code></pre><p>Return a function <code>L : ℝᴺ → ℝᵖ</code> where <code>N</code> is the dimension of the domain of <code>qrule</code>, and <code>p</code> is the number of nodes in <code>qrule</code>. The function <code>L</code> is a polynomial in <a href="#Inti.polynomial_space-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D"><code>polynomial_space(qrule)</code></a>, and <code>L(xⱼ)[i] = δᵢⱼ</code> (i.e. the <code>i</code>th component of <code>L</code> is the <code>i</code>th Lagrange basis).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L517-L524">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.lagrange_basis-Union{Tuple{Type{Inti.LagrangeElement{D, N, T}}}, Tuple{T}, Tuple{N}, Tuple{D}} where {D, N, T}" href="#Inti.lagrange_basis-Union{Tuple{Type{Inti.LagrangeElement{D, N, T}}}, Tuple{T}, Tuple{N}, Tuple{D}} where {D, N, T}"><code>Inti.lagrange_basis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lagrange_basis(E::Type{&lt;:LagrangeElement})</code></pre><p>Return the Lagrange basis <code>B</code> for the element <code>E</code>. Evaluating <code>B(x)</code> yields the value of each basis function at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L546-L551">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.line-Tuple{Any, Any}" href="#Inti.line-Tuple{Any, Any}"><code>Inti.line</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">line(a,b)</code></pre><p>Create a [<code>GeometricEntity</code>] representing a straight line connecting points <code>a</code> and <code>b</code>. The points <code>a</code> and <code>b</code> can be either <code>SVector</code>s or a <code>Tuple</code>.</p><p>The parametrization of the line is given by <code>f(u) = a + u(b - a)</code>, where <code>0 ≤ u ≤ 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/entities.jl#L165-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.mean_curvature-Tuple{Inti.Quadrature}" href="#Inti.mean_curvature-Tuple{Inti.Quadrature}"><code>Inti.mean_curvature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mean_curvature(Q::Quadrature)</code></pre><p>Compute the <code>mean_curvature</code> at each quadrature node in <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/quadrature.jl#L322-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.mean_curvature-Tuple{Inti.ReferenceInterpolant, Any}" href="#Inti.mean_curvature-Tuple{Inti.ReferenceInterpolant, Any}"><code>Inti.mean_curvature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mean_curvature(τ, x̂)</code></pre><p>Calculate the <a href="https://en.wikipedia.org/wiki/Mean_curvature">mean curvature</a> of the element <code>τ</code> at the parametric coordinate <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.measure" href="#Inti.measure"><code>Inti.measure</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measure(k::EntityKey, rtol)</code></pre><p>Compute the length/area/volume of the entity <code>k</code> using an adaptive quadrature with a relative tolerance <code>rtol</code>. Assumes that the entity has an explicit parametrization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/entities.jl#L141-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.meshgen!-Tuple{Inti.Mesh, Inti.Domain, Int64}" href="#Inti.meshgen!-Tuple{Inti.Mesh, Inti.Domain, Int64}"><code>Inti.meshgen!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">meshgen!(mesh,Ω,sz)</code></pre><p>Similar to <a href="#Inti.meshgen-Tuple{Inti.Domain, Vararg{Any}}"><code>meshgen</code></a>, but append entries to <code>mesh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/mesh.jl#L234-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.meshgen-Tuple{Inti.Domain, Vararg{Any}}" href="#Inti.meshgen-Tuple{Inti.Domain, Vararg{Any}}"><code>Inti.meshgen</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">meshgen(Ω, n; T = Float64)
meshgen(Ω, n_dict; T = Float64)
meshgen(Ω; meshsize, T = Float64)</code></pre><p>Generate a <code>Mesh</code> for the domain <code>Ω</code> where each curve is meshed using <code>n</code> elements. Passing a dictionary allows for a finer control; in such cases, <code>n_dict[ent]</code> should return an integer for each entity <code>ent</code> in <code>Ω</code> of <code>geometric_dimension</code> one.</p><p>Alternatively, a <code>meshsize</code> can be passed, in which case, the number of elements is computed as so as to obtain an <em>average</em> mesh size of <code>meshsize</code>. Note that the actual mesh size may vary significantly for each element if the parametrization is far from uniform.</p><p>The mesh is created with primitive data of type <code>T</code>.</p><p>This function requires the entities forming <code>Ω</code> to have an explicit parametrization.</p><div class="admonition is-warning"><header class="admonition-header">Mesh quality</header><div class="admonition-body"><p>The quality of the generated mesh created using <code>meshgen</code> depends on the quality of the underlying parametrization. For complex surfaces, you are better off using a proper mesher such as <code>gmsh</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/mesh.jl#L197-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.monomial_basis" href="#Inti.monomial_basis"><code>Inti.monomial_basis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">monomial_basis(sp::PolynomialSpace)</code></pre><p>Return a function <code>f : ℝᴺ → ℝᵈ</code>, where <code>N</code> is the dimension of the domain of <code>sp</code>     containing a basis of monomials <code>𝐱ᶿ</code> spanning the polynomial space <a href="#Inti.PolynomialSpace"><code>PolynomialSpace</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/polynomials.jl#L47-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.near_interaction_list-Union{Tuple{N}, Tuple{AbstractVector{&lt;:StaticArraysCore.SVector{N}}, Inti.AbstractMesh{N}}} where N" href="#Inti.near_interaction_list-Union{Tuple{N}, Tuple{AbstractVector{&lt;:StaticArraysCore.SVector{N}}, Inti.AbstractMesh{N}}} where N"><code>Inti.near_interaction_list</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">near_interaction_list(X,Y::AbstractMesh; tol)</code></pre><p>For each element <code>el</code> of type <code>E</code> in <code>Y</code>, return the indices of the points in <code>X</code> which are closer than <code>tol</code> to the <code>center</code> of <code>el</code>.</p><p>This function returns a dictionary where e.g. <code>dict[E][5] --&gt; Vector{Int}</code> gives the indices of points in <code>X</code> which are closer than <code>tol</code> to the center of the fifth element of type <code>E</code>.</p><p>If <code>tol</code> is a <code>Dict</code>, then <code>tol[E]</code> is the tolerance for elements of type <code>E</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/mesh.jl#L573-L584">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.new_tag-Tuple{Integer}" href="#Inti.new_tag-Tuple{Integer}"><code>Inti.new_tag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">new_tag(dim)</code></pre><p>Return a new tag for an entity of dimension <code>dim</code> so that <code>EntityKey(dim, tag)</code> is not already in <code>ENTITIES</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/entities.jl#L316-L321">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.nodes-Tuple{Inti.SubMesh}" href="#Inti.nodes-Tuple{Inti.SubMesh}"><code>Inti.nodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nodes(msh::SubMesh)</code></pre><p>A view of the nodes of the parent mesh belonging to the submesh. The ordering is given by the <a href="#Inti.nodetags-Tuple{Inti.SubMesh}"><code>nodetags</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/mesh.jl#L554-L559">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.nodetags-Tuple{Inti.SubMesh}" href="#Inti.nodetags-Tuple{Inti.SubMesh}"><code>Inti.nodetags</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nodetags(msh::SubMesh)</code></pre><p>Return the tags of the nodes in the parent mesh belonging to the submesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/mesh.jl#L540-L544">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.normal-Tuple{Any, Any}" href="#Inti.normal-Tuple{Any, Any}"><code>Inti.normal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normal(el, x̂)</code></pre><p>Return the normal vector of <code>el</code> at the parametric coordinate <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.normal-Tuple{T} where T" href="#Inti.normal-Tuple{T} where T"><code>Inti.normal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normal(q)</code></pre><p>Return the normal vector of <code>q</code>, if it exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/quadrature.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.notimplemented-Tuple{}" href="#Inti.notimplemented-Tuple{}"><code>Inti.notimplemented</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">notimplemented()</code></pre><p>Things which should probably be implemented at some point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L273-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.order-Union{Tuple{Inti.Fejer{N}}, Tuple{N}} where N" href="#Inti.order-Union{Tuple{Inti.Fejer{N}}, Tuple{N}} where N"><code>Inti.order</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">order(q::ReferenceQuadrature)</code></pre><p>A quadrature of order <code>p</code> (sometimes called degree of precision) integrates all polynomials of degree <code>≤ p</code> but not <code>≤ p + 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.order-Union{Tuple{Type{&lt;:Inti.LagrangeElement{D, Np}}}, Tuple{Np}, Tuple{D}} where {D, Np}" href="#Inti.order-Union{Tuple{Type{&lt;:Inti.LagrangeElement{D, Np}}}, Tuple{Np}, Tuple{D}} where {D, Np}"><code>Inti.order</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">order(el::LagrangeElement)</code></pre><p>The order of the element&#39;s interpolating polynomial (e.g. a <code>LagrangeLine</code> with <code>2</code> nodes defines a linear polynomial, and thus has order <code>1</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L258-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.parametric_curve-Union{Tuple{F}, Tuple{F, Real, Real}} where F" href="#Inti.parametric_curve-Union{Tuple{F}, Tuple{F, Real, Real}} where F"><code>Inti.parametric_curve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parametric_curve(f, a::Real, b::Real)</code></pre><p>Create a [<code>GeometricEntity</code>] representing a parametric curve defined by the <code>{f(t) | a ≤ t ≤ b}</code>. The function <code>f</code> should map a scalar to an <code>SVector</code>.</p><p>Flipping the orientation is supported by passing <code>a &gt; b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/entities.jl#L181-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.parametric_surface" href="#Inti.parametric_surface"><code>Inti.parametric_surface</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    parametric_surface(f, lc, hc, boundary = nothing; kwargs...)</code></pre><p>Create a parametric surface defined by the function <code>f</code> over the rectangular domain defined by the lower corner <code>lc</code> and the upper corner <code>hc</code>. The optional <code>boundary</code> argument can be used to specify the boundary curves of the surface.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: A function that takes two arguments <code>x</code> and <code>y</code> and returns a tuple <code>(u, v)</code>   representing the parametric coordinates of the surface at <code>(x, y)</code>.</li><li><code>lc</code>: A 2-element array representing the lower corner of the rectangular domain.</li><li><code>hc</code>: A 2-element array representing the upper corner of the rectangular domain.</li><li><code>boundary</code>: An optional array of boundary curves that define the surface.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>kwargs</code>: Additional keyword arguments that can be passed to the <code>GeometricEntity</code>   constructor.</li></ul><p><strong>Returns</strong></p><ul><li>The key of the created <code>GeometricEntity</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/entities.jl#L251-L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.polynomial_solutions_vdim" href="#Inti.polynomial_solutions_vdim"><code>Inti.polynomial_solutions_vdim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">polynomial_solutions_vdim(op, order[, center])</code></pre><p>For every monomial term <code>pₙ</code> of degree <code>order</code>, compute a polynomial <code>Pₙ</code> such that <code>ℒ[Pₙ] = pₙ</code>, where <code>ℒ</code> is the differential operator associated with <code>op</code>. This function returns <code>{pₙ,Pₙ,γ₁Pₙ}</code>, where <code>γ₁Pₙ</code> is the generalized Neumann trace of <code>Pₙ</code>.</p><p>Passing a point <code>center</code> will shift the monomials and solutions accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/vdim.jl#L297-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.polynomial_space-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D" href="#Inti.polynomial_space-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D"><code>Inti.polynomial_space</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">polynomial_space(qrule::ReferenceQuadrature)</code></pre><p>Return a <a href="#Inti.PolynomialSpace"><code>PolynomialSpace</code></a> associated with the <a href="#Inti.interpolation_order-Tuple{Inti.ReferenceQuadrature{Inti.ReferenceHyperCube{1}}}"><code>interpolation_order</code></a> of the quadrature nodes of <code>qrule</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L532-L537">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.qcoords-Tuple{Inti.ReferenceQuadrature}" href="#Inti.qcoords-Tuple{Inti.ReferenceQuadrature}"><code>Inti.qcoords</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qcoords(q)</code></pre><p>Return the coordinate of the quadrature nodes associated with <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.quadrature_to_node_vals-Tuple{Inti.Quadrature, AbstractVector}" href="#Inti.quadrature_to_node_vals-Tuple{Inti.Quadrature, AbstractVector}"><code>Inti.quadrature_to_node_vals</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quadrature_to_node_vals(Q::Quadrature, qvals::AbstractVector)</code></pre><p>Given a vector <code>qvals</code> of scalar values at the quadrature nodes of <code>Q</code>, return a vector <code>ivals</code> of scalar values at the interpolation nodes of <code>Q.mesh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/quadrature.jl#L296-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.qweights-Tuple{Inti.ReferenceQuadrature}" href="#Inti.qweights-Tuple{Inti.ReferenceQuadrature}"><code>Inti.qweights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qweights(q)</code></pre><p>Return the quadrature weights associated with <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_integration.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.reference_nodes-Tuple{Inti.LagrangeElement}" href="#Inti.reference_nodes-Tuple{Inti.LagrangeElement}"><code>Inti.reference_nodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reference_nodes(el::LagrangeElement)
reference_nodes(::Type{&lt;:LagrangeElement})</code></pre><p>Return the reference nodes on <code>domain(el)</code> used for the polynomial interpolation. The function values on these nodes completely determines the interpolating polynomial.</p><p>We use the same convention as <code>gmsh</code> for defining the reference nodes and their order (see <a href="https://gmsh.info/doc/texinfo/gmsh.html#Node-ordering">node ordering</a> on <code>gmsh</code> documentation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L226-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.return_type-Tuple{Any, Vararg{Any}}" href="#Inti.return_type-Tuple{Any, Vararg{Any}}"><code>Inti.return_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">return_type(f[,args...])</code></pre><p>The type returned by <code>f(args...)</code>, where <code>args</code> is a tuple of types. Falls back to <code>Base.promote_op</code> by default.</p><p>A functors of type <code>T</code> with a knonw return type should extend <code>return_type(::T,args...)</code> to avoid relying on <code>promote_op</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L52-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.rotation_matrix-Tuple{Any}" href="#Inti.rotation_matrix-Tuple{Any}"><code>Inti.rotation_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotation_matrix(rot)</code></pre><p>Constructs a rotation matrix given the rotation angles around the x, y, and z axes.</p><p><strong>Arguments</strong></p><ul><li><code>rot</code>: A tuple or vector containing the rotation angles in radians for each axis.</li></ul><p><strong>Returns</strong></p><ul><li><code>R::SMatrix</code>: The resulting rotation matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L377-L389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.single_double_layer-Tuple{}" href="#Inti.single_double_layer-Tuple{}"><code>Inti.single_double_layer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">single_double_layer(; op, target, source::Quadrature, compression,
correction, derivative = false)</code></pre><p>Construct a discrete approximation to the single- and double-layer integral operators for <code>op</code>, mapping values defined on the quadrature nodes of <code>source</code> to values defined on the nodes of <code>target</code>. If <code>derivative = true</code>, return instead the adjoint double-layer and hypersingular operators (which are the derivative of the single- and double-layer, respectively).</p><p>You  must choose a <code>compression</code> method and a <code>correction</code> method, as described below.</p><p><strong>Compression</strong></p><p>The <code>compression</code> argument is a named tuple with a <code>method</code> field followed by method-specific fields. It specifies how the dense linear operators should be compressed. The available options are:</p><ul><li><code>(method = :none, )</code>: no compression is performed, the resulting matrices are dense.</li><li><code>(method =:hmatrix, tol)</code>: the resulting operators are compressed using hierarchical matrices with an absolute tolerance <code>tol</code> (defaults to <code>1e-8</code>).</li><li><code>(method = :fmm, tol)</code>: the resulting operators are compressed using the fast multipole method with an absolute tolerance <code>tol</code> (defaults to <code>1e-8</code>).</li></ul><p><strong>Correction</strong></p><p>The <code>correction</code> argument is a named tuple with a <code>method</code> field followed by method-specific fields. It specifies how the singular and nearly-singular integrals should be computed. The available options are:</p><ul><li><code>(method = :none, )</code>: no correction is performed. This is not recommented, as the resulting approximation will be inaccurate if the source and target are not sufficiently far apart.</li><li><code>(method = :dim, maxdist, target_location)</code>: use the density interpolation method to compute the correction. <code>maxdist</code> specifies the distance between source and target points above which no correction is performed (defaults to <code>Inf</code>). <code>target_location</code> should be either <code>:inside</code>, <code>:outside</code>, or <code>:on</code>, and specifies where the <code>target</code><code>points lie relative to the to the</code>source<code>curve/surface (which is assumed to be closed). When</code>target === source<code>,</code>target_location` is not needed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/api.jl#L16-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.single_double_layer_potential-Tuple{}" href="#Inti.single_double_layer_potential-Tuple{}"><code>Inti.single_double_layer_potential</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">single_double_layer_potential(; op, source)</code></pre><p>Return the single- and double-layer potentials for <code>op</code> as <a href="#Inti.IntegralPotential"><code>IntegralPotential</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/api.jl#L209-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.skeleton-Tuple{Inti.Domain}" href="#Inti.skeleton-Tuple{Inti.Domain}"><code>Inti.skeleton</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">skeleton(Ω::Domain)</code></pre><p>Return all the boundaries of the domain, i.e. the domain&#39;s skeleton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/domain.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.stack_weakdeps_env!-Tuple{}" href="#Inti.stack_weakdeps_env!-Tuple{}"><code>Inti.stack_weakdeps_env!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stack_weakdeps_env!(; verbose = false, update = false)</code></pre><p>Push to the load stack an environment providing the weak dependencies of Inti.jl. This allows benefiting from additional functionalities of Inti.jl which are powered by weak dependencies without having to manually install them in your environment.</p><p>Set <code>update=true</code> if you want to update the <code>weakdeps</code> environment.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Calling this function can take quite some time, especially the first time around, if packages have to be installed or precompiled. Run in <code>verbose</code> mode to see what is happening.</p></div></div><p><strong>Examples:</strong></p><pre><code class="language-example hljs">Inti.stack_weakdeps_env!()
using HMatrices</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L318-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.standard_basis_vector-Union{Tuple{N}, Tuple{Any, Val{N}}} where N" href="#Inti.standard_basis_vector-Union{Tuple{N}, Tuple{Any, Val{N}}} where N"><code>Inti.standard_basis_vector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">standard_basis_vector(k, ::Val{N})</code></pre><p>Create an <code>SVector</code> of length N with a 1 in the kth position and zeros elsewhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.svector-Union{Tuple{F}, Tuple{F, Any}} where F" href="#Inti.svector-Union{Tuple{F}, Tuple{F, Any}} where F"><code>Inti.svector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svector(f,n)</code></pre><p>Create an <code>SVector</code> of length n, computing each element as f(i), where i is the index of the element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.torus-Tuple{}" href="#Inti.torus-Tuple{}"><code>Inti.torus</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">torus(; r, R, translation, rotation, scaling, labels)</code></pre><p>Create a torus entity in 3D, and apply optional transformations. Returns the key. The parameters <code>r</code> and <code>R</code> are the inner and outer radii of the torus.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/simpleshapes.jl#L91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.uniform_points_circle-Tuple{Any, Any, Any}" href="#Inti.uniform_points_circle-Tuple{Any, Any, Any}"><code>Inti.uniform_points_circle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uniform_points_circle(N,r,c)</code></pre><p>Return <code>N</code> points uniformly distributed on a circle of radius <code>r</code> centered at <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/utils.jl#L135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.vdim_correction-Union{Tuple{SHIFT}, Tuple{Any, Any, Inti.Quadrature, Inti.Quadrature, Any, Any, Any}} where SHIFT" href="#Inti.vdim_correction-Union{Tuple{SHIFT}, Tuple{Any, Any, Inti.Quadrature, Inti.Quadrature, Any, Any, Any}} where SHIFT"><code>Inti.vdim_correction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vdim_correction(op,X,Y,Y_boundary,S,D,V; green_multiplier, kwargs...)</code></pre><p>Compute a correction to the volume potential <code>V : Y → X</code> such that <code>V + δV</code> is a more accurate approximation of the underlying volume potential operator. The correction is computed using the (volume) density interpolation method.</p><p>This function requires a <code>op::AbstractDifferentialOperator</code>, a target set <code>X</code>, a source quadrature <code>Y</code>, a boundary quadrature <code>Y_boundary</code>, approximations <code>S : Y_boundary -&gt; X</code> and <code>D : Y_boundary -&gt; X</code> to the single- and double-layer potentials (correctly handling nearly-singular integrals), and a naive approximation of the volume potential <code>V</code>. The <code>green_multiplier</code> is a vector of the same length as <code>X</code> storing the value of <code>μ(x)</code> for <code>x ∈ X</code> in the Green identity (see <a href="#Inti._green_multiplier-Tuple{Symbol}"><code>_green_multiplier</code></a>).</p><p>See [<a href="../references/#anderson2024fast">8</a>] for more details on the method.</p><p><strong>Optional <code>kwargs</code>:</strong></p><ul><li><code>interpolation_order</code>: the order of the polynomial interpolation. By default, the maximum order of the quadrature rules is used.</li><li><code>maxdist</code>: distance beyond which interactions are considered sufficiently far so that no correction is needed. This is used to determine a threshold for nearly-singular corrections.</li><li><code>center</code>: the center of the basis functions. By default, the basis functions are centered at the origin.</li><li><code>shift</code>: a boolean indicating whether the basis functions should be shifted and rescaled to each element.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/vdim.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.vdim_mesh_center-Tuple{Inti.AbstractMesh}" href="#Inti.vdim_mesh_center-Tuple{Inti.AbstractMesh}"><code>Inti.vdim_mesh_center</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vdim_mesh_center(msh)</code></pre><p>Point <code>x</code> which minimizes ∑ (x-xⱼ)²/r²ⱼ, where xⱼ and rⱼ are the circumcenter and circumradius of the elements of <code>msh</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/vdim.jl#L275-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.vertices-Tuple{Inti.LagrangeElement}" href="#Inti.vertices-Tuple{Inti.LagrangeElement}"><code>Inti.vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertices(el::LagrangeElement)</code></pre><p>Coordinates of the vertices of <code>el</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L349-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.vertices_idxs-Tuple{Type{&lt;:Inti.LagrangeElement{Inti.ReferenceHyperCube{1}}}}" href="#Inti.vertices_idxs-Tuple{Type{&lt;:Inti.LagrangeElement{Inti.ReferenceHyperCube{1}}}}"><code>Inti.vertices_idxs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertices_idxs(el::LagrangeElement)</code></pre><p>The indices of the nodes in <code>el</code> that define the vertices of the element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/reference_interpolation.jl#L337-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.volume_potential-Tuple{}" href="#Inti.volume_potential-Tuple{}"><code>Inti.volume_potential</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">volume_potential(; op, target, source::Quadrature, compression, correction)</code></pre><p>Compute the volume potential operator for a given PDE.</p><p><strong>Arguments</strong></p><ul><li><code>op</code>: The PDE (Partial Differential Equation) to solve.</li><li><code>target</code>: The target domain where the potential is computed.</li><li><code>source</code>: The source domain where the potential is generated.</li><li><code>compression</code>: The compression method to use for the potential operator.</li><li><code>correction</code>: The correction method to use for the potential operator.</li></ul><p><strong>Returns</strong></p><p>The volume potential operator <code>V</code> that represents the interaction between the target and source domains.</p><p><strong>Compression</strong></p><p>The <code>compression</code> argument is a named tuple with a <code>method</code> field followed by method-specific fields. It specifies how the dense linear operators should be compressed. The available options are:</p><ul><li><code>(method = :none, )</code>: no compression is performed, the resulting matrices are dense.</li><li><code>(method =:hmatrix, tol)</code>: the resulting operators are compressed using hierarchical matrices with an absolute tolerance <code>tol</code> (defaults to <code>1e-8</code>).</li><li><code>(method = :fmm, tol)</code>: the resulting operators are compressed using the fast multipole method with an absolute tolerance <code>tol</code> (defaults to <code>1e-8</code>).</li></ul><p><strong>Correction</strong></p><p>The <code>correction</code> argument is a named tuple with a <code>method</code> field followed by method-specific fields. It specifies how the singular and nearly-singular integrals should be computed. The available options are:</p><ul><li><code>(method = :none, )</code>: no correction is performed. This is not recommented, as the resulting approximation will be inaccurate if the source and target are not sufficiently far apart.</li><li><code>(method = :dim, maxdist, target_location)</code>: use the density interpolation method to compute the correction. <code>maxdist</code> specifies the distance between source and target points above which no correction is performed (defaults to <code>Inf</code>). <code>target_location</code> should be either <code>:inside</code>, <code>:outside</code>, or <code>:on</code>, and specifies where the <code>target</code><code>points lie relative to the to the</code>source<code>&#39;s boundary. When</code>target === source<code>,</code>target_location` is not needed.</li></ul><p><strong>Details</strong></p><p>The volume potential operator is computed by assembling the integral operator <code>V</code> using the single-layer kernel <code>G</code>. The operator <code>V</code> is then compressed using the specified compression method. If no compression is specified, the operator is returned as is. If a correction method is specified, the correction is computed and added to the compressed operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/23dc8a3e6165649005a855741744106b2f8db29f/src/api.jl#L223-L276">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../references/">« References</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Saturday 1 March 2025 00:33">Saturday 1 March 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

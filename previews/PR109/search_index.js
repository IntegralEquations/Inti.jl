var documenterSearchIndex = {"docs":
[{"location":"tutorials/solvers/#Linear-solvers","page":"Linear solvers","title":"Linear solvers","text":"","category":"section"},{"location":"tutorials/solvers/","page":"Linear solvers","title":"Linear solvers","text":"CurrentModule = Inti","category":"page"},{"location":"tutorials/solvers/","page":"Linear solvers","title":"Linear solvers","text":"warning: Work in progress\nThis tutorial is still a work in progress. We will update it with more details and examples in the future.","category":"page"},{"location":"tutorials/solvers/","page":"Linear solvers","title":"Linear solvers","text":"Inti.jl does not provide its own linear solvers, but relies on external libraries such as IterativeSolvers.jl or the LinearAlgebra standard library for the solving the linear systems that arise in the discretization of integral equations.","category":"page"},{"location":"references/","page":"References","title":"References","text":"CurrentModule = Inti","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"J.-C.¬†N√©d√©lec. Acoustic and electromagnetic equations: integral representations for harmonic problems. Vol.¬†144 (Springer, 2001).\n\n\n\nD.¬†Colton and R.¬†Kress. Integral equation methods in scattering theory (SIAM, 2013).\n\n\n\nM.¬†Bebendorf. Hierarchical matrices (Springer, 2008).\n\n\n\nW.¬†Hackbusch and others. Hierarchical matrices: algorithms and analysis. Vol.¬†49 (Springer, 2015).\n\n\n\nV.¬†Rokhlin. Rapid solution of integral equations of classical potential theory. Journal¬†of¬†computational¬†physics 60, 187‚Äì207 (1985).\n\n\n\nL.¬†Greengard and V.¬†Rokhlin. A fast algorithm for particle simulations. Journal¬†of¬†computational¬†physics 73, 325‚Äì348 (1987).\n\n\n\nL.¬†M.¬†Faria, C.¬†P√©rez-Arancibia and M.¬†Bonnet. General-purpose kernel regularization of boundary integral equations via density interpolation. Computer¬†Methods¬†in¬†Applied¬†Mechanics¬†and¬†Engineering 378, 113703 (2021).\n\n\n\nT.¬†G.¬†Anderson, M.¬†Bonnet, L.¬†M.¬†Faria and C.¬†P√©rez-Arancibia. Fast, high-order numerical evaluation of volume potentials via polynomial density interpolation. Journal¬†of¬†Computational¬†Physics, 113091 (2024).\n\n\n\n","category":"page"},{"location":"tutorials/layer_potentials/#Layer-potentials","page":"Layer potentials","title":"Layer potentials","text":"","category":"section"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"CurrentModule = Inti","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"note: Important points covered in this tutorial\nNearly singular evaluation of layer potentials\nCreating a smooth domain with splines using Gmsh's API\nPlotting values on a mesh","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"In this tutorial we focus on evaluating the layer potentials given a source density. This is a common post-processing task in boundary integral equation methods, and while most of it is straightforward, some subtleties arise when the target points are close to the boundary (nearly-singular integrals).","category":"page"},{"location":"tutorials/layer_potentials/#Integral-potentials","page":"Layer potentials","title":"Integral potentials","text":"","category":"section"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"IntegralPotential represent the following mathematical objects:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"mathcalPsigma(boldsymbolr) = int_Gamma K(boldsymbolr boldsymbolr) sigma(boldsymbolr)  dboldsymbolr","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"where K is the kernel of the operator, Gamma is the source's boundary, boldsymbolr not in Gamma is a target point, and sigma is the source density.","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"Here is a simple example of how to create a kernel representing a Laplace double-layer potential:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"using Inti, StaticArrays, LinearAlgebra\n# define a kernel function\nfunction K(target,source)\n    r = Inti.coords(target) - Inti.coords(source)\n    ny = Inti.normal(source)\n    return 1 / (2œÄ * norm(r)^2) * dot(r, ny)\nend\n# define a domain\nŒì = Inti.parametric_curve(s -> SVector(cos(2œÄ * s), sin(2œÄ * s)), 0, 1) |> Inti.Domain\n# and a quadrature of Œì\nQ = Inti.Quadrature(Œì; meshsize = 0.1, qorder = 5)\nùíÆ = Inti.IntegralPotential(K, Q)","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"If we have a source density sigma, defined on the quadrature nodes of Gamma, we can create a function that evaluates the layer potential at an arbitrary point:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"œÉ = map(q -> 1.0, Q)\nu = ùíÆ[œÉ]","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"u is now an anonymous function that evaluates the layer potential at any point:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"r = SVector(0.1, 0.2)\n@assert u(r) ‚âà -1 # hide\nu(r)","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"Although we created the single-layer potential for the Laplace kernel manually, it is often more convenient to use the single_layer_potential when working with a supported PDE, e.g.:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"op = Inti.Laplace(; dim = 2)\nùíÆ, ùíü = Inti.single_double_layer_potential(; op, source = Q)","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"creates the single and double layer potentials for the Laplace equation in 2D.","category":"page"},{"location":"tutorials/layer_potentials/#Direct-evaluation-of-layer-potentials","page":"Layer potentials","title":"Direct evaluation of layer potentials","text":"","category":"section"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"We now show how to evaluate the layer potentials of an exact solution on a mesh created through the Gmsh API. Do to so, let us first define the PDE:g","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"using Inti, StaticArrays, LinearAlgebra, Meshes, GLMakie, Gmsh\n# define the PDE\nk = 4œÄ\nop = Inti.Helmholtz(; dim = 2, k)","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"We will now use the gmsh_curve function to create a smooth domain of a kite using splines:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"gmsh.initialize()\nmeshsize = 2œÄ / k / 4\nkite = Inti.gmsh_curve(0, 1; meshsize) do s\n    SVector(0.25, 0.0) + SVector(cos(2œÄ * s) + 0.65 * cos(4œÄ * s[1]) - 0.65, 1.5 * sin(2œÄ * s))\nend\ncl = gmsh.model.occ.addCurveLoop([kite])\nsurf = gmsh.model.occ.addPlaneSurface([cl])\ngmsh.model.occ.synchronize()\ngmsh.model.mesh.generate(2)\nmsh = Inti.import_mesh(; dim = 2)\ngmsh.finalize()","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"tip: Tip\nThe GMSH API is a powerful tool to create complex geometries and meshes directly from Julia (the gmsh_curve function above is just a simple wrapper around some spline functionality). For more information, see the official documentation.","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"We can visualize the triangular mesh using:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"using Meshes, GLMakie\n# extract the domain Œ© from the mesh entities\nents = Inti.entities(msh)\nŒ© = Inti.Domain(e->Inti.geometric_dimension(e) == 2, ents)\nviz(msh[Œ©]; showsegments = true, axis = (aspect = DataAspect(), ))","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"For the purpose of testing the accuracy of the layer potential evaluation, we will construct an exact solution of the Helmholtz equation on the interior domain and plot it:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"# construct an exact interior solution as a sum of random plane waves\ndirs  = [SVector(cos(Œ∏), sin(Œ∏)) for Œ∏ in 2œÄ*rand(10)]\ncoefs = rand(ComplexF64, 10)\nu  =  (x)   -> sum(c*exp(im*k*dot(x, d)) for (c,d) in zip(coefs, dirs))\ndu =  (x,ŒΩ) -> sum(c*im*k*dot(d, ŒΩ)*exp(im*k*dot(x, d)) for (c,d) in zip(coefs, dirs))\n# plot the exact solution\nŒ©_msh = view(msh, Œ©)\ntarget = Inti.nodes(Œ©_msh)\nviz(Œ©_msh; showsegments = false, axis = (aspect = DataAspect(), ), color = real(u.(target)))","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"Since u satisfies the Helmholtz equation, we know that the following representation holds:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"u(boldsymbolr) = mathcalSgamma_1 u(boldsymbolr) - mathcalDgamma_0 u(boldsymbolr) quad boldsymbolr in Omega","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"where gamma_0 u and gamma_1 u are the respective Dirichlet and Neumann traces of u, and mathcalS and mathcalD are the respective single and double layer potentials over Gamma = partial Omega.","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"Let's compare next the exact solution with the layer potential evaluation, based on a quadrature of Gamma:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"Œì = Inti.boundary(Œ©)\nQ = Inti.Quadrature(view(msh,Œì); qorder = 5)\n# evaluate the layer potentials\nùíÆ, ùíü = Inti.single_double_layer_potential(; op, source = Q)\nŒ≥‚ÇÄu = map(q -> u(q.coords), Q)\nŒ≥‚ÇÅu = map(q -> du(q.coords, q.normal), Q)\nu‚Çï = x -> ùíÆ[Œ≥‚ÇÅu](x) - ùíü[Œ≥‚ÇÄu](x)\n# plot the error on the target nodes\ner_log10 = log10.(abs.(u.(target) - u‚Çï.(target)))\ncolorrange = extrema(er_log10)\nfig, ax, pl = viz(Œ©_msh;\n    color = er_log10,\n    colormap = :viridis,\n    colorrange,\n    axis = (aspect = DataAspect(),),\n    interpolate=true\n)\nColorbar(fig[1, 2]; label = \"log‚ÇÅ‚ÇÄ(error)\", colorrange)\nfig","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"We see a common pattern of potential evaluation: the error is small away from the boundary, but grows near it. This is due to the nearly-singular nature of the layer potential integrals, which can be mitigated by using a correction method that accounts for the singularity of the kernel as boldsymbolr to Gamma.","category":"page"},{"location":"tutorials/layer_potentials/#Near-field-correction-of-layer-potentials","page":"Layer potentials","title":"Near-field correction of layer potentials","text":"","category":"section"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"There are two cases where the direct evaluation of layer potentials is not recommended:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"When the target point is close to the boundary (nearly-singular integrals).\nWhen evaluation at many target points is desired (computationally burdensome)and take advantage of an acceleration routine.","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"In such contexts, it is recommended to use the single_double_layer function (alternately, one can directly assemble an IntegralOperator) with a correction, for the first case, and/or a compression (acceleration) method, for the latter case, as appropriate. Here is an example of how to use the FMM acceleration with a near-field correction to evaluate the layer potentials::","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"using FMM2D\nS, D = Inti.single_double_layer(; op, target, source = Q,\n    compression = (method = :fmm, tol = 1e-12),\n    correction = (method = :dim, target_location = :inside, maxdist = 0.2)\n)\ner_log10_cor = log10.(abs.(S*Œ≥‚ÇÅu - D*Œ≥‚ÇÄu - u.(target)))\ncolorrange = extrema(er_log10) # use scale without correction\nfig = Figure(resolution = (800, 400))\nax1 = Axis(fig[1, 1], aspect = DataAspect(), title = \"Naive evaluation\")\nviz!(Œ©_msh; color = er_log10, colormap = :viridis, colorrange,interpolate=true)\nax2 = Axis(fig[1, 2], aspect = DataAspect(), title = \"Nearfield correction\")\nviz!(Œ©_msh; color = er_log10_cor, colormap = :viridis, colorrange, interpolate=true)\nColorbar(fig[1, 3]; label = \"log‚ÇÅ‚ÇÄ(error)\", colorrange)\nfig","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"As can be seen, the near-field correction significantly reduces the error near the boundary, making if feasible to evaluate the layer potential near Gamma if necessary.","category":"page"},{"location":"tutorials/integral_operators/#Boundary-integral-operators","page":"Boundary integral operators","title":"Boundary integral operators","text":"","category":"section"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"CurrentModule = Inti","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"note: Important points covered in this tutorial\nDefine layer potentials and the four integral operators of Calder√≥n calculus\nConstruct block operators\nSet up a custom kernel","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"A central piece of integral equation methods is the efficient and accurate computation of integral operators. In the first part of this tutorial we will cover how to assemble and manipulate the four integral operators of Calder√≥n calculus, namely the single-layer, double-layer, hypersingular, and adjoint operators [1, 2], for some predefined kernels in Inti.jl. In the second part we will show how to extend the package to handle custom kernels.","category":"page"},{"location":"tutorials/integral_operators/#Predefined-kernels-and-integral-operators","page":"Boundary integral operators","title":"Predefined kernels and integral operators","text":"","category":"section"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"To simplify the construction of integral operators for some commonly used PDEs, Inti.jl defines a few AbstractDifferentialOperators types. For each of these PDEs, the package provides a SingleLayerKernel, DoubleLayerKernel, HyperSingularKernel, and AdjointDoubleLayerKernel that can be used to construct the corresponding kernel functions, e.g.:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"using Inti, StaticArrays, LinearAlgebra\nop = Inti.Helmholtz(; dim = 2, k = 2œÄ)\nG   = Inti.SingleLayerKernel(op)","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"Typically, we are not interested in the kernels themselves, but in the integral operators they define. Two functions, single_double_layer and adj_double_layer_hypersingular, are provided as a high-level syntax to construct the four integral operators of Calder√≥n calculus:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"Œì = Inti.parametric_curve(s -> SVector(cos(s), sin(s)), 0, 2œÄ) |> Inti.Domain\nQ = Inti.Quadrature(Œì; meshsize = 0.1, qorder = 5)\nS, D = Inti.single_double_layer(; \n    op, \n    target = Q, \n    source = Q, \n    compression = (method = :none,), \n    correction = (method = :dim,)\n)\nK, N = Inti.adj_double_layer_hypersingular(; \n    op, \n    target = Q, \n    source = Q, \n    compression = (method = :none,), \n    correction = (method = :dim,)\n)\nnothing # hide","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"Much goes on under the hood in the function above, and the sections on correction and compression methods will provide more details on the options available. The important thing to keep in mind is that S, D, K, and N are discrete approximations of the following (linear) operators:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"beginaligned\n    Ssigma(boldsymbolx) = int_Gamma G(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly quad \n    Dsigma(boldsymbolx) = mathrmpv int_Gamma fracpartial Gpartial nu_boldsymboly(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly \n    Ksigma(boldsymbolx) =  mathrmpv int_Gamma fracpartial Gpartial nu_boldsymbolx(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly quad\n    Nsigma(boldsymbolx) = mathrmfp int_Gamma fracpartial^2 Gpartial nu_boldsymbolx partial nu_boldsymboly(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly\nendaligned","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"The actual type of S, D, K, and N depends on the compression and correction methods. In the simple case above, these are simply matrices:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"@assert all(T -> T == Matrix{ComplexF64}, map(typeof, (S, D, K, N))) # hide\nmap(typeof, (S, D, K, N))","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"If we turn on a compression method, such as :fmm, the types may change into something different:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"using FMM2D # will load the extension\nSfmm, Dfmm = Inti.single_double_layer(; \n    op, \n    target = Q, \n    source = Q, \n    compression = (method = :fmm, tol = 1e-10), \n    correction = (method = :dim, )\n)\nKfmm, Nfmm = Inti.adj_double_layer_hypersingular(; \n    op, \n    target = Q, \n    source = Q, \n    compression = (method = :fmm, tol = 1e-10), \n    correction = (method = :dim,)\n)\ntypeof(Sfmm)","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"This is because the FMM method is used to approximate the matrix-vector in a matrix-free way: the only thing guaranteed is that S and D can be applied to a vector:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"x = map(q -> cos(q.coords[1] + q.coords[2]), Q)\n@assert norm(Sfmm*x - S*x, Inf) / norm(S*x, Inf) < 1e-8 # hide\nnorm(Sfmm*x - S*x, Inf)","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"The Sfmm object above in fact combines two linear maps:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"Sfmm","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"The FunctionMap computes a matrix-vector by performing a function call to the FMM2D library. The WrappedMap accounts for a sparse matrix used to correct for singular and nearly singular interactions. These two objects are added lazily using LinearMaps.","category":"page"},{"location":"tutorials/integral_operators/#Operator-composition","page":"Boundary integral operators","title":"Operator composition","text":"","category":"section"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"Effortlessly and efficiently composing operators is a powerful abstraction for integral equations, as it allows for the construction of complex systems from simple building blocks. To show this, let us show how to construct the Calder√≥n projectors:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"beginaligned\nH = beginbmatrix\n    -D  S \n    -N  K\nendbmatrix \nendaligned","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"As is well-known [1, Theorem 3.1.3], the operators C_pm = I2 pm H are the projectors (i.e. C_pm^2 = C_pm):","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"using LinearMaps\n# create the block operator\nH = [-Dfmm Sfmm; -Nfmm Kfmm]\nC‚Çä = I / 2 + H\nC‚Çã = I / 2 - H\n# define two density functions on Œì\nu = map(q -> cos(q.coords[1] + q.coords[2]), Q)\nv = map(q-> q.coords[1], Q)\nx = [u; v]\n# compute the error in the projector identity\ne‚Çä = norm(C‚Çä*(C‚Çä*x) - C‚Çä*x, Inf)\ne‚Çã = norm(C‚Çã*(C‚Çã*x) - C‚Çã*x, Inf)\n@assert e‚Çä < 1e-5 && e‚Çã < 1e-5 # hide\nprintln(\"projection error for C‚Çä: $e‚Çä\")\nprintln(\"projection error for C‚Çã: $e‚Çã\")","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"We see that the error in the projector identity is small, as expected. Note that such compositions are not limited to the Calder√≥n projectors, and can be used e.g. to construct the combined field integral equation (CFIE), or to compose a formulation with an operator preconditioner.","category":"page"},{"location":"tutorials/integral_operators/#Custom-kernels","page":"Boundary integral operators","title":"Custom kernels","text":"","category":"section"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"So far we have focused on problems for which Inti.jl provides predefined kernels, and used the high-level syntax of e.g. single_double_layer to construct the integral operators. We will now dig into the details of how to set up a custom kernel function, and how to build an integral operator from it.","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"note: Integral operators coming from PDEs\nIf the integral operator of interest arises from a PDE, it is recommended to define a new AbstractDifferentialOperator type, and implement the required methods for SingleLayerKernel, DoubleLayerKernel, AdjointDoubleLayerKernel, and HyperSingularKernel. This will enable the use of the high-level syntax for constructing boundary integral operators, as well as the use of the compression and correction methods specific to integral operators arising from PDEs.","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"For the sake of simplicity, let us consider the following kernel representing the half-space Dirichlet Green function for Helmholtz's equation in 2D:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"    G_D(boldsymbolx boldsymboly) = fraci4 H^(1)_0(k boldsymbolx - boldsymboly) - fraci4 H^(1)_0(k boldsymbolx - boldsymboly^*)","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"where boldsymboly^* = (y_1 -y_2). We can define this kernel as a","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"using SpecialFunctions # for hankelh1\nfunction helmholtz_kernel(target, source, k)\n    x, y  = Inti.coords(target), Inti.coords(source)\n    yc = SVector(y[1], -y[2])\n    d, dc  = norm(x-y), norm(x-yc)\n    # the singularity at x = y needs to be handled separately, so just put a zero\n    d == 0 ? zero(ComplexF64) : im / 4 * ( hankelh1(0, k * d) - hankelh1(0, k * dc))\nend","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"Let us now consider the integral operator S defined by:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"    Ssigma(boldsymbolx) = int_Gamma G_D(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly quad boldsymbolx in Gamma","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"We can represent S by an IntegralOperator type:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"k = 50œÄ\nŒª = 2œÄ/k\nmeshsize = Œª / 10\ngeo = Inti.parametric_curve(s -> SVector(cos(s), 2 + sin(s)), 0, 2œÄ)\nŒì = Inti.Domain(geo)\nmsh = Inti.meshgen(Œì; meshsize)\nQ = Inti.Quadrature(msh; qorder = 5)\n# create a local scope to capture `k`\nK = let k = k\n    (t,q) -> helmholtz_kernel(t,q,k)\nend\nSop = Inti.IntegralOperator(K, Q, Q)","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"note: Signature of custom kernels\nKernel functions passed to IntegralOperator should always take two arguments, target and source, which are both of QuadratureNode. This allows for extracting not only the coords of the nodes, but also the normal vector if needed (e.g. for double-layer or hypersingular kernels).","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"The approximation of Sop now involves two steps:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"build a dense operator S‚ÇÄ that efficiently computes the matrix-vector product Sop * x for any vector x\ncorrect for the inaccuracies of S‚ÇÄ due to singular/nearly-singular interactions by adding to it a correction matrix Œ¥S","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"For the first step, we will use a hierarchical matrix:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"using HMatrices\nS‚ÇÄ = Inti.assemble_hmatrix(Sop; rtol = 1e-4)","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"The correction matrix Œ¥S will be constructed using adaptive_correction:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"Œ¥S = Inti.adaptive_correction(Sop; tol = 1e-4, maxdist = 5*meshsize)","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"How exactly one adds S‚ÇÄ and Œ¥S to get the final operator depends on the intended usage. For instance, one can use the LinearMap type to simply add them lazily:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"using LinearMaps\nS = LinearMap(S‚ÇÄ) + LinearMap(Œ¥S)","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"Or, one can add Œ¥S to S‚ÇÄ to create a new object:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"S = S‚ÇÄ + Œ¥S","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"or if performance/memory is a concern, one may want to directly add Œ¥S to S‚ÇÄ in-place:","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"axpy!(1.0, Œ¥S, S‚ÇÄ)","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"All of these should give an identical matrix-vector product, but the latter two allow e.g. for the use of direct solvers though an LU factorization.","category":"page"},{"location":"tutorials/integral_operators/","page":"Boundary integral operators","title":"Boundary integral operators","text":"warning: Limitations\nIntegral operators defined from custom kernel functions do not support all the features of the predefined ones. In particular, some singular integration methods (e.g. the Density Interpolation Method) and acceleration routines (e.g. Fast Multipole Method) used to correct for singular and nearly singular integral operators, and to accelerate the matrix vector products, are only available for specific kernels. Check the corrections and compression for more details concerning which methods are compatible with custom kernels.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"(Image: Pluto notebook)","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"begin\n    import Pkg as _Pkg\n    haskey(ENV, \"PLUTO_PROJECT\") && _Pkg.activate(ENV[\"PLUTO_PROJECT\"])\n    using PlutoUI: TableOfContents\nend;","category":"page"},{"location":"pluto-examples/helmholtz_scattering/#Helmholtz-scattering","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"","category":"section"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"note: Important points covered in this example\nCreating a geometry using the Gmsh API\nAssembling integral operators and integral potentials\nSetting up a sound-soft problem in both 2 and 3 spatial dimensions\nUsing GMRES to solve the linear system\nExporting the solution to Gmsh for visualization","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"In this tutorial we will show how to solve an acoustic scattering problem in the context of Helmholtz equation. We will focus on a smooth sound-soft obstacle for simplicity, and introduce along the way the necessary techniques used to handle some difficulties encountered. We will use various packages throughout this example (including of course Inti.jl); if they are not on your environment, you can install them using ] add <package> in the REPL.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"In the following section, we will provide a brief mathematical description of the problem (valid in both 2 and 3 dimensions). We will tackle the two-dimensional problem first, for which we do not need to worry much about performance issues (e.g. compressing the integral operators). Finally, we present a three-dimensional example, where we will use HMatrices.jl to compress the underlying integral operators.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/#Sound-soft-problem","page":"Helmholtz scattering","title":"Sound-soft problem","text":"","category":"section"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"This example concerns the sound-soft acoustic scattering problem. Mathematically, this means solving an exterior problem governed by Helmholtz equation (time-harmonic acoustics) with a Dirichlet boundary condition. More precisely, letting Omega subset mathbbR^d be a bounded domain, and denoting by Gamma = partial Omega its boundary, we wish to solve","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Delta u + k^2 u = 0 quad texton quad mathbbR^d setminus barOmega","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"subject to Dirichlet boundary conditions on Gamma","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"\tu(boldsymbolx) = g(boldsymbolx) quad textfor quad boldsymbolx in Gamma","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"and the Sommerfeld radiation condition at infinity","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"\tlim_boldsymbolx to infty boldsymbolx^(d-1)2 left( fracpartial upartial boldsymbolx - i k u right) = 0","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Here g is a (given) boundary datum, and k is the constant wavenumber.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"For simplicity, we will take Gamma circle/sphere, and focus on the plane-wave scattering problem. This means we will seek a solution u of the form u = u_s + u_i, where u_i is a known incident field, and u_s is the scattered field we wish to compute.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"note: Complex geometries\nThe main reason for focusing on such a simple example is twofold. First, it alleviates the complexities associated with the mesh generation. Second, since exact solutions are known for this problem (in the form of a series), it is easy to assess the accuracy of the solution obtained. In practice, you can use the same techniques to solve the problem on more complex geometries by providing a .msh file containing the mesh.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Using the theory of boundary integral equations, we can express u_s as","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"\tu_s(boldsymbolr) = mathcalDsigma(boldsymbolr) - i k mathcalSsigma(boldsymbolr)","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"where mathcalS is the so-called single layer potential, mathcalD is the double-layer potential, and sigma  Gamma to mathbbC is a surface density. This is an indirect formulation (because sigma is an auxiliary density, not necessarily physical) commonly referred to as a combined field formulation. Taking the limit mathbbR^d setminus bar Omega ni x to Gamma, it can be shown that the following equation holds on Gamma:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"\tleft( fracmathrmI2 + mathrmD - i k mathrmS right)sigma = g","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"where mathrmI is the identity operator, and mathrmS and mathrmD are the single- and double-layer operators. This is the combined field integral equation that we will solve. The boundary data g is obtained by applying the sound-soft condition u=0 on Gamma, from which it readily follows that u_s = -u_i on Gamma.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We are now have the necessary background to solve this problem in both 2 and 3 spatial dimensions. Let's load Inti.jl as well as the required dependencies","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"using Inti\nusing LinearAlgebra\nusing StaticArrays\nusing Gmsh\nusing Meshes\nusing GLMakie\nusing SpecialFunctions\nusing GSL\nusing IterativeSolvers\nusing LinearMaps","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"and setup some of the (global) problem parameters:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"k = 4œÄ\nŒª = 2œÄ / k\nqorder = 4 # quadrature order\ngorder = 2 # order of geometrical approximation\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/#Two-dimensional-scattering","page":"Helmholtz scattering","title":"Two-dimensional scattering","text":"","category":"section"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We will use Gmsh API for creating .msh file containing the desired geometry and mesh. Here is a function to mesh the circle:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"function gmsh_circle(; name, meshsize, order = 1, radius = 1, center = (0, 0))\n    try\n        gmsh.initialize()\n        gmsh.model.add(\"circle-mesh\")\n        gmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\n        gmsh.option.setNumber(\"Mesh.MeshSizeMin\", meshsize)\n        gmsh.model.occ.addDisk(center[1], center[2], 0, radius, radius)\n        gmsh.model.occ.synchronize()\n        gmsh.model.mesh.generate(1)\n        gmsh.model.mesh.setOrder(order)\n        gmsh.write(name)\n    finally\n        gmsh.finalize()\n    end\nend\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Let us now use gmsh_circle to create a circle.msh file. As customary in wave-scattering problems, we will choose a mesh size that is proportional to wavelength:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"name = joinpath(@__DIR__, \"circle.msh\")\nmeshsize = Œª / 5\ngmsh_circle(; meshsize, order = gorder, name)","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We can now import the file and parse the mesh and domain information into Inti.jl using the import_mesh function:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Inti.clear_entities!() # empty the entity cache\nmsh = Inti.import_mesh(name; dim = 2)","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The code above will import the mesh with all of its geometrical entities. The dim=2 projects all points to two dimensions by ignoring the third component. To extract the domain Omega we need to filter the entities in the mesh; here we will simply filter them based on the geometric_dimension:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Œ© = Inti.Domain(e -> Inti.geometric_dimension(e) == 2, Inti.entities(msh))","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"To solve our boundary integral equation usign a Nystr√∂m method, we actually need a quadrature of our curve/surface (and possibly the normal vectors at the quadrature nodes). Once a mesh is available, creating a quadrature object can be done via the Quadrature constructor, which requires passing a mesh of the domain that one wishes to generate a quadrature for:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Œì = Inti.boundary(Œ©)\nŒì_msh = view(msh, Œì)\nQ = Inti.Quadrature(Œì_msh; qorder)\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"tip: Views of a mesh\nIn Inti.jl, you can use domain to create a view of a mesh containing only the elements in the domain. For example view(msh,Œì) will return an SubMesh type that you can use to iterate over the elements in the boundary of the disk without actually creating a new mesh. You can use msh[Œì], or collect(view(msh,Œì)) to create a new mesh containing only the elements and nodes in Œì.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The object Q now contains a quadrature (of order 4) that can be used to solve a boundary integral equation on Œì. As a sanity check, let's make sure integrating the function x->1 over Q gives an approximation to the perimeter:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"@assert abs(Inti.integrate(x -> 1, Q) - 2œÄ) < 1e-5","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"abs(Inti.integrate(x -> 1, Q) - 2œÄ)","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"With the Quadrature constructed, we now can define discrete approximation to the integral operators mathrmS and mathrmD as follows:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"op = Inti.Helmholtz(; k, dim = 2)\nS, D = Inti.single_double_layer(;\n    op,\n    target = Q,\n    source = Q,\n    compression = (method = :none,),\n    correction = (method = :dim,),\n)\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"There are two well-known difficulties related to the discretization of the boundary integral operators S and D:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The kernel of the integral operator is not smooth, and thus specialized quadrature rules are required to accurately approximate the matrix entries for which the target and source point lie close (relative to some scale) to each other.\nThe underlying matrix is dense, and thus the storage and computational cost of the operator is prohibitive for large problems unless acceleration techniques such as Fast Multipole Methods or Hierarchical Matrices are employed.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Inti.jl tries to provide a modular and transparent interface for dealing with both of these difficulties, where the general approach for solving a BIE will be to first construct a (possible compressed) naive representation of the integral operator where singular and nearly-singular integrals are ignored, followed by a the creation of a (sparse) correction intended to account for such singular interactions. See single_double_layer for more details on the various options available.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We can now combine S and D to form the combined-field operator:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"L = I / 2 + D - im * k * S\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"where I is the identity matrix. Assuming an incident field along the x_1 direction of the form u_i =e^ikx_1, the right-hand side of the equation can be construted using:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"u·µ¢ = x -> exp(im * k * x[1]) # plane-wave incident field\nrhs = map(Q) do q\n    x = q.coords\n    return -u·µ¢(x)\nend\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"note: Iterating over a quadrature\nIn computing rhs above, we used map to evaluate the incident field at all quadrature nodes. When iterating over Q, the iterator returns a QuadratureNode, and not simply the coordinate of the quadrature node. This is so that you can access additional information, such as the normal vector, at the quadrature node.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We can now solve the integral equation using e.g. the backslash operator:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"œÉ = L \\ rhs\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The variable œÉ contains the value of the approximate density at the quadrature nodes. To reconstruct a continuous approximation to the solution, we can use single_double_layer_potential to obtain the single- and double-layer potentials, and then combine them as follows:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"ùíÆ, ùíü = Inti.single_double_layer_potential(; op, source = Q)\nu‚Çõ = x -> ùíü[œÉ](x) - im * k * ùíÆ[œÉ](x)\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The variable u‚Çõ is an anonymous/lambda function representing the approximate scattered field.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"To assess the accuracy of the solution, we can compare it to the exact solution (obtained by separation of variables in polar coordinates):","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"function circle_helmholtz_soundsoft(pt; radius = 1, k, Œ∏in)\n    x = pt[1]\n    y = pt[2]\n    r = sqrt(x^2 + y^2)\n    Œ∏ = atan(y, x)\n    u = 0.0\n    r < radius && return u\n    c(n) = -exp(im * n * (œÄ / 2 - Œ∏in)) * besselj(n, k * radius) / besselh(n, k * radius)\n    u = c(0) * besselh(0, k * r)\n    n = 1\n    while (abs(c(n)) > 1e-12)\n        u +=\n            c(n) * besselh(n, k * r) * exp(im * n * Œ∏) +\n            c(-n) * besselh(-n, k * r) * exp(-im * n * Œ∏)\n        n += 1\n    end\n    return u\nend\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Here is the maximum error on some points located on a circle of radius 2:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"u‚Çë = x -> circle_helmholtz_soundsoft(x; k, radius = 1, Œ∏in = 0) # exact solution\ner = maximum(0:0.01:2œÄ) do Œ∏\n    R = 2\n    x = (R * cos(Œ∏), R * sin(Œ∏))\n    return abs(u‚Çõ(x) - u‚Çë(x))\nend\n@info \"maximum error = $er\"","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"@assert er < 1e-3","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"As we can see, the error is quite small! Let's use Makie to visualize the solution in this simple (2d) example:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"xx = yy = range(-4; stop = 4, length = 200)\nvals =\n    map(pt -> Inti.isinside(pt, Q) ? NaN : real(u‚Çõ(pt) + u·µ¢(pt)), Iterators.product(xx, yy))\nfig, ax, hm = heatmap(\n    xx,\n    yy,\n    vals;\n    colormap = :inferno,\n    interpolate = true,\n    axis = (aspect = DataAspect(), xgridvisible = false, ygridvisible = false),\n)\nviz!(Œì_msh; color = :white, segmentsize = 5)\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"While here we simply used a heatmap to visualize the solution, more complex problems may require a mesh-based visualization, where we would first create a mesh for the places where we want to visualize the solution.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Before moving on to the 3D example let us simply mention that, besides the fact that an analytic solution was available for comparisson, there was nothing special about the unit disk (or the use of GMSH). We could have, for instance, replaced the disk by shapes created parametrically:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"let\n    # vertices of an equilateral triangle centered at the origin with a vertex at (0,1)\n    a, b, c = SVector(0, 1), SVector(sqrt(3) / 2, -1 / 2), SVector(-sqrt(3) / 2, -1 / 2)\n    function circle_f(center, radius)\n        return s -> center + radius * SVector(cospi(2 * s[1]), sinpi(2 * s[1]))\n    end\n    disk1 = Inti.parametric_curve(circle_f(a, 1 / 2), 0, 1)\n    disk2 = Inti.parametric_curve(circle_f(b, 1 / 2), 0, 1)\n    disk3 = Inti.parametric_curve(circle_f(c, 1 / 2), 0, 1)\n    Œì = disk1 ‚à™ disk2 ‚à™ disk3\n    msh = Inti.meshgen(Œì; meshsize)\n    Œì_msh = view(msh, Œì)\n    Q = Inti.Quadrature(Œì_msh; qorder)\n    S, D = Inti.single_double_layer(;\n        op,\n        target = Q,\n        source = Q,\n        compression = (method = :none,),\n        correction = (method = :dim,),\n    )\n    L = I / 2 + D - im * k * S\n    rhs = map(q -> -u·µ¢(q.coords), Q)\n    œÉ = L \\ rhs\n    ùíÆ, ùíü = Inti.single_double_layer_potential(; op, source = Q)\n    u‚Çõ = x -> ùíü[œÉ](x) - im * k * ùíÆ[œÉ](x)\n    vals = map(\n        pt -> Inti.isinside(pt, Q) ? NaN : real(u‚Çõ(pt) + u·µ¢(pt)),\n        Iterators.product(xx, yy),\n    )\n    colorrange = (-2, 2)\n    fig, ax, hm = heatmap(\n        xx,\n        yy,\n        vals;\n        colormap = :inferno,\n        colorrange,\n        interpolate = true,\n        axis = (aspect = DataAspect(), xgridvisible = false, ygridvisible = false),\n    )\n    viz!(Œì_msh; color = :black, segmentsize = 4)\n    Colorbar(fig[1, 2], hm)\n    fig\nend","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"note: Near-field evaluation\nIn the example above we employed a naive evaluation of the integral potentials, and therefore the computed solution is expected to become innacurate near the obstacles. See the layer potential tutorial for more information on how to correct for this.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/#Three-dimensional-scattering","page":"Helmholtz scattering","title":"Three-dimensional scattering","text":"","category":"section"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We now consider the same problem in 3D. Unlike the 2D case, assembling dense matrix representations of the integral operators quickly becomes unfeasiable as the problem size increases. Inti adds support for compressing the underlying linear operators by wrapping external libraries. In this example, we will rely on HMatrices.jl to handle the compression.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The visualization is also more involved, and we will use the Gmsh API to create a not only a mesh of the scatterer, but also of a punctured plane where we will visualize the solution. Here is the function that setups up the mesh:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"function gmsh_sphere(; meshsize, order = gorder, radius = 1, visualize = false, name)\n    gmsh.initialize()\n    gmsh.model.add(\"sphere-scattering\")\n    gmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\n    gmsh.option.setNumber(\"Mesh.MeshSizeMin\", meshsize)\n    sphere_tag = gmsh.model.occ.addSphere(0, 0, 0, radius)\n    xl, yl, zl = -2 * radius, -2 * radius, 0\n    Œîx, Œîy = 4 * radius, 4 * radius\n    rectangle_tag = gmsh.model.occ.addRectangle(xl, yl, zl, Œîx, Œîy)\n    outDimTags, _ =\n        gmsh.model.occ.cut([(2, rectangle_tag)], [(3, sphere_tag)], -1, true, false)\n    gmsh.model.occ.synchronize()\n    gmsh.model.addPhysicalGroup(3, [sphere_tag], -1, \"omega\")\n    gmsh.model.addPhysicalGroup(2, [dt[2] for dt in outDimTags], -1, \"sigma\")\n    gmsh.model.mesh.generate(2)\n    gmsh.model.mesh.setOrder(order)\n    visualize && gmsh.fltk.run()\n    gmsh.option.setNumber(\"Mesh.SaveAll\", 1) # otherwise only the physical groups are saved\n    gmsh.write(name)\n    return gmsh.finalize()\nend\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"As before, lets write a file with our mesh, and import it into Inti.jl:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"name_sphere = joinpath(@__DIR__, \"sphere.msh\")\ngmsh_sphere(; meshsize = (Œª / 5), order = gorder, name = name_sphere, visualize = false)\nmsh_3d = Inti.import_mesh(name_sphere; dim = 3)","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"tip: Tip\nIf you pass visualize=true to gmsh_sphere, it will open a window with the current model. This is done by calling gmsh.fltk.run(). Note that the main julia thread will be blocked until the window is closed.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Since we created physical groups in Gmsh, we can use them to extract the relevant domains Œ© and Œ£:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Œ©_3d = Inti.Domain(e -> \"omega\" ‚àà Inti.labels(e), Inti.entities(msh_3d))\nŒ£_3d = Inti.Domain(e -> \"sigma\" ‚àà Inti.labels(e), Inti.entities(msh_3d))\nŒì_3d = Inti.boundary(Œ©_3d)\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We can now create a quadrature as before","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Œì_msh_3d = view(msh_3d, Œì_3d)\nQ_3d = Inti.Quadrature(Œì_msh_3d; qorder)\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"tip: Writing/reading a mesh from disk\nWriting and reading a mesh to/from disk can be time consuming. You can avoid doing so by using import_mesh without a file name to import the mesh from the current gmsh session without the need to write it to disk.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Next we assemble the integral operators, indicating that we wish to compress them using hierarchical matrices:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"using HMatrices\nop_3d = Inti.Helmholtz(; k, dim = 3)\nS_3d, D_3d = Inti.single_double_layer(;\n    op = op_3d,\n    target = Q_3d,\n    source = Q_3d,\n    compression = (method = :hmatrix, tol = 1e-4),\n    correction = (method = :dim,),\n)\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Here is how much memory it would take to store the dense representation of these matrices:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"mem = 2 * length(S_3d) * 16 / 1e9 # 16 bytes per complex number, 1e9 bytes per GB, two matrices\nprintln(\"memory required to store S and D: $(mem) GB\")","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Even for this simple example, the dense representation of the integral operators as matrix is already quite expensive!","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"note: Compression methods\nIt is worth mentioning that hierchical matrices are not the only way to compress such integral operators, and may in fact not even be the best for the problem at hand. For example, one could use a fast multipole method (FMM), which has a much lighter memory footprint. See the the tutorial on compression methods for more information.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We will use the generalized minimal residual (GMRES) iterative solver, for the linear system. This requires us to define a linear operator L, approximating the combined-field operator, that supports the matrix-vector product. While it is possible to add two HMatrix objects to obtain a new HMatrix, this is somewhat more involved due to the addition of low-rank blocks (which requires a recompression). To keep things simple, we will use LinearMaps to lazily compose the operators:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"L_3d = I / 2 + LinearMap(D_3d) - im * k * LinearMap(S_3d)\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We can now solve the linear system using GMRES solver:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"rhs_3d = map(Q_3d) do q\n    x = q.coords\n    return -u·µ¢(x)\nend\nœÉ_3d, hist = gmres(\n    L_3d,\n    rhs_3d;\n    log = true,\n    abstol = 1e-6,\n    verbose = false,\n    restart = 100,\n    maxiter = 100,\n)\n@show hist","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"As before, let us represent the solution using IntegralPotentials:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"ùíÆ_3d, ùíü_3d = Inti.single_double_layer_potential(; op = op_3d, source = Q_3d)\nu‚Çõ_3d = x -> ùíü_3d[œÉ_3d](x) - im * k * ùíÆ_3d[œÉ_3d](x)\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"To check the result, we compare against the exact solution obtained through a series:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"sphbesselj(l, r) = sqrt(œÄ / (2r)) * besselj(l + 1 / 2, r)\nsphbesselh(l, r) = sqrt(œÄ / (2r)) * besselh(l + 1 / 2, r)\nsphharmonic(l, m, Œ∏, œï) = GSL.sf_legendre_sphPlm(l, abs(m), cos(Œ∏)) * exp(im * m * œï)\nfunction sphere_helmholtz_soundsoft(xobs; radius = 1, k = 1, Œ∏in = 0, œïin = 0)\n    x = xobs[1]\n    y = xobs[2]\n    z = xobs[3]\n    r = sqrt(x^2 + y^2 + z^2)\n    Œ∏ = acos(z / r)\n    œï = atan(y, x)\n    u = 0.0\n    r < radius && return u\n    function c(l, m)\n        return -4œÄ * im^l * sphharmonic(l, -m, Œ∏in, œïin) * sphbesselj(l, k * radius) /\n               sphbesselh(l, k * radius)\n    end\n    l = 0\n    for l = 0:60\n        for m = -l:l\n            u += c(l, m) * sphbesselh(l, k * r) * sphharmonic(l, m, Œ∏, œï)\n        end\n        l += 1\n    end\n    return u\nend\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We will compute the error on some point on the sphere of radius 2:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"u‚Çë_3d = (x) -> sphere_helmholtz_soundsoft(x; radius = 1, k = k, Œ∏in = œÄ / 2, œïin = 0)\ner_3d = maximum(1:100) do _\n    xÃÇ = rand(Inti.Point3D) |> normalize # an SVector of unit norm\n    x = 2 * xÃÇ\n    return abs(u‚Çõ_3d(x) - u‚Çë_3d(x))\nend\n@info \"error with correction = $er_3d\"","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"@assert er_3d < 1e-3","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We see that, once again, the approximation is quite accurate. Let us now visualize the solution on the punctured plane (which we labeled as \"sigma\"). Since evaluating the integral representation of the solution at many points is expensive, we will use again use a method to accelerate the evaluation:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Œ£_msh = view(msh_3d, Œ£_3d)\ntarget = Inti.nodes(Œ£_msh)\n\nS_viz, D_viz = Inti.single_double_layer(;\n    op = op_3d,\n    target,\n    source = Q_3d,\n    compression = (method = :hmatrix, tol = 1e-4),\n    # correction for the nearfield (for visual purposes, set to `:none` to disable)\n    correction = (method = :dim, maxdist = meshsize, target_location = :outside),\n)\n\nui_eval_msh = u·µ¢.(target)\nus_eval_msh = D_viz * œÉ_3d - im * k * S_viz * œÉ_3d\nu_eval_msh = ui_eval_msh + us_eval_msh\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Finalize, we use Meshes.viz to visualize the scattered field:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"nv = length(Inti.nodes(Œì_msh_3d))\ncolorrange = extrema(real(u_eval_msh))\ncolormap = :inferno\nfig_3d = Figure(; size = (800, 500))\nax_3d = Axis3(fig_3d[1, 1]; aspect = :data)\nviz!(Œì_msh_3d; colorrange, colormap, color = zeros(nv), interpolate = true)\nviz!(Œ£_msh; colorrange, colormap, color = real(u_eval_msh))\ncb = Colorbar(fig_3d[1, 2]; label = \"real(u)\", colormap, colorrange)\nfig_3d #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"TableOfContents()","category":"page"},{"location":"pluto-examples/toy_example/","page":"Toy example","title":"Toy example","text":"(Image: Pluto notebook)","category":"page"},{"location":"pluto-examples/toy_example/","page":"Toy example","title":"Toy example","text":"begin\n    import Pkg as _Pkg\n    haskey(ENV, \"PLUTO_PROJECT\") && _Pkg.activate(ENV[\"PLUTO_PROJECT\"])\nend;","category":"page"},{"location":"pluto-examples/toy_example/#Toy-example","page":"Toy example","title":"Toy example","text":"","category":"section"},{"location":"pluto-examples/toy_example/","page":"Toy example","title":"Toy example","text":"All examples in Inti.jl are autogenerated by executing the make.jl script in the docs folder. The workflow uses Pluto.jl to generate markdown files passed to Documenter.jl. The original pluto notebook files are downloadable from the example's page.","category":"page"},{"location":"pluto-examples/toy_example/","page":"Toy example","title":"Toy example","text":"using Inti","category":"page"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"CurrentModule = Inti","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Modules = [Inti]","category":"page"},{"location":"docstrings/#Inti.Inti","page":"Docstrings","title":"Inti.Inti","text":"module Inti\n\nLibrary for solving integral equations using Nystr√∂m methods.\n\n\n\n\n\n","category":"module"},{"location":"docstrings/#Inti.COMPRESSION_METHODS","page":"Docstrings","title":"Inti.COMPRESSION_METHODS","text":"const COMPRESSION_METHODS = [:none, :hmatrix, :fmm]\n\nAvailable compression methods for the dense linear operators in Inti.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#Inti.CORRECTION_METHODS","page":"Docstrings","title":"Inti.CORRECTION_METHODS","text":"const CORRECTION_METHODS = [:none, :dim, :hcubature]\n\nAvailable correction methods for the singular and nearly-singular integrals in Inti.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#Inti.ENTITIES","page":"Docstrings","title":"Inti.ENTITIES","text":"const ENTITIES\n\nDictionary mapping EntityKey to GeometricEntity. Contains all entities created in a given session.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#Inti.SAME_POINT_TOLERANCE","page":"Docstrings","title":"Inti.SAME_POINT_TOLERANCE","text":"SAME_POINTS_TOLERANCE\n\nTwo points x and y are considerd the same if norm(x-y) ‚â§ SAME_POINT_TOLERANCE.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#Inti.AbstractDifferentialOperator","page":"Docstrings","title":"Inti.AbstractDifferentialOperator","text":"abstract type AbstractDifferentialOperator{N}\n\nA partial differential operator in dimension N.\n\nAbstractDifferentialOperator types are used to define AbstractKernels related to fundamental solutions of differential operators.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.AbstractKernel","page":"Docstrings","title":"Inti.AbstractKernel","text":"abstract type AbstractKernel{T}\n\nA kernel functions K with the signature K(target,source)::T.\n\nSee also: SingleLayerKernel, DoubleLayerKernel, AdjointDoubleLayerKernel, HyperSingularKernel\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.AbstractMesh","page":"Docstrings","title":"Inti.AbstractMesh","text":"abstract type AbstractMesh{N,T}\n\nAn abstract mesh structure in dimension N with primite data of type T (e.g. Float64 for double precision representation).\n\nConcrete subtypes of AbstractMesh should implement ElementIterator for accessing the mesh elements.\n\nSee also: Mesh\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.AdjointDoubleLayerKernel","page":"Docstrings","title":"Inti.AdjointDoubleLayerKernel","text":"struct AdjointDoubleLayerKernel{T,Op} <: AbstractKernel{T}\n\nGiven an operator Op, construct its free-space adjoint double-layer kernel. This corresponds to the transpose(Œ≥‚ÇÅ,‚Çì[G]), where G is the SingleLayerKernel. For operators such as Laplace or Helmholtz, this is simply the normal derivative of the fundamental solution respect to the target variable.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.BlockArray","page":"Docstrings","title":"Inti.BlockArray","text":"struct BlockArray{T<:StaticArray,N,S} <: AbstractMatrix{T,N}\n\nA struct which behaves like an  Array{T,N}, but with the underlying data stored as a Matrix{S}, where S::Number = eltype(T) is the scalar type associated with T. This allows for the use of blas routines under-the-hood, while providing a convenient interface for handling matrices over StaticArrays.\n\nusing StaticArrays\nT = SMatrix{2,2,Int,4}\nB = Inti.BlockArray{T}([i*j for i in 1:4, j in 1:4])\n\n# output\n\n2√ó2 Inti.BlockArray{SMatrix{2, 2, Int64, 4}, 2, Int64}:\n [1 2; 2 4]  [3 4; 6 8]\n [3 6; 4 8]  [9 12; 12 16]\n\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.DimParameters","page":"Docstrings","title":"Inti.DimParameters","text":"struct DimParameters\n\nParameters associated with the density interpolation method used in bdim_correction.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Domain","page":"Docstrings","title":"Inti.Domain","text":"struct Domain\n\nRepresentation of a geometrical domain formed by a set of entities with the same geometric dimension. For basic set operations on domains are supported (union, intersection, difference, etc), and they all return a new Domain object.\n\nCalling keys(Œ©) returns the set of EntityKeys that make up the domain; given a key, the underlying entities can be accessed with global_get_entity(key).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Domain-Tuple{Function, Any}","page":"Docstrings","title":"Inti.Domain","text":"Domain([f::Function,] keys)\n\nCreate a domain from a set of EntityKeys. Optionally, a filter function f can be passed to filter the entities.\n\nNote that all entities in a domain must have the same geometric dimension.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.Domain-Tuple{Function, Inti.AbstractMesh}","page":"Docstrings","title":"Inti.Domain","text":"Domain(f::Function, msh::AbstractMesh)\n\nCall Domain(f, ents) on ents = entities(msh).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.DoubleLayerKernel","page":"Docstrings","title":"Inti.DoubleLayerKernel","text":"struct DoubleLayerKernel{T,Op} <: AbstractKernel{T}\n\nGiven an operator Op, construct its free-space double-layer kernel. This corresponds to the Œ≥‚ÇÅ trace of the SingleLayerKernel. For operators such as Laplace or Helmholtz, this is simply the normal derivative of the fundamental solution respect to the source variable.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Elastostatic","page":"Docstrings","title":"Inti.Elastostatic","text":"struct Elastostatic{N,T} <: AbstractDifferentialOperator{N}\n\nElastostatic operator in N dimensions: -ŒºŒîu - (Œº+Œª)‚àá(‚àá‚ãÖu)\n\nNote that the displacement u is a vector of length N since this is a vectorial problem.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ElementIterator","page":"Docstrings","title":"Inti.ElementIterator","text":"struct ElementIterator{E,M} <: AbstractVector{E}\n\nStructure to lazily access elements of type E in a mesh of type M. This is particularly useful for LagrangeElements, where the information to reconstruct the element is stored in the mesh connectivity matrix.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.EmbeddedQuadrature","page":"Docstrings","title":"Inti.EmbeddedQuadrature","text":"struct EmbeddedQuadrature{L,H,D} <: ReferenceQuadrature{D}\n\nA quadrature rule for the reference shape D based on a high-order quadrature of type H and a low-order quadrature of type L. The low-order quadrature rule is embedded in the sense that its n nodes are exactly the first n nodes of the high-order quadrature rule.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.EntityKey","page":"Docstrings","title":"Inti.EntityKey","text":"EntityKey\n\nUsed to represent the key of a GeometricEntity, comprised of a dim and a tag field, where dim is the geometrical dimension of the entity, and tag is a unique integer identifying the entity.\n\nThe sign of the tag field is used to distinguish the orientation of the entity, and is ignored when comparing two EntityKeys for equality.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Fejer","page":"Docstrings","title":"Inti.Fejer","text":"struct Fejer{N}\n\nN-point Fejer's first quadrature rule for integrating a function over [0,1]. Exactly integrates all polynomials of degree ‚â§ N-1.\n\nusing Inti\n\nq = Inti.Fejer(;order=10)\n\nInti.integrate(cos,q) ‚âà sin(1) - sin(0)\n\n# output\n\ntrue\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Gauss","page":"Docstrings","title":"Inti.Gauss","text":"struct Gauss{D,N} <: ReferenceQuadrature{D}\n\nTabulated N-point symmetric Gauss quadrature rule for integration over D.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.GaussLegendre","page":"Docstrings","title":"Inti.GaussLegendre","text":"struct GaussLegendre{N,T}\n\nN-point Gauss-Legendre quadrature rule for integrating a function over [0,1]. Exactly integrates all polynomials of degree ‚â§ 2N-1.\n\nusing Inti\n\nq = Inti.GaussLegendre(;order=10)\n\nInti.integrate(cos,q) ‚âà sin(1) - sin(0)\n\n# output\n\ntrue\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.GeometricEntity","page":"Docstrings","title":"Inti.GeometricEntity","text":"struct GeometricEntity\n\nGeometrical objects such as lines, surfaces, and volumes.\n\nGeometrical entities are stored in a global ENTITIES dictionary mapping EntityKey to the corresponding GeometricEntity, and usually entities are manipulated through their keys.\n\nA GeometricEntity can also contain a pushforward field used to parametrically represent the entry as the image of a reference domain (pushforward.domain) under some function (pushforward.parametrization).\n\nNote that entities are manipulated through their keys, and the GeometricEntity constructor returns the key of the created entity; to retrieve the entity, use the global_get_entity function.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.GeometricEntity-Tuple{String}","page":"Docstrings","title":"Inti.GeometricEntity","text":"GeometricEntity(shape::String [; translation, rotation, scaling, kwargs...])\n\nConstructs a geometric entity with the specified shape and optional parameters, and returns its key.\n\nArguments\n\nshape::String: The shape of the geometric entity.\ntranslation: The translation vector of the geometric entity. Default is SVector(0, 0, 0).\nrotation: The rotation vector of the geometric entity. Default is SVector(0, 0, 0).\nscaling: The scaling vector of the geometric entity. Default is SVector(1, 1, 1).\nkwargs...: Additional keyword arguments to be passed to the shape constructor.\n\nSupported shapes\n\nellipsoid\ntorus\nbean\nacorn\ncushion\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.Helmholtz-Tuple{}","page":"Docstrings","title":"Inti.Helmholtz","text":"Helmholtz(; k, dim)\n\nHelmholtz operator in dim dimensions: -Œîu - k¬≤u.\n\nThe parameter k can be a real or complex number. For purely imaginary wavenumbers, consider using the Yukawa kernel.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.HyperRectangle","page":"Docstrings","title":"Inti.HyperRectangle","text":"struct HyperRectangle{N,T} <: ReferenceInterpolant{ReferenceHyperCube{N},T}\n\nAxis-aligned hyperrectangle in N dimensions given by low_corner::SVector{N,T} and high_corner::SVector{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.HyperSingularKernel","page":"Docstrings","title":"Inti.HyperSingularKernel","text":"struct HyperSingularKernel{T,Op} <: AbstractKernel{T}\n\nGiven an operator Op, construct its free-space hypersingular kernel. This corresponds to the transpose(Œ≥‚ÇÅ,‚ÇìŒ≥‚ÇÅ[G]), where G is the SingleLayerKernel. For operators such as Laplace or Helmholtz, this is simply the normal derivative respect to the target variable of the DoubleLayerKernel.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.IntegralOperator","page":"Docstrings","title":"Inti.IntegralOperator","text":"struct IntegralOperator{T} <: AbstractMatrix{T}\n\nA discrete linear integral operator given by\n\nIu(x) = int_Gamma_s K(xy)u(y) ds_y x in Gamma_t\n\nwhere Gamma_s and Gamma_t are the source and target domains, respectively.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.IntegralPotential","page":"Docstrings","title":"Inti.IntegralPotential","text":"struct IntegralPotential\n\nRepresent a potential given by a kernel and a quadrature over which integration is performed.\n\nIntegralPotentials are created using IntegralPotential(kernel, quadrature).\n\nEvaluating an integral potential requires a density œÉ (defined over the quadrature nodes of the source mesh) and a point x at which to evaluate the integral\n\nint_Gamma K(oldsymbolxoldsymboly)sigma(y) ds_y x not in Gamma\n\nAssuming ùíÆ is an integral potential and œÉ is a vector of values defined on quadrature, calling ùíÆ[œÉ] creates an anonymous function that can be evaluated at any point x.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Kronrod","page":"Docstrings","title":"Inti.Kronrod","text":"struct Kronrod{D,N} <: ReferenceQuadrature{D}\n\nN-point Kronrod rule obtained by adding n+1 points to a Gauss quadrature containing n points. The order is either 3n + 1 for n even or 3n + 2 for n odd.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeCube","page":"Docstrings","title":"Inti.LagrangeCube","text":"const LagrangeSquare = LagrangeElement{ReferenceSquare}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeElement","page":"Docstrings","title":"Inti.LagrangeElement","text":"struct LagrangeElement{D,Np,T} <: ReferenceInterpolant{D,T}\n\nA polynomial p : D ‚Üí T uniquely defined by its Np values on the Np reference nodes of D.\n\nThe return type T should be a vector space (i.e. support addition and multiplication by scalars). For istance, T could be a number or a vector, but not a Tuple.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeLine","page":"Docstrings","title":"Inti.LagrangeLine","text":"const LagrangeLine = LagrangeElement{ReferenceLine}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeSquare","page":"Docstrings","title":"Inti.LagrangeSquare","text":"const LagrangeSquare = LagrangeElement{ReferenceSquare}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeTetrahedron","page":"Docstrings","title":"Inti.LagrangeTetrahedron","text":"const LagrangeTetrahedron = LagrangeElement{ReferenceTetrahedron}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeTriangle","page":"Docstrings","title":"Inti.LagrangeTriangle","text":"const LagrangeTriangle = LagrangeElement{ReferenceTriangle}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Laplace-Tuple{}","page":"Docstrings","title":"Inti.Laplace","text":"Laplace(; dim)\n\nLaplace's differential operator in dim dimension: -Œîu. ```\n\nNote the negative sign in the definition.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.Mesh","page":"Docstrings","title":"Inti.Mesh","text":"struct Mesh{N,T} <: AbstractMesh{N,T}\n\nUnstructured mesh defined by a set of nodes(of typeSVector{N,T}`), and a dictionary mapping element types to connectivity matrices. Each columns of a given connectivity matrix stores the integer tags of the nodes in the mesh comprising the element.\n\nAdditionally, the mesh contains a mapping from EntityKeys to the tags of the elements composing the entity. This can be used to extract submeshes from a given mesh using e.g. view(msh,Œì) or msh[Œì], where Œì is a Domain.\n\nSee elements for a way to iterate over the elements of a mesh.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ModifiedHelmholtz","page":"Docstrings","title":"Inti.ModifiedHelmholtz","text":"const ModifiedHelmholtz\n\nType alias for the Yukawa operator.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.MultiIndex","page":"Docstrings","title":"Inti.MultiIndex","text":"MultiIndex{N}\n\nWrapper around NTuple{N,Int} mimicking a multi-index in ‚Ñ§‚ÇÄ·¥∫.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ParametricElement","page":"Docstrings","title":"Inti.ParametricElement","text":"ParametricElement{D,T,F} <: ReferenceInterpolant{D,T}\n\nAn element represented through a explicit function f mapping D into the element. For performance reasons, f should take as input a StaticVector and return a StaticVector or StaticArray.\n\nSee also: ReferenceInterpolant, LagrangeElement\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ParametricElement-Union{Tuple{T}, Tuple{N}, Tuple{Any, Inti.HyperRectangle{N, T}}} where {N, T}","page":"Docstrings","title":"Inti.ParametricElement","text":"ParametricElement(f, d::HyperRectangle)\n\nConstruct the element defined as the image of f over d.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.PolynomialSpace","page":"Docstrings","title":"Inti.PolynomialSpace","text":"struct PolynomialSpace{D,K}\n\nThe space of all polynomials of degree ‚â§K, commonly referred to as ‚Ñô‚Çñ.\n\nThe type parameter D, of singleton type, is used to determine the reference domain of the polynomial basis. In particular, when D is a hypercube in d dimensions, the precise definition is ‚Ñô‚Çñ = span{ùê±·∂ø : 0‚â§max(Œ∏)‚â§ K}; when D is a d-dimensional simplex, the space is ‚Ñô‚Çñ = span{ùê±·∂ø : 0‚â§sum(Œ∏)‚â§ K}, where Œ∏ ‚àà ùêç·µà is a multi-index.\n\nSee also: monomial_basis, lagrange_basis\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Quadrature","page":"Docstrings","title":"Inti.Quadrature","text":"struct Quadrature{N,T} <: AbstractVector{QuadratureNode{N,T}}\n\nA collection of QuadratureNodes used to integrate over an AbstractMesh.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Quadrature-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.Quadrature","text":"Quadrature(Œ©::Domain; meshsize, qorder)\n\nConstruct a Quadrature over the domain Œ© with a mesh of size meshsize and quadrature order qorder.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.Quadrature-Union{Tuple{T}, Tuple{N}, Tuple{Inti.AbstractMesh{N, T}, Dict}} where {N, T}","page":"Docstrings","title":"Inti.Quadrature","text":"Quadrature(msh::AbstractMesh, etype2qrule::Dict)\nQuadrature(msh::AbstractMesh, qrule::ReferenceQuadrature)\nQuadrature(msh::AbstractMesh; qorder)\n\nConstruct a Quadrature for msh, where for each element type E in msh the reference quadrature q = etype2qrule[E] is used. When a single qrule is passed, it is used for all element types in msh.\n\nIf an order keyword is passed, a default quadrature of the desired order is used for each element type usig _qrule_for_reference_shape.\n\nFor co-dimension one elements, the normal vector is also computed and stored in the QuadratureNodes.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.QuadratureNode","page":"Docstrings","title":"Inti.QuadratureNode","text":"QuadratureNode{N,T<:Real}\n\nA point in ‚Ñù·¥∫ with a weight for performing numerical integration. A QuadratureNode can optionally store a normal vector.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceCube","page":"Docstrings","title":"Inti.ReferenceCube","text":"const ReferenceCube = ReferenceHyperCube{3}\n\nSingleton type representing the unit cube [0,1]¬≥.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceHyperCube","page":"Docstrings","title":"Inti.ReferenceHyperCube","text":"struct ReferenceHyperCube{N} <: ReferenceShape{N}\n\nSingleton type representing the axis-aligned hypercube in N dimensions with the lower corner at the origin and the upper corner at (1,1,‚Ä¶,1).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceInterpolant","page":"Docstrings","title":"Inti.ReferenceInterpolant","text":"abstract type ReferenceInterpolant{D,T}\n\nInterpolanting function mapping points on the domain D<:ReferenceShape (of singleton type) to a value of type T.\n\nInstances el of ReferenceInterpolant are expected to implement:\n\nel(xÃÇ): evaluate the interpolation scheme at the (reference) coordinate xÃÇ ‚àà D.\njacobian(el,xÃÇ) : evaluate the jacobian matrix of the interpolation at the (reference) coordinate x ‚àà D.\n\nnote: Note\nFor performance reasons, both el(xÃÇ) and jacobian(el,xÃÇ) should take as input a StaticVector and output a static vector or static array.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceLine","page":"Docstrings","title":"Inti.ReferenceLine","text":"const ReferenceLine = ReferenceHyperCube{1}\n\nSingleton type representing the [0,1] segment.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceQuadrature","page":"Docstrings","title":"Inti.ReferenceQuadrature","text":"abstract type ReferenceQuadrature{D}\n\nA quadrature rule for integrating a function over the domain D <: ReferenceShape.\n\nCalling x,w = q() returns the nodes x, given as SVectors, and weights w, for performing integration over domain(q).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceShape","page":"Docstrings","title":"Inti.ReferenceShape","text":"abstract type ReferenceShape\n\nA fixed reference domain/shape. Used mostly for defining more complex shapes as transformations mapping an ReferenceShape to some region of ‚Ñú·¥π.\n\nSee e.g. ReferenceLine or ReferenceTriangle for some examples of concrete subtypes.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceSimplex","page":"Docstrings","title":"Inti.ReferenceSimplex","text":"struct ReferenceSimplex{N}\n\nSingleton type representing the N-simplex with N+1 vertices (0,...,0),(0,...,0,1),(0,...,0,1,0),(1,0,...,0)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceSquare","page":"Docstrings","title":"Inti.ReferenceSquare","text":"const ReferenceSquare = ReferenceHyperCube{2}\n\nSingleton type representing the unit square [0,1]¬≤.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceTetrahedron","page":"Docstrings","title":"Inti.ReferenceTetrahedron","text":"struct ReferenceTetrahedron\n\nSingleton type representing the tetrahedron with vertices (0,0,0),(0,0,1),(0,1,0),(1,0,0)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceTriangle","page":"Docstrings","title":"Inti.ReferenceTriangle","text":"struct ReferenceTriangle\n\nSingleton type representing the triangle with vertices (0,0),(1,0),(0,1)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.SingleLayerKernel","page":"Docstrings","title":"Inti.SingleLayerKernel","text":"struct SingleLayerKernel{T,Op} <: AbstractKernel{T}\n\nThe free-space single-layer kernel (i.e. the fundamental solution) of an Op <: AbstractDifferentialOperator.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Stokes-Tuple{}","page":"Docstrings","title":"Inti.Stokes","text":"Stokes(; Œº, dim)\n\nStokes operator in dim dimensions: -ŒºŒîu + p u.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.SubMesh","page":"Docstrings","title":"Inti.SubMesh","text":"struct SubMesh{N,T} <: AbstractMesh{N,T}\n\nView into a parent mesh over a given domain.\n\nA submesh implements the interface for AbstractMesh; therefore you can iterate over elements of the submesh just like you would with a mesh.\n\nConstruct SubMeshs using view(parent,Œ©::Domain).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.TensorProductQuadrature","page":"Docstrings","title":"Inti.TensorProductQuadrature","text":"TensorProductQuadrature{N,Q}\n\nA tensor-product of one-dimension quadrature rules. Integrates over [0,1]^N.\n\nExamples\n\nqx = Inti.Fejer(10)\nqy = Inti.Fejer(15)\nq  = Inti.TensorProductQuadrature(qx,qy)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.VioreanuRokhlin","page":"Docstrings","title":"Inti.VioreanuRokhlin","text":"struct VioreanuRokhlin{D,N} <: ReferenceQuadrature{D}\n\nTabulated N-point Vioreanu-Rokhlin quadrature rule for integration over D.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Yukawa-Tuple{}","page":"Docstrings","title":"Inti.Yukawa","text":"Yukawa(; Œª, dim)\n\nYukawa operator, also known as modified Helmholtz, in dim dimensions: -Œîu + Œª¬≤u.\n\nThe parameter Œª is a positive number. Note the negative sign in front of the Laplacian.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.iterate","page":"Docstrings","title":"Base.iterate","text":"iterate(Œ©::Domain)\n\nIterating over a domain means iterating over its entities.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti._copyto!-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:StaticArraysCore.SMatrix}}","page":"Docstrings","title":"Inti._copyto!","text":"_copyto!(target,source)\n\nDefaults to Base.copyto!, but includes some specialized methods to copy from a Matrix of SMatrix to a Matrix of Numbers and viceversa.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._get_gauss_qcoords_and_qweights-Tuple{Type{<:Inti.ReferenceShape}, Any}","page":"Docstrings","title":"Inti._get_gauss_qcoords_and_qweights","text":"_get_gauss_and_qweights(R::Type{<:ReferenceShape{D}}, N) where D\n\nReturns the N-point symmetric gaussian qnodes and qweights (x, w) for integration over R.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._get_vioreanurokhlin_qcoords_and_qweights-Tuple{Type{<:Inti.ReferenceShape}, Any}","page":"Docstrings","title":"Inti._get_vioreanurokhlin_qcoords_and_qweights","text":"_get_vioreanurokhlin_qcoords_and_qweights(R::Type{<:ReferenceShape{D}}, N) where D\n\nReturns the N-point Vioreanu-Rokhlin qnodes and qweights (x, w) for integration over R.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._green_multiplier-Tuple{Symbol}","page":"Docstrings","title":"Inti._green_multiplier","text":"_green_multiplier(s::Symbol)\n\nReturn -1.0 if s == :inside, 0.0 if s == :outside, and -0.5 if s == :on; otherwise, throw an error. The orientation is relative to the normal of the bounding curve/surface.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._green_multiplier-Union{Tuple{N}, Tuple{StaticArraysCore.SVector, Inti.Quadrature{N}}} where N","page":"Docstrings","title":"Inti._green_multiplier","text":"_green_multiplier(x, quad)\n\nHelper function to help determine the constant œÉ in the Green identity S[Œ≥‚ÇÅu](x)\n\nD[Œ≥‚ÇÄu](x) + œÉ*u(x) = 0. This can be used as a predicate to determine whether a\n\npoint is inside a domain or not.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._meshgen-Tuple{Any, Inti.HyperRectangle, NTuple{N, T} where {N, T}}","page":"Docstrings","title":"Inti._meshgen","text":"_meshgen(f,d::HyperRectangle,sz)\n\nCreate prod(sz) elements of ParametricElement type representing the push forward of f on each of the subdomains defined by a uniform cartesian mesh of d of size sz.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._normal-Union{Tuple{StaticArraysCore.SMatrix{N, M}}, Tuple{M}, Tuple{N}} where {N, M}","page":"Docstrings","title":"Inti._normal","text":"_normal(jac::SMatrix{M,N})\n\nGiven a an M by N matrix representing the jacobian of a codimension one object, compute the normal vector.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._qrule_for_reference_shape-Tuple{Any, Any}","page":"Docstrings","title":"Inti._qrule_for_reference_shape","text":"_qrule_for_reference_shape(ref,order)\n\nGiven a reference shape and a desired quadrature order, return an appropiate quadrature rule.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.acorn-Tuple{}","page":"Docstrings","title":"Inti.acorn","text":"acorn(; translation, rotation, scaling, labels)\n\nCreate an acorn entity in 3D, and apply optional transformations. Returns the key.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.adaptive_correction-Tuple{Inti.IntegralOperator}","page":"Docstrings","title":"Inti.adaptive_correction","text":"adaptive_correction(iop::IntegralOperator; tol, maxdist = farfield_distance(iop; atol), maxsplit = 1000])\n\nGiven an integral operator iop, this function provides a sparse correction to iop for the entries i,j such that the distance between the i-th target and the j-th source is less than maxdist.\n\nChoosing maxdist is a trade-off between accuracy and efficiency. The smaller the value, the fewer corrections are needed, but this may compromise the accuracy. For a fixed quadrature, the size of maxdist has to grow as the tolerance tol decreases. The default [farfield_distance(iop; tol)](@ref) provides a heuristic to determine a suitablemaxdist`.\n\nThe correction is computed by using the adaptive_integration routine, with a tolerance atol and a maximum number of subdivisions maxsplit; see adaptive_integration for more details.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.adaptive_integration-Tuple{Any, Inti.EmbeddedQuadrature}","page":"Docstrings","title":"Inti.adaptive_integration","text":"adaptive_integration(f, œÑÃÇ::RefernceShape; kwargs...)\nadaptive_integration(f, qrule::EmbeddedQuadrature; kwargs...)\n\nUse an adaptive procedure to estimate the integral of f over œÑÃÇ = domain(qrule). The following optional keyword arguments are available:\n\natol::Real=0.0: absolute tolerance for the integral estimate\nrtol::Real=0.0: relative tolerance for the integral estimate\nmaxsplit::Int=1000: maximum number of times to split the domain\nnorm::Function=LinearAlgebra.norm: norm to use for error estimates\nbuffer::BinaryHeap: a pre-allocated buffer to use for the adaptive procedure (see allocate_buffer)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.adaptive_integration_singular-Tuple{Any, Inti.ReferenceHyperCube{1}, Any}","page":"Docstrings","title":"Inti.adaptive_integration_singular","text":"adaptive_integration_singular(f, œÑÃÇ, xÃÇ‚Çõ; kwargs...)\n\nSimilar to adaptive_integration, but indicates that f has an isolated (integrable) singularity at xÃÇ‚Çõ ‚àà xÃÇ‚Çõ.\n\nThe integration is performed by splitting œÑÃÇ so that xÃÇ‚Çõ is a fixed vertex, guaranteeing that f is never evaluated at xÃÇ‚Çõ. Aditionally, a suitable change of variables may be applied to alleviate the singularity and improve the rate of convergence.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.adj_double_layer_hypersingular-Tuple{}","page":"Docstrings","title":"Inti.adj_double_layer_hypersingular","text":"adj_double_layer_hypersingular(; op, target, source, compression,\ncorrection)\n\nSimilar to single_double_layer, but for the adjoint double-layer and hypersingular operators. See the documentation of [single_double_layer] for a description of the arguments.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.allocate_buffer-Tuple{Any, Inti.EmbeddedQuadrature}","page":"Docstrings","title":"Inti.allocate_buffer","text":"allocate_buffer(f, quad::EmbeddedQuadrature)\n\nCreate the buffer needed for the call adaptive_integration(f, œÑÃÇ; buffer, ...).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.ambient_dimension","page":"Docstrings","title":"Inti.ambient_dimension","text":"ambient_dimension(x)\n\nDimension of the ambient space where x lives. For geometrical objects this can differ from its geometric_dimension; for example a triangle in ‚Ñù¬≥ has ambient dimension 3 but geometric dimension 2, while a curve in ‚Ñù¬≥ has ambient dimension 3 but geometric dimension 1.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.assemble_fmm-Tuple{Inti.IntegralOperator, Vararg{Any}}","page":"Docstrings","title":"Inti.assemble_fmm","text":"assemble_fmm(iop; atol)\n\nSet up a 2D or 3D FMM for evaluating the discretized integral operator iop associated with the op. In 2D the FMM2D or FMMLIB2D library is used (whichever was most recently loaded) while in 3D FMM3D is used.\n\nwarning: FMMLIB2D\nFMMLIB2D does no checking for if the targets and sources coincide, and will return Inf values if iop.target !== iop.source, but there is a point x ‚àà iop.target such that x ‚àà iop.source.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.assemble_hmatrix-Tuple","page":"Docstrings","title":"Inti.assemble_hmatrix","text":"assemble_hmatrix(iop[; atol, rank, rtol, eta])\n\nAssemble an H-matrix representation of the discretized integral operator iop using the HMatrices.jl library.\n\nSee the documentation of HMatrices for more details on usage and other keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.assemble_matrix-Tuple{Inti.IntegralOperator}","page":"Docstrings","title":"Inti.assemble_matrix","text":"assemble_matrix(iop::IntegralOperator; threads = true)\n\nAssemble a dense matrix representation of an IntegralOperator.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.bdim_correction-Tuple{Any, Any, Inti.Quadrature, Any, Any}","page":"Docstrings","title":"Inti.bdim_correction","text":"bdim_correction(op,X,Y,S,D; green_multiplier, kwargs...)\n\nGiven a op and a (possibly innacurate) discretizations of its single and double-layer operators S and D (taking a vector of values on Y and returning a vector on of values on X), compute corrections Œ¥S and Œ¥D such that S + Œ¥S and D + Œ¥D are more accurate approximations of the underlying single- and double-layer integral operators.\n\nSee [7] for more details on the method.\n\nArguments\n\nRequired:\n\nop must be an AbstractDifferentialOperator\nY must be a Quadrature object of a closed surface\nX is either inside, outside, or on Y\nS and D are approximations to the single- and double-layer operators for op taking densities in Y and returning densities in X.\ngreen_multiplier (keyword argument) is a vector with the same length as X storing the value of Œº(x) for x ‚àà X in the Green identity S\\[Œ≥‚ÇÅu\\](x) - D\\[Œ≥‚ÇÄu\\](x) + Œº*u(x) = 0. See _green_multiplier.\n\nOptional kwargs:\n\nparameters::DimParameters: parameters associated with the density interpolation method\nderivative: if true, compute the correction to the adjoint double-layer and hypersingular operators instead. In this case, S and D should be replaced by a (possibly innacurate) discretization of adjoint double-layer and hypersingular operators, respectively.\nmaxdist: distance beyond which interactions are considered sufficiently far so that no correction is needed. This is used to determine a threshold for nearly-singular corrections when X and Y are different surfaces. When X === Y, this is not needed.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.bean-Tuple{}","page":"Docstrings","title":"Inti.bean","text":"bean(; translation, rotation, scaling, labels)\n\nCreate a bean entity in 3D, and apply optional transformations. Returns the key.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.boundary-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.boundary","text":"boundary(Œ©::Domain)\n\nReturn the external boundaries of a domain.\n\nSee also: external_boundary, internal_boundary, skeleton.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.boundary_idxs-Tuple{Inti.LagrangeElement{Inti.ReferenceHyperCube{1}}}","page":"Docstrings","title":"Inti.boundary_idxs","text":"boundary_idxs(el::LagrangeElement)\n\nThe indices of the nodes in el that define the boundary of the element.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.cart2sph-Tuple{Any, Any, Any}","page":"Docstrings","title":"Inti.cart2sph","text":"cart2sph(x,y,z)\n\nMap cartesian coordinates x,y,z to spherical ones r, Œ∏, œÜ representing the radius, elevation, and azimuthal angle respectively. The convention followed is that 0 ‚â§ Œ∏ ‚â§ œÄ and -œÄ < œÜ ‚â§ œÄ. Same as the cart2sph function in MATLAB.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.connectivity-Tuple{Inti.Mesh, DataType}","page":"Docstrings","title":"Inti.connectivity","text":"connectivity(msh::AbstractMesh,E::DataType)\n\nReturn the connectivity matrix for elements of type E in msh. The integer tags in the matrix refer to the points in nodes(msh)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.coords-Tuple{T} where T","page":"Docstrings","title":"Inti.coords","text":"coords(q)\n\nReturn the spatial coordinates of q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.cushion-Tuple{}","page":"Docstrings","title":"Inti.cushion","text":"cushion(; translation, rotation, scaling, labels)\n\nCreate a cushion entity in 3D, and apply optional transformations. Returns the key.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.decompose","page":"Docstrings","title":"Inti.decompose","text":"decompose(s::ReferenceShape,x)\n\nDecompose an ReferenceShape into LagrangeElements so that x is a fixed vertex of the children elements.\n\nThe decomposed elements may be oriented differently than the parent, and thus care has to be taken regarding e.g. normal vectors.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.degree-Union{Tuple{Type{<:Inti.LagrangeElement{D, Np}}}, Tuple{Np}, Tuple{D}} where {D, Np}","page":"Docstrings","title":"Inti.degree","text":"degree(el::LagrangeElement)\ndegree(el::Type{<:LagrangeElement})\n\nThe polynomial degree el.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.dimension-Union{Tuple{Type{Inti.PolynomialSpace{D, K}}}, Tuple{K}, Tuple{D}} where {D, K}","page":"Docstrings","title":"Inti.dimension","text":"dimension(space)\n\nThe length of a basis for space; i.e. the number of linearly independent elements required to span space.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.dom2elt-Tuple{Inti.AbstractMesh, Inti.Domain, DataType}","page":"Docstrings","title":"Inti.dom2elt","text":"dom2elt(m::Mesh,Œ©,E)::Vector{Int}\n\nCompute the element indices idxs of the elements of type E composing Œ©.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.dom2qtags-Tuple{Inti.Quadrature, Inti.Domain}","page":"Docstrings","title":"Inti.dom2qtags","text":"dom2qtags(Q::Quadrature, dom::Domain)\n\nGiven a domain, return the indices of the quadratures nodes in Q associated to its quadrature.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.domain","page":"Docstrings","title":"Inti.domain","text":"domain(f)\n\nGiven a function-like object f: Œ© ‚Üí R, return Œ©.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.domain-Tuple{Inti.AbstractMesh}","page":"Docstrings","title":"Inti.domain","text":"domain(msh::AbstractMesh)\n\nReturn a [Domain] containing of all entities covered by the mesh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.domain-Tuple{Inti.Quadrature}","page":"Docstrings","title":"Inti.domain","text":"domain(Q::Quadrature)\n\nThe Domain over which Q performs integration.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.domain-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D","page":"Docstrings","title":"Inti.domain","text":"domain(q::ReferenceQuadrature)\n\nThe domain of integratino for quadrature rule q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.element_types","page":"Docstrings","title":"Inti.element_types","text":"element_types(msh::AbstractMesh)\n\nReturn the element types present in the msh.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.elements","page":"Docstrings","title":"Inti.elements","text":"elements(msh::AbstractMesh [, E::DataType])\n\nReturn the elements of a msh. Passing and element type E will restricts to elements of that type.\n\nA common pattern to avoid type-instabilies in performance critical parts of the code is to use a function barrier, as illustrated below:\n\nfor E in element_types(msh)\n    _long_computation(elements(msh, E), args...)\nend\n\n@noinline function _long_computation(iter, args...)\n    for el in iter # the type of el is known at compile time\n        # do something with el\n    end\nend\n\nwhere a dynamic dispatch is performed only on the element types (typically small for a given mesh).\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.ellipsoid-Tuple{}","page":"Docstrings","title":"Inti.ellipsoid","text":"ellipsoid(; translation, rotation, scaling, labels)\n\nCreate an ellipsoid entity in 3D, and apply optional transformations. Returns the key of the created entity.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.ent2etags-Tuple{Inti.Mesh}","page":"Docstrings","title":"Inti.ent2etags","text":"ent2etags(msh::AbstractMesh)\n\nReturn a dictionary mapping entities to a dictionary of element types to element tags.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.entities-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.entities","text":"entities(Œ©::Domain)\n\nReturn all entities making up a domain (as a set of EntityKeys).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.etype_to_nearest_points-Tuple{Any, Inti.Quadrature}","page":"Docstrings","title":"Inti.etype_to_nearest_points","text":"etype_to_nearest_points(X,Y::Quadrature; maxdist)\n\nFor each element el in Y.mesh, return a list with the indices of all points in X for which el is the nearest element. Ignore indices for which the distance exceeds maxdist.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.external_boundary-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.external_boundary","text":"external_boundary(Œ©::Domain)\n\nReturn the external boundaries inside a domain. These are entities in the skeleton of Œ© which are not in the internal boundaries of Œ©.\n\nSee also: internal_boundary, skeleton.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.farfield_distance-Tuple{Inti.IntegralOperator}","page":"Docstrings","title":"Inti.farfield_distance","text":"farfield_distance(iop::IntegralOperator; tol, maxiter = 10)\nfarfield_distance(K, Q::Quadrature; tol, maxiter = 10)\n\nReturn an estimate of the distance d such that the (absolute) quadrature error of the integrand y -> K(x,y) is below tol for x at a distance d from the center of the largest element in Q; when an integral operator is passed, we have Q::Quadrature = source(iop) and K = kernel(iop).\n\nThe estimate is computed by finding the first integer n such that the quadrature error on the largest element œÑ lies below tol for points x satisfying dist(x,center(œÑ)) = n*radius(œÑ).\n\nNote that the desired tolerance may not be achievable if the quadrature rule is not accurate enough, or if œÑ is not sufficiently small, and therefore a maximum number of iterations maxiter is provided to avoid an infinite loops. In such cases, it is recommended that you either increase the quadrature order, or decrease the mesh size.\n\nNote: this is obviously a heuristic, and may not be accurate in all cases.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.fibonnaci_points_sphere-Tuple{Any, Any, Any}","page":"Docstrings","title":"Inti.fibonnaci_points_sphere","text":"fibonnaci_points_sphere(N,r,c)\n\nReturn N points distributed (roughly) in a uniform manner on the sphere of radius r centered at c.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.flip_normal-Tuple{Inti.QuadratureNode}","page":"Docstrings","title":"Inti.flip_normal","text":"flip_normal(q::QuadratureNode)\n\nReturn a new QuadratureNode with the normal vector flipped.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.gauss_curvature-Tuple{Inti.Quadrature}","page":"Docstrings","title":"Inti.gauss_curvature","text":"gauss_curvature(Q::Quadrature)\n\nCompute the gauss_curvature at each quadrature node in Q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.gauss_curvature-Tuple{Inti.ReferenceInterpolant, Any}","page":"Docstrings","title":"Inti.gauss_curvature","text":"gauss_curvature(œÑ, xÃÇ)\n\nCalculate the Gaussian curvature of the element œÑ at the parametric coordinate xÃÇ.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.geometric_dimension","page":"Docstrings","title":"Inti.geometric_dimension","text":"geometric_dimension(x)\n\nNNumber of degrees of freedom necessary to locally represent the geometrical object. For example, lines have geometric dimension of 1 (whether in ‚Ñù¬≤ or in ‚Ñù¬≥), while surfaces have geometric dimension of 2.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.global_get_entity-Tuple{Inti.EntityKey}","page":"Docstrings","title":"Inti.global_get_entity","text":"global_get_entity(k::EntityKey)\n\nRetrieve the GeometricEntity corresponding to the EntityKey k from the global ENTITIES dictionary.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.gmsh_curve-Tuple","page":"Docstrings","title":"Inti.gmsh_curve","text":"gmsh_curve(f::Function, a, b; npts=100, meshsize = 0, tag=-1)\n\nCreate a curve in the current gmsh model given by {f(t) : t ‚àà (a,b) } where f is a function from ‚Ñù to ‚Ñù^3. The curve is approximated by C¬≤ b-splines passing through npts equispaced in parameter space. If a meshsize is given, gmsh will use it when meshing the curve.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.hessian-Tuple{Inti.ReferenceInterpolant, Any}","page":"Docstrings","title":"Inti.hessian","text":"hesssian(el,x)\n\nGiven a (possibly vector-valued) functor f : ùêë·µê ‚Üí ùêÖ‚Åø, return the n √ó m √ó m matrix A·µ¢‚±º‚±º = ‚àÇ¬≤f·µ¢/‚àÇx‚±º‚àÇx‚±º. By default ForwardDiff is used to compute the hessian, but you should overload this method for specific f if better performance and/or precision is required.\n\nNote: both x and f(x) are expected to be of SVector type.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.image","page":"Docstrings","title":"Inti.image","text":"image(f)\n\nGiven a function-like object f: Œ© ‚Üí R, return f(Œ©).\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.import_mesh-Tuple","page":"Docstrings","title":"Inti.import_mesh","text":"import_mesh(filename = nothing; dim=3)\n\nOpen filename and create a Mesh from the gmsh model in it.\n\nIf filename is nothing, the current gmsh model is used. Note that this assumes that the Gmsh API has been initialized through gmsh.initialize.\n\nPassing dim=2 will create a two-dimensional mesh by projecting the original mesh onto the x,y plane.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.integrate-Tuple{Any, Inti.Quadrature}","page":"Docstrings","title":"Inti.integrate","text":"integrate(f,quad::Quadrature)\n\nCompute ‚àë·µ¢ f(q·µ¢)w·µ¢, where the q·µ¢ are the quadrature nodes of quad, and w·µ¢ are the quadrature weights.\n\nNote that you must define f(::QuadratureNode): use q.coords and q.normal if you need to access the coordinate or normal vector at que quadrature node.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.integrate-Tuple{Any, Inti.ReferenceQuadrature}","page":"Docstrings","title":"Inti.integrate","text":"integrate(f,q::ReferenceQuadrature)\nintegrate(f,x,w)\n\nIntegrate the function f using the quadrature rule q. This is simply sum(f.(x) .* w), where x and w are the quadrature nodes and weights, respectively.\n\nThe function f should take an SVector as input.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.integrate_with_error_estimate","page":"Docstrings","title":"Inti.integrate_with_error_estimate","text":"integrate_with_error_estimate(f, quad::EmbeddedQuadrature, norm = LinearAlgebra.norm)\n\nReturn I, E where I is the estimated integral of f over domain(quad) using the high-order quadrature and E is the error estimate obtained by taking the norm of the difference between the high and low-order quadratures in quad.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.integration_measure-Tuple{Any, Any}","page":"Docstrings","title":"Inti.integration_measure","text":"integration_measure(f, xÃÇ)\n\nGiven the Jacobian matrix J of a transformation f : ‚Ñù·¥π ‚Üí ‚Ñù·¥∫ compute the integration measure ‚àödet(J·µÄJ) at the parametric coordinate xÃÇ\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.interface_method-Tuple{DataType}","page":"Docstrings","title":"Inti.interface_method","text":"interface_method(x)\n\nA method of an abstract type for which concrete subtypes are expected to provide an implementation.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.internal_boundary-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.internal_boundary","text":"internal_boundary(Œ©::Domain)\n\nReturn the internal boundaries of a Domain. These are entities in skeleton(Œ©) which appear at least twice as a boundary of entities in Œ©.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.interpolation_order-Tuple{Inti.ReferenceQuadrature{Inti.ReferenceHyperCube{1}}}","page":"Docstrings","title":"Inti.interpolation_order","text":"interpolation_order(qrule::ReferenceQuadrature)\n\nThe interpolation order of a quadrature rule is defined as the the smallest k such that there exists a unique polynomial in PolynomialSpace{D,k} that minimizes the error in approximating the function f at the quadrature nodes.\n\nFor an N-point Gauss quadrature rule on the segment, the interpolation order is N-1 since N points uniquely determine a polynomial of degree N-1.\n\nFor a triangular reference domain, the interpolation order is more difficult to define. An unisolvent three-node quadrature on the triangular, for example, has an interpolation order k=1 since the three nodes uniquely determine a linear polynomial, but a four-node quadrature may also have an interpolation order k=1 since for k=2 there are multiple polynomials that pass through the four nodes.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.jacobian-Tuple{Any, Any}","page":"Docstrings","title":"Inti.jacobian","text":"jacobian(f,x)\n\nGiven a (possibly vector-valued) functor f : ùêë·µê ‚Üí ùêÖ‚Åø, return the n √ó m matrix A·µ¢‚±º = ‚àÇf·µ¢/‚àÇx‚±º. By default ForwardDiff is used to compute the jacobian, but you should overload this method for specific f if better performance and/or precision is required.\n\nNote: both x and f(x) are expected to be of SVector type.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.kress_change_of_variables-Tuple{Any}","page":"Docstrings","title":"Inti.kress_change_of_variables","text":"kress_change_of_variables(P)\n\nReturn a change of variables mapping [0,1] to [0,1] with the property that the first P-1 derivatives of the transformation vanish at x=0.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.kress_change_of_variables_periodic-Tuple{Any}","page":"Docstrings","title":"Inti.kress_change_of_variables_periodic","text":"kress_change_of_variables_periodic(P)\n\nLike kress_change_of_variables, this change of variables maps the interval [0,1] onto itself, but the first P derivatives of the transformation vanish at both endpoints (thus making it a periodic function).\n\nThis change of variables can be used to periodize integrals over the interval [0,1] by mapping the integrand into a new integrand that vanishes (to order P) at both endpoints.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.lagrange_basis-Tuple{Any, Inti.PolynomialSpace}","page":"Docstrings","title":"Inti.lagrange_basis","text":"lagrange_basis(nodes,[sp::AbstractPolynomialSpace])\n\nReturn the set of n polynomials in sp taking the value of 1 on node i and 0 on nodes j ‚âÇÃ∏ i for 1 ‚â§ i ‚â§ n.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.lagrange_basis-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D","page":"Docstrings","title":"Inti.lagrange_basis","text":"lagrange_basis(qrule::ReferenceQuadrature)\n\nReturn a function L : ‚Ñù·¥∫ ‚Üí ‚Ñù·µñ where N is the dimension of the domain of qrule, and p is the number of nodes in qrule. The function L is a polynomial in polynomial_space(qrule), and L(x‚±º)[i] = Œ¥·µ¢‚±º (i.e. the ith component of L is the ith Lagrange basis).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.lagrange_basis-Union{Tuple{Type{Inti.LagrangeElement{D, N, T}}}, Tuple{T}, Tuple{N}, Tuple{D}} where {D, N, T}","page":"Docstrings","title":"Inti.lagrange_basis","text":"lagrange_basis(E::Type{<:LagrangeElement})\n\nReturn the Lagrange basis B for the element E. Evaluating B(x) yields the value of each basis function at x.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.line-Tuple{Any, Any}","page":"Docstrings","title":"Inti.line","text":"line(a,b)\n\nCreate a [GeometricEntity] representing a straight line connecting points a and b. The points a and b can be either SVectors or a Tuple.\n\nThe parametrization of the line is given by f(u) = a + u(b - a), where 0 ‚â§ u ‚â§ 1.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.mean_curvature-Tuple{Inti.Quadrature}","page":"Docstrings","title":"Inti.mean_curvature","text":"mean_curvature(Q::Quadrature)\n\nCompute the mean_curvature at each quadrature node in Q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.mean_curvature-Tuple{Inti.ReferenceInterpolant, Any}","page":"Docstrings","title":"Inti.mean_curvature","text":"mean_curvature(œÑ, xÃÇ)\n\nCalculate the mean curvature of the element œÑ at the parametric coordinate xÃÇ.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.measure","page":"Docstrings","title":"Inti.measure","text":"measure(k::EntityKey, rtol)\n\nCompute the length/area/volume of the entity k using an adaptive quadrature with a relative tolerance rtol. Assumes that the entity has an explicit parametrization.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.meshgen!-Tuple{Inti.Mesh, Inti.Domain, Int64}","page":"Docstrings","title":"Inti.meshgen!","text":"meshgen!(mesh,Œ©,sz)\n\nSimilar to meshgen, but append entries to mesh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.meshgen-Tuple{Inti.Domain, Vararg{Any}}","page":"Docstrings","title":"Inti.meshgen","text":"meshgen(Œ©, n; T = Float64)\nmeshgen(Œ©, n_dict; T = Float64)\nmeshgen(Œ©; meshsize, T = Float64)\n\nGenerate a Mesh for the domain Œ© where each curve is meshed using n elements. Passing a dictionary allows for a finer control; in such cases, n_dict[ent] should return an integer for each entity ent in Œ© of geometric_dimension one.\n\nAlternatively, a meshsize can be passed, in which case, the number of elements is computed as so as to obtain an average mesh size of meshsize. Note that the actual mesh size may vary significantly for each element if the parametrization is far from uniform.\n\nThe mesh is created with primitive data of type T.\n\nThis function requires the entities forming Œ© to have an explicit parametrization.\n\nwarning: Mesh quality\nThe quality of the generated mesh created using meshgen depends on the quality of the underlying parametrization. For complex surfaces, you are better off using a proper mesher such as gmsh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.monomial_basis","page":"Docstrings","title":"Inti.monomial_basis","text":"monomial_basis(sp::PolynomialSpace)\n\nReturn a function f : ‚Ñù·¥∫ ‚Üí ‚Ñù·µà, where N is the dimension of the domain of sp     containing a basis of monomials ùê±·∂ø spanning the polynomial space PolynomialSpace.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.near_interaction_list-Union{Tuple{N}, Tuple{AbstractVector{<:StaticArraysCore.SVector{N}}, Inti.AbstractMesh{N}}} where N","page":"Docstrings","title":"Inti.near_interaction_list","text":"near_interaction_list(X,Y::AbstractMesh; tol)\n\nFor each element el of type E in Y, return the indices of the points in X which are closer than tol to the center of el.\n\nThis function returns a dictionary where e.g. dict[E][5] --> Vector{Int} gives the indices of points in X which are closer than tol to the center of the fifth element of type E.\n\nIf tol is a Dict, then tol[E] is the tolerance for elements of type E.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.new_tag-Tuple{Integer}","page":"Docstrings","title":"Inti.new_tag","text":"new_tag(dim)\n\nReturn a new tag for an entity of dimension dim so that EntityKey(dim, tag) is not already in ENTITIES.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.nodes-Tuple{Inti.SubMesh}","page":"Docstrings","title":"Inti.nodes","text":"nodes(msh::SubMesh)\n\nA view of the nodes of the parent mesh belonging to the submesh. The ordering is given by the nodetags function.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.nodetags-Tuple{Inti.SubMesh}","page":"Docstrings","title":"Inti.nodetags","text":"nodetags(msh::SubMesh)\n\nReturn the tags of the nodes in the parent mesh belonging to the submesh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.normal-Tuple{Any, Any}","page":"Docstrings","title":"Inti.normal","text":"normal(el, xÃÇ)\n\nReturn the normal vector of el at the parametric coordinate xÃÇ.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.normal-Tuple{T} where T","page":"Docstrings","title":"Inti.normal","text":"normal(q)\n\nReturn the normal vector of q, if it exists.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.notimplemented-Tuple{}","page":"Docstrings","title":"Inti.notimplemented","text":"notimplemented()\n\nThings which should probably be implemented at some point.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.order-Union{Tuple{Inti.Fejer{N}}, Tuple{N}} where N","page":"Docstrings","title":"Inti.order","text":"order(q::ReferenceQuadrature)\n\nA quadrature of order p (sometimes called degree of precision) integrates all polynomials of degree ‚â§ p but not ‚â§ p + 1.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.order-Union{Tuple{Type{<:Inti.LagrangeElement{D, Np}}}, Tuple{Np}, Tuple{D}} where {D, Np}","page":"Docstrings","title":"Inti.order","text":"order(el::LagrangeElement)\n\nThe order of the element's interpolating polynomial (e.g. a LagrangeLine with 2 nodes defines a linear polynomial, and thus has order 1).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.parametric_curve-Union{Tuple{F}, Tuple{F, Real, Real}} where F","page":"Docstrings","title":"Inti.parametric_curve","text":"parametric_curve(f, a::Real, b::Real)\n\nCreate a [GeometricEntity] representing a parametric curve defined by the {f(t) | a ‚â§ t ‚â§ b}. The function f should map a scalar to an SVector.\n\nFlipping the orientation is supported by passing a > b.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.parametric_surface","page":"Docstrings","title":"Inti.parametric_surface","text":"    parametric_surface(f, lc, hc, boundary = nothing; kwargs...)\n\nCreate a parametric surface defined by the function f over the rectangular domain defined by the lower corner lc and the upper corner hc. The optional boundary argument can be used to specify the boundary curves of the surface.\n\nArguments\n\nf: A function that takes two arguments x and y and returns a tuple (u, v)   representing the parametric coordinates of the surface at (x, y).\nlc: A 2-element array representing the lower corner of the rectangular domain.\nhc: A 2-element array representing the upper corner of the rectangular domain.\nboundary: An optional array of boundary curves that define the surface.\n\nKeyword Arguments\n\nkwargs: Additional keyword arguments that can be passed to the GeometricEntity   constructor.\n\nReturns\n\nThe key of the created GeometricEntity.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.polynomial_solutions_vdim","page":"Docstrings","title":"Inti.polynomial_solutions_vdim","text":"polynomial_solutions_vdim(op, order[, center])\n\nFor every monomial term p‚Çô of degree order, compute a polynomial P‚Çô such that ‚Ñí[P‚Çô] = p‚Çô, where ‚Ñí is the differential operator associated with op. This function returns {p‚Çô,P‚Çô,Œ≥‚ÇÅP‚Çô}, where Œ≥‚ÇÅP‚Çô is the generalized Neumann trace of P‚Çô.\n\nPassing a point center will shift the monomials and solutions accordingly.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.polynomial_space-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D","page":"Docstrings","title":"Inti.polynomial_space","text":"polynomial_space(qrule::ReferenceQuadrature)\n\nReturn a PolynomialSpace associated with the interpolation_order of the quadrature nodes of qrule.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.qcoords-Tuple{Inti.ReferenceQuadrature}","page":"Docstrings","title":"Inti.qcoords","text":"qcoords(q)\n\nReturn the coordinate of the quadrature nodes associated with q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.quadrature_to_node_vals-Tuple{Inti.Quadrature, AbstractVector}","page":"Docstrings","title":"Inti.quadrature_to_node_vals","text":"quadrature_to_node_vals(Q::Quadrature, qvals::AbstractVector)\n\nGiven a vector qvals of scalar values at the quadrature nodes of Q, return a vector ivals of scalar values at the interpolation nodes of Q.mesh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.qweights-Tuple{Inti.ReferenceQuadrature}","page":"Docstrings","title":"Inti.qweights","text":"qweights(q)\n\nReturn the quadrature weights associated with q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.reference_nodes-Tuple{Inti.LagrangeElement}","page":"Docstrings","title":"Inti.reference_nodes","text":"reference_nodes(el::LagrangeElement)\nreference_nodes(::Type{<:LagrangeElement})\n\nReturn the reference nodes on domain(el) used for the polynomial interpolation. The function values on these nodes completely determines the interpolating polynomial.\n\nWe use the same convention as gmsh for defining the reference nodes and their order (see node ordering on gmsh documentation).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.return_type-Tuple{Any, Vararg{Any}}","page":"Docstrings","title":"Inti.return_type","text":"return_type(f[,args...])\n\nThe type returned by f(args...), where args is a tuple of types. Falls back to Base.promote_op by default.\n\nA functors of type T with a knonw return type should extend return_type(::T,args...) to avoid relying on promote_op.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.rotation_matrix-Tuple{Any}","page":"Docstrings","title":"Inti.rotation_matrix","text":"rotation_matrix(rot)\n\nConstructs a rotation matrix given the rotation angles around the x, y, and z axes.\n\nArguments\n\nrot: A tuple or vector containing the rotation angles in radians for each axis.\n\nReturns\n\nR::SMatrix: The resulting rotation matrix.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.single_double_layer-Tuple{}","page":"Docstrings","title":"Inti.single_double_layer","text":"single_double_layer(; op, target, source::Quadrature, compression,\ncorrection, derivative = false)\n\nConstruct a discrete approximation to the single- and double-layer integral operators for op, mapping values defined on the quadrature nodes of source to values defined on the nodes of target. If derivative = true, return instead the adjoint double-layer and hypersingular operators (which are the derivative of the single- and double-layer, respectively).\n\nYou  must choose a compression method and a correction method, as described below.\n\nCompression\n\nThe compression argument is a named tuple with a method field followed by method-specific fields. It specifies how the dense linear operators should be compressed. The available options are:\n\n(method = :none, ): no compression is performed, the resulting matrices are dense.\n(method =:hmatrix, tol): the resulting operators are compressed using hierarchical matrices with an absolute tolerance tol (defaults to 1e-8).\n(method = :fmm, tol): the resulting operators are compressed using the fast multipole method with an absolute tolerance tol (defaults to 1e-8).\n\nCorrection\n\nThe correction argument is a named tuple with a method field followed by method-specific fields. It specifies how the singular and nearly-singular integrals should be computed. The available options are:\n\n(method = :none, ): no correction is performed. This is not recommented, as the resulting approximation will be inaccurate if the source and target are not sufficiently far apart.\n(method = :dim, maxdist, target_location): use the density interpolation method to compute the correction. maxdist specifies the distance between source and target points above which no correction is performed (defaults to Inf). target_location should be either :inside, :outside, or :on, and specifies where the targetpoints lie relative to the to thesourcecurve/surface (which is assumed to be closed). Whentarget === source,target_location` is not needed.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.single_double_layer_potential-Tuple{}","page":"Docstrings","title":"Inti.single_double_layer_potential","text":"single_double_layer_potential(; op, source)\n\nReturn the single- and double-layer potentials for op as IntegralPotentials.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.skeleton-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.skeleton","text":"skeleton(Œ©::Domain)\n\nReturn all the boundaries of the domain, i.e. the domain's skeleton.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.stack_weakdeps_env!-Tuple{}","page":"Docstrings","title":"Inti.stack_weakdeps_env!","text":"stack_weakdeps_env!(; verbose = false, update = false)\n\nPush to the load stack an environment providing the weak dependencies of Inti.jl. This allows benefiting from additional functionalities of Inti.jl which are powered by weak dependencies without having to manually install them in your environment.\n\nSet update=true if you want to update the weakdeps environment.\n\nwarning: Warning\nCalling this function can take quite some time, especially the first time around, if packages have to be installed or precompiled. Run in verbose mode to see what is happening.\n\nExamples:\n\nInti.stack_weakdeps_env!()\nusing HMatrices\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.standard_basis_vector-Union{Tuple{N}, Tuple{Any, Val{N}}} where N","page":"Docstrings","title":"Inti.standard_basis_vector","text":"standard_basis_vector(k, ::Val{N})\n\nCreate an SVector of length N with a 1 in the kth position and zeros elsewhere.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.svector-Union{Tuple{F}, Tuple{F, Any}} where F","page":"Docstrings","title":"Inti.svector","text":"svector(f,n)\n\nCreate an SVector of length n, computing each element as f(i), where i is the index of the element.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.torus-Tuple{}","page":"Docstrings","title":"Inti.torus","text":"torus(; r, R, translation, rotation, scaling, labels)\n\nCreate a torus entity in 3D, and apply optional transformations. Returns the key. The parameters r and R are the inner and outer radii of the torus.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.uniform_points_circle-Tuple{Any, Any, Any}","page":"Docstrings","title":"Inti.uniform_points_circle","text":"uniform_points_circle(N,r,c)\n\nReturn N points uniformly distributed on a circle of radius r centered at c.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.vdim_correction-Union{Tuple{SHIFT}, Tuple{Any, Any, Inti.Quadrature, Inti.Quadrature, Any, Any, Any}} where SHIFT","page":"Docstrings","title":"Inti.vdim_correction","text":"vdim_correction(op,X,Y,Y_boundary,S,D,V; green_multiplier, kwargs...)\n\nCompute a correction to the volume potential V : Y ‚Üí X such that V + Œ¥V is a more accurate approximation of the underlying volume potential operator. The correction is computed using the (volume) density interpolation method.\n\nThis function requires a op::AbstractDifferentialOperator, a target set X, a source quadrature Y, a boundary quadrature Y_boundary, approximations S : Y_boundary -> X and D : Y_boundary -> X to the single- and double-layer potentials (correctly handling nearly-singular integrals), and a naive approximation of the volume potential V. The green_multiplier is a vector of the same length as X storing the value of Œº(x) for x ‚àà X in the Green identity (see _green_multiplier).\n\nSee [8] for more details on the method.\n\nOptional kwargs:\n\ninterpolation_order: the order of the polynomial interpolation. By default, the maximum order of the quadrature rules is used.\nmaxdist: distance beyond which interactions are considered sufficiently far so that no correction is needed. This is used to determine a threshold for nearly-singular corrections.\ncenter: the center of the basis functions. By default, the basis functions are centered at the origin.\nshift: a boolean indicating whether the basis functions should be shifted and rescaled to each element.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.vdim_mesh_center-Tuple{Inti.AbstractMesh}","page":"Docstrings","title":"Inti.vdim_mesh_center","text":"vdim_mesh_center(msh)\n\nPoint x which minimizes ‚àë (x-x‚±º)¬≤/r¬≤‚±º, where x‚±º and r‚±º are the circumcenter and circumradius of the elements of msh, respectively.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.vertices-Tuple{Inti.LagrangeElement}","page":"Docstrings","title":"Inti.vertices","text":"vertices(el::LagrangeElement)\n\nCoordinates of the vertices of el.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.vertices_idxs-Tuple{Type{<:Inti.LagrangeElement{Inti.ReferenceHyperCube{1}}}}","page":"Docstrings","title":"Inti.vertices_idxs","text":"vertices_idxs(el::LagrangeElement)\n\nThe indices of the nodes in el that define the vertices of the element.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.volume_potential-Tuple{}","page":"Docstrings","title":"Inti.volume_potential","text":"volume_potential(; op, target, source::Quadrature, compression, correction)\n\nCompute the volume potential operator for a given PDE.\n\nArguments\n\nop: The PDE (Partial Differential Equation) to solve.\ntarget: The target domain where the potential is computed.\nsource: The source domain where the potential is generated.\ncompression: The compression method to use for the potential operator.\ncorrection: The correction method to use for the potential operator.\n\nReturns\n\nThe volume potential operator V that represents the interaction between the target and source domains.\n\nCompression\n\nThe compression argument is a named tuple with a method field followed by method-specific fields. It specifies how the dense linear operators should be compressed. The available options are:\n\n(method = :none, ): no compression is performed, the resulting matrices are dense.\n(method =:hmatrix, tol): the resulting operators are compressed using hierarchical matrices with an absolute tolerance tol (defaults to 1e-8).\n(method = :fmm, tol): the resulting operators are compressed using the fast multipole method with an absolute tolerance tol (defaults to 1e-8).\n\nCorrection\n\nThe correction argument is a named tuple with a method field followed by method-specific fields. It specifies how the singular and nearly-singular integrals should be computed. The available options are:\n\n(method = :none, ): no correction is performed. This is not recommented, as the resulting approximation will be inaccurate if the source and target are not sufficiently far apart.\n(method = :dim, maxdist, target_location): use the density interpolation method to compute the correction. maxdist specifies the distance between source and target points above which no correction is performed (defaults to Inf). target_location should be either :inside, :outside, or :on, and specifies where the targetpoints lie relative to the to thesource's boundary. Whentarget === source,target_location` is not needed.\n\nDetails\n\nThe volume potential operator is computed by assembling the integral operator V using the single-layer kernel G. The operator V is then compressed using the specified compression method. If no compression is specified, the operator is returned as is. If a correction method is specified, the correction is computed and added to the compressed operator.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/compression_methods/#Compression-methods","page":"Compression methods","title":"Compression methods","text":"","category":"section"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"CurrentModule = Inti","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"note: Important points covered in this tutorial\nOverview of the compression methods available in Inti.jl\nDetails and limitations of the various compression methods\nGuideline on how to choose a compression method","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"Inti.jl wraps several external libraries providing acceleration routines for integral operators. In general, acceleration routines have the signature assemble_*(iop, args...; kwargs...), and take an IntegralOperator as a first argument. They return a new object that represents a compressed version of the operator. The following methods are available:","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"assemble_matrix: create a dense Matrix representation of the integral operator. Not really a compression method, but useful for debugging and small problems.\nassemble_hmatrix: assemble a hierarchical matrix representation of the operator using the HMatrices library.\nassemble_fmm: return a LinearMap object that represents the operator using the fast multipole method. This method is powered by the FMM2D, FMMLIB2D and FMM3D libraries, and is only available for certain kernels.","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"warning: Singular kernels\nAcceleration methods do not correct for singular or nearly-singular interactions. When the underlying kernel is singular, a correction is usually necessary in order to obtain accurate results (see the section on correction methods for more details).","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"To illustrate the use of compression methods, we will use the following problem as an example. Note that for such a small problem, compression methods are not likely not necessary, but they are useful for larger problems.","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"using Inti\nusing LinearAlgebra\n# define the quadrature\ngeo = Inti.GeometricEntity(\"ellipsoid\")\nŒ© = Inti.Domain(geo)\nŒì = Inti.boundary(Œ©)\nQ = Inti.Quadrature(Œì; meshsize = 0.4, qorder = 5)\n# create the operator\nop = Inti.Helmholtz(; dim = 3, k = 2œÄ)\nK = Inti.SingleLayerKernel(op)\nSop = Inti.IntegralOperator(K, Q, Q)\nx = rand(eltype(Sop), length(Q))\nrtol = 1e-8\nnothing # hide","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"In what follows we compress Sop using the different methods available.","category":"page"},{"location":"tutorials/compression_methods/#Dense-matrix","page":"Compression methods","title":"Dense matrix","text":"","category":"section"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"assemble_matrix","category":"page"},{"location":"tutorials/compression_methods/#Inti.assemble_matrix-tutorials-compression_methods","page":"Compression methods","title":"Inti.assemble_matrix","text":"assemble_matrix(iop::IntegralOperator; threads = true)\n\nAssemble a dense matrix representation of an IntegralOperator.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"Typically used for small problems, the dense matrix representation converts the IntegralOperator into a Matrix object. The underlying type of the Matrix is determined by the eltype of the IntegralOperator, and depends on the inferred type of the kernel. Here is how assemble_matrix can be used:","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"Smat = Inti.assemble_matrix(Sop; threads=true)\n@assert Sop * x ‚âà Smat * x # hide\ner = norm(Sop * x - Smat * x, Inf) / norm(Sop * x, Inf)\nprintln(\"Forward map error: $er\")","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"Since the returned object is plain Julia Matrix, it can be used with any of the linear algebra routines available in Julia (e.g. \\, lu, qr, *, etc.)","category":"page"},{"location":"tutorials/compression_methods/#Hierarchical-matrix","page":"Compression methods","title":"Hierarchical matrix","text":"","category":"section"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"assemble_hmatrix","category":"page"},{"location":"tutorials/compression_methods/#Inti.assemble_hmatrix-tutorials-compression_methods","page":"Compression methods","title":"Inti.assemble_hmatrix","text":"assemble_hmatrix(iop[; atol, rank, rtol, eta])\n\nAssemble an H-matrix representation of the discretized integral operator iop using the HMatrices.jl library.\n\nSee the documentation of HMatrices for more details on usage and other keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"The hierarchical matrix representation is a compressed representation of the underlying operator; as such, it takes a tolerance parameter that determines the relative error of the compression. Here is an example of how to use the assemble_hmatrix method to compress the previous problem:","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"using HMatrices\nShmat = Inti.assemble_hmatrix(Sop; rtol = 1e-8)\ner = norm(Smat * x - Shmat * x, Inf) / norm(Smat * x, Inf)\n@assert er < 10*rtol # hide\nprintln(\"Forward map error: $er\")","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"Note that HMatrices are said to be kernel-independent, meaning that they efficiently compress a wide range of integral operators provided they satisfy a certain asymptotic smoothness criterion (see e.g. [3, 4]).","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"The HMatrix object can be used to solve linear systems, both iteratively through e.g. GMRES, or directly using an LU factorization.","category":"page"},{"location":"tutorials/compression_methods/#Fast-multipole-method","page":"Compression methods","title":"Fast multipole method","text":"","category":"section"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"assemble_fmm","category":"page"},{"location":"tutorials/compression_methods/#Inti.assemble_fmm-tutorials-compression_methods","page":"Compression methods","title":"Inti.assemble_fmm","text":"assemble_fmm(iop; atol)\n\nSet up a 2D or 3D FMM for evaluating the discretized integral operator iop associated with the op. In 2D the FMM2D or FMMLIB2D library is used (whichever was most recently loaded) while in 3D FMM3D is used.\n\nwarning: FMMLIB2D\nFMMLIB2D does no checking for if the targets and sources coincide, and will return Inf values if iop.target !== iop.source, but there is a point x ‚àà iop.target such that x ‚àà iop.source.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"The fast multipole method (FMM) is an acceleration technique based on an analytic multipole expansion of the kernel in the integral operator [5, 6]. It provides a very memory-efficient and fast way to evaluate certain types of integral operators. Here is how assemble_fmm can be used:","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"using FMM3D\nSfmm = Inti.assemble_fmm(Sop; rtol = 1e-8)\ner = norm(Sop * x - Sfmm * x, Inf) / norm(Sop * x, Inf)\n@assert er < 10*rtol # hide\nprintln(\"Forward map error: $er\")","category":"page"},{"location":"tutorials/compression_methods/#Tips-on-choosing-a-compression-method","page":"Compression methods","title":"Tips on choosing a compression method","text":"","category":"section"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"The choice of compression method depends on the problem at hand, as well as on the available hardware. Here is a rough guide on how to choose a compression:","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"For small problems (say less than 5k degrees of freedom), use the dense matrix representation. It is the simplest and most straightforward method, and does not require any additional packages. It is also the most accurate since it does not introduce any approximation errors.\nIf the integral operator is supported by the assemble_fmm, and if an iterative solver is acceptable, use it. The FMM is a very efficient method for certain types of kernels, and can handle problems with up to a few million degrees of freedom on a laptop.\nIf the kernel is not supported by assemble_fmm, if iterative solvers are not an option, or if the system needs solution for many right-hand sides, use the assemble_hmatrix method. It is a very general method that can handle a wide range of kernels, and although assembling the HMatrix can be time and memory consuming (the complexity is still log-linear in the DOFs for many kernels of interest, but the constants can be large), the resulting HMatrix object is very efficient to use. For example, the forward map is usually significantly faster than the one obtained through assemble_fmm.","category":"page"},{"location":"tutorials/correction_methods/#Correction-methods","page":"Correction methods","title":"Correction methods","text":"","category":"section"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"CurrentModule = Inti","category":"page"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"warning: Work in progress\nThis tutorial is still a work in progress. We will update it with more details and examples in the future.","category":"page"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"note: Important points covered in this tutorial\nOverview of the correction methods available in Inti.jl\nDetails and limitations of the various correction methods\nGuideline on how to choose a correction method","category":"page"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"When the underlying kernel is singular, a correction is usually necessary in order to obtain accurate results in the approximation of the underlying integral operator by a quadrature. At present, Inti.jl provides the following functions to correct for singularities:","category":"page"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"adaptive_correction\nbdim_correction\nvdim_correction","category":"page"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"They have different strengths and weaknesses, and we will discuss them in the following sections.","category":"page"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"note: High-level API\nNote that the single_double_layer, adj_double_layer_hypersingular, and volume_potential functions have high-level API with a correction keyword argument that allows one to specify the correction method to use when constructing the integral operators; see the documentation of these functions for more details.","category":"page"},{"location":"tutorials/correction_methods/#Adaptive-correction","page":"Correction methods","title":"Adaptive correction","text":"","category":"section"},{"location":"tutorials/correction_methods/#Boundary-density-interpolation-method","page":"Correction methods","title":"Boundary density interpolation method","text":"","category":"section"},{"location":"tutorials/correction_methods/#Volume-density-interpolation-method","page":"Correction methods","title":"Volume density interpolation method","text":"","category":"section"},{"location":"tutorials/correction_methods/#Martensen-Kussmaul-method","page":"Correction methods","title":"Martensen-Kussmaul method","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/#Geometry-and-meshes","page":"Geometry and meshes","title":"Geometry and meshes","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"CurrentModule = Inti","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"note: Important points covered in this tutorial\nCombine simple shapes to create domains\nImport a mesh from a file\nIterative over mesh elements","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"In the getting started tutorial, we saw how to solve a simple Helmholtz scattering problem in 2D. We will now dig deeper into how to create and manipulate more complex geometrical shapes, as well the associated meshes.","category":"page"},{"location":"tutorials/geo_and_meshes/#Overview","page":"Geometry and meshes","title":"Overview","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Inti.jl provides a flexible way to define geometrical entities and their associated meshes. Simply put, the GeometricEntity type is the atomic building block of geometries: they can represent points, curves, surfaces, or volumes. Geometrical entities of the same dimension can be combined to form Domain, and domains can be manipulated using basic set operations such union and intersection. Meshes on the other hand are collections of (simple) elements that approximate the geometrical entities. A mesh element is a just a function that maps points from a ReferenceShape to the physical space.","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"In most applications involving complex three-dimensional surfaces, an external meshing software is used to generate a mesh, and the mesh is imported using the import_mesh function (which relies on Gmsh). The entities can then be extracted from the mesh based on e.g. their dimension or label. Here is an example of how to import a mesh from a file:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"using Inti\nusing Gmsh \nfilename = joinpath(Inti.PROJECT_ROOT,\"docs\", \"assets\", \"piece.msh\")\nmsh = Inti.import_mesh(filename)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"The imported mesh contains elements of several types, used to represent the segments, triangles, and tetras used to approximate the geometry:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Inti.element_types(msh)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Note that the msh object contains all entities used to construct the mesh, usually defined in a .geo file, which can be extracted using the entities:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"ents = Inti.entities(msh)\nnothing # hide","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Filtering of entities satisfying a certain condition, e.g., entities of a given dimension or containing a certain label, can also be performed in order to construct a domain:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"filter = e -> Inti.geometric_dimension(e) == 3\nŒ© = Inti.Domain(filter, ents)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Domains can be used to index the mesh, creating either a new object containing only the necessary elements:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Œì = Inti.boundary(Œ©)\nmsh[Œì]","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"or a SubMesh containing a view of the mesh:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Œì_msh = view(msh, Œì)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Finally, we can visualize the mesh using:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"using Meshes, GLMakie\nfig = Figure(; size = (800,400))\nax = Axis3(fig[1, 1]; aspect = :data)\nviz!(Œì_msh; showsegments = true, alpha = 0.5)\nfig","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"warning: Mesh visualization\nNote that although the mesh may be of high order and/or conforming, the visualization of a mesh is always performed on the underlying first order mesh, and therefore elements may look flat even if the problem is solved on a curved mesh.","category":"page"},{"location":"tutorials/geo_and_meshes/#Parametric-entities-and-meshgen","page":"Geometry and meshes","title":"Parametric entities and meshgen","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"In the previous section we saw an example of how to import a mesh from a file, and how to extract the entities from the mesh. For simple geometries for which an explicit parametrization is available, Inti.jl provides a way to create and manipulate geometrical entities and their associated meshes.","category":"page"},{"location":"tutorials/geo_and_meshes/#Parametric-curves","page":"Geometry and meshes","title":"Parametric curves","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"The simplest parametric shapes are parametric_curves, which are defined by a function that maps a scalar parameter t to a point in 2D or 3D space. Parametric curves are expected to return an SVector, and can be created as follows:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"using StaticArrays\nl1 = Inti.parametric_curve(x->SVector(x, 0.1 * sin(2œÄ * x)), 0.0, 1.0, labels = [\"l‚ÇÅ\"])","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"The object l1 represents a GeometricEntity with a known push-forward map:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Inti.pushforward(l1)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"For the sake of this example, let's create three more curves, and group them together to form a Domain:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"l2 = Inti.parametric_curve(x->SVector(1 + 0.1 * sin(2œÄ * x), x), 0.0, 1.0, labels = [\"l‚ÇÇ\"])\nl3 = Inti.parametric_curve(x->SVector(1 - x, 1 - 0.1 * sin(2œÄ * x)), 0.0, 1.0, labels = [\"l‚ÇÉ\"])\nl4 = Inti.parametric_curve(x->SVector(0.1 * sin(2œÄ * x), 1 - x), 0.0, 1.0, labels = [\"l‚ÇÑ\"])\nŒì  = l1 ‚à™ l2 ‚à™ l3 ‚à™ l4","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Domains for which a parametric representation is available can be passed to the meshgen function:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"msh = Inti.meshgen(Œì; meshsize = 0.05)\nnothing # hide","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"We can use the Meshes.viz function to visualize the mesh, and use domains to index the mesh:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Œì‚ÇÅ = l1 ‚à™ l3\nŒì‚ÇÇ = l2 ‚à™ l4\nfig, ax, pl = viz(view(msh, Œì‚ÇÅ); segmentsize = 4,  label = \"Œì‚ÇÅ\")\nviz!(view(msh, Œì‚ÇÇ); segmentsize = 4, color = :red, label = \"Œì‚ÇÇ\")\nfig # hide","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Note that the orientation of the curve determines the direction of the normal vector. The normal points to the right of the curve when moving in the direction of increasing parameter t:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"pts, tangents, normals = Makie.Point2f[], Makie.Vec2f[], Makie.Vec2f[]\nfor l in [l1, l2, l3, l4]\n      push!(pts, l(0.5)) # mid-point of the curve \n      push!(tangents, vec(Inti.jacobian(l, 0.5)))\n      push!(normals,Inti.normal(l, 0.5))\nend\narrows!(pts, tangents, color = :blue, linewidth = 2, linestyle = :dash, lengthscale = 1/4, label = \"tangent\")\narrows!(pts, normals, color = :black, linewidth = 2, linestyle = :dash, lengthscale = 1/4, label = \"normal\")\naxislegend()\nfig # hide","category":"page"},{"location":"tutorials/geo_and_meshes/#Parametric-surfaces","page":"Geometry and meshes","title":"Parametric surfaces","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Like parametric curves, parametric surfaces are defined by a function that maps a reference domain D subset mathbbR^2 to a surface in 3D space. They can be constructed using the parametric_surface function:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"# a patch of the unit sphere\nlc = SVector(-1.0, -1.0)\nhc = SVector(1.0, 1.0)\nf = (u,v) -> begin\n      x = SVector(1.0, u, v)   # a face of the cube\n      x ./ sqrt(u^2 + v^2 + 1) # project to the sphere\nend\npatch = Inti.parametric_surface(f, lc, hc, labels = [\"patch1\"])\nŒì  = Inti.Domain(patch)\nmsh = Inti.meshgen(Œì; meshsize = 0.1)\nviz(msh[Œì]; showsegments = true, figure = (; size = (400,400),))","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Since creating parametric surfaces that form a closed volume can be a bit more involved, Inti.jl provide a few helper functions to create simple shapes:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"fig = Figure(; size = (600,400))\nnshapes = Inti.length(Inti.PREDEFINED_SHAPES)\nncols = 3; nrows = ceil(Int, nshapes/ncols)\nfor (n,shape) in enumerate(Inti.PREDEFINED_SHAPES)\n      Œ© = Inti.GeometricEntity(shape) |> Inti.Domain\n      Œì = Inti.boundary(Œ©)\n      msh = Inti.meshgen(Œì; meshsize = 0.1)\n      i,j = (n-1) √∑ ncols + 1, (n-1) % ncols + 1\n      ax = Axis3(fig[i,j]; aspect = :data, title = shape)\n      hidedecorations!(ax)\n      viz!(msh; showsegments = true)\nend\nfig # hide","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"See GeometricEntity(shape::String) for a list of predefined geometries.","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"warning: Mesh quality\nThe quality of the generated mesh created through meshgen depends   heavily on the quality of the underlying parametrization. For surfaces   containing a degenerate parametrization, or for complex shapes, one is   better off using a suitable CAD (Computer-Aided Design) software in   conjunction with a mesh generator.","category":"page"},{"location":"tutorials/geo_and_meshes/#Transfinite-domains","page":"Geometry and meshes","title":"Transfinite domains","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"It is possible to combine parametric curves/surfaces to form a transfinite domain where the parametrization is inherited from the curves/surfaces that form its boundary. At present, Inti.jl only supports transfinite squares, which are defined by four parametric curves:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"l1 = Inti.parametric_curve(x->SVector(x, 0.1 * sin(2œÄ * x)), 0.0, 1.0, labels = [\"l‚ÇÅ\"])\nl2 = Inti.parametric_curve(x->SVector(1 + 0.1 * sin(2œÄ * x), x), 0.0, 1.0, labels = [\"l‚ÇÇ\"])\nl3 = Inti.parametric_curve(x->SVector(1 - x, 1 - 0.1 * sin(2œÄ * x)), 0.0, 1.0, labels = [\"l‚ÇÉ\"])\nl4 = Inti.parametric_curve(x->SVector(0.1 * sin(2œÄ * x), 1 - x), 0.0, 1.0, labels = [\"l‚ÇÑ\"])\nsurf = Inti.transfinite_square(l1, l2, l3, l4; labels = [\"Œ©\"])\nŒ© = Inti.Domain(surf)\nmsh = Inti.meshgen(Œ©; meshsize = 0.05)\nviz(msh; showsegments = true)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Note that the msh object contains all entities used to construct Œ©, including the boundary segments:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Inti.entities(msh)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"This allows us to probe the msh object to extract e.g. the boundary mesh:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"viz(msh[Inti.boundary(Œ©)]; color = :red)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"warning: Limitations\nAt present only the transfinite interpolation for the logically   quadrilateral domains is supported. In the future we hope to add support   for three-dimensional transfinite interpolation, as well as transfinite   formulas for simplices.","category":"page"},{"location":"tutorials/geo_and_meshes/#Elements-of-a-mesh","page":"Geometry and meshes","title":"Elements of a mesh","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"To iterate over the elements of a mesh, use the elements function:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"filename = joinpath(Inti.PROJECT_ROOT,\"docs\", \"assets\", \"piece.msh\")\nmsh = Inti.import_mesh(filename)\nents = Inti.entities(msh)\nŒ© = Inti.Domain(e -> Inti.geometric_dimension(e) == 3, ents) \nels = Inti.elements(view(msh, Œ©))\ncenters = map(el -> Inti.center(el), els)\nfig = Figure(; size = (800,400))\nax = Axis3(fig[1, 1]; aspect = :data)\nscatter!([c[1] for c in centers], [c[2] for c in centers], [c[3] for c in centers], markersize = 5)\nfig # hide","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"This example shows how to extract the centers of the tetrahedral elements in the mesh; and of course we can perform any desired computation on the elements.","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"tip: Type-stable iteration over elements\nSince a mesh in Inti.jl can contain elements of various types, the   elements function above is not type-stable. For a type-stable iterator   approach, one should first iterate over the element types using   element_types, and then use elements(msh, E) to iterate over a   specific element type E.","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Under the hood, each element is simply a functor which maps points xÃÇ from a ReferenceShape into the physical space:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"el = first(els)\nxÃÇ = SVector(1/3,1/3, 1/3)\nel(xÃÇ)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Likewise, we can compute the jacobian of the element, or its normal at a given parametric coordinate.","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"(Image: Pluto notebook)","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"begin\n    import Pkg as _Pkg\n    haskey(ENV, \"PLUTO_PROJECT\") && _Pkg.activate(ENV[\"PLUTO_PROJECT\"])\n    using PlutoUI: TableOfContents\nend;","category":"page"},{"location":"pluto-examples/poisson/#Poisson-Problem","page":"Poisson problem","title":"Poisson Problem","text":"","category":"section"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"note: Important points covered in this example\nReformulating Poisson-like problems using integral equations\nUsing volume potentials\nCreating interior meshes using Gmsh","category":"page"},{"location":"pluto-examples/poisson/#Problem-definition","page":"Poisson problem","title":"Problem definition","text":"","category":"section"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"In this example we will solve the Poisson equation in a domain Omega with Dirichlet boundary conditions on Gamma = partial Omega:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"  beginalign*\n      -Delta u = f  quad textin  quad Omega\n      u = g  quad texton  quad Gamma\n  endalign*","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"where f  Omega to mathbbR and g  Gamma to mathbbR are given functions. To solve this problem using integral equations, we split the solution u into a particular solution u_p and a homogeneous solution u_h:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"  u = u_p + u_h","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"The function u_p is given by","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"u_p(boldsymbolr) = int_Omega G(boldsymbolr boldsymbolr) f(boldsymbolr) dboldsymbolr","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"with G the fundamental solution of -Delta.","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"The function u_h satisfies the homogeneous problem","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"  beginalign*\n      Delta u_h = 0  quad textin  quad Omega \n      u_h = g - u_p  quad texton   quad Gamma\n  endalign*","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"which can be solved using the integral equation method. In particular, for this example, we employ a double-layer formulation:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"u_h(boldsymbolr) = int_Gamma G(boldsymbolr boldsymbolr) sigma(boldsymbolr) dboldsymbolr","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"where the density function sigma solves the integral equation","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"  -fracsigma(boldsymbolx)2 + int_Gamma partial_nu_boldsymbolyG(boldsymbolx boldsymboly) sigma(boldsymboly)  mathrmd s_boldsymboly = g(boldsymbolx) - u_p(boldsymbolx)","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"In what follows we illustrate how to solve the problem in this manner.","category":"page"},{"location":"pluto-examples/poisson/#Geometry-and-mesh","page":"Poisson problem","title":"Geometry and mesh","text":"","category":"section"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"We use the Gmsh API to create a jellyfish-shaped domain and to generate a second order mesh of its interior and boundary:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"using Inti, Gmsh\nmeshsize = 0.1\ngmsh.initialize()\njellyfish = Inti.gmsh_curve(0, 2œÄ; meshsize) do s\n    r = 1 + 0.3 * cos(4 * s + 2 * sin(s))\n    return r * Inti.Point2D(cos(s), sin(s))\nend\ncl = gmsh.model.occ.addCurveLoop([jellyfish])\nsurf = gmsh.model.occ.addPlaneSurface([cl])\ngmsh.model.occ.synchronize()\ngmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\ngmsh.model.mesh.generate(2)\ngmsh.model.mesh.setOrder(2)\nmsh = Inti.import_mesh(; dim = 2)\ngmsh.finalize()","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"We can now extract components of the mesh corresponding to the Omega and Gamma domains:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"Œ© = Inti.Domain(e -> Inti.geometric_dimension(e) == 2, msh)\nŒì = Inti.boundary(Œ©)\nŒ©_msh = view(msh, Œ©)\nŒì_msh = view(msh, Œì)\nnothing #hide","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"and visualize them:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"using Meshes, GLMakie\nviz(Œ©_msh; showsegments = true)\nviz!(Œì_msh; color = :red)\nMakie.current_figure() #hide","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"To conclude the geometric setup, we need a quadrature for the volume and boundary:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"Œ©_quad = Inti.Quadrature(Œ©_msh; qorder = 4)\nŒì_quad = Inti.Quadrature(Œì_msh; qorder = 6)\nnothing #hide","category":"page"},{"location":"pluto-examples/poisson/#Integral-operators","page":"Poisson problem","title":"Integral operators","text":"","category":"section"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"We can now assemble the required volume potential. To obtain the value of the particular solution u_p on the boundary for the modified integral equation above we will need the volume integral operator mapping to points on the boundary, i.e. operator:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"using FMM2D #to accelerate the maps\nop = Inti.Laplace(; dim = 2)\n# Newtonian potential mapping domain to boundary\nV_d2b = Inti.volume_potential(;\n    op,\n    target = Œì_quad,\n    source = Œ©_quad,\n    compression = (method = :fmm, tol = 1e-12),\n    correction = (method = :dim, maxdist = 5 * meshsize, target_location = :on),\n)","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"We require also the boundary integral operators for the ensuing integral equation:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"# Single and double layer operators on Œì\nS_b2b, D_b2b = Inti.single_double_layer(;\n    op,\n    target = Œì_quad,\n    source = Œì_quad,\n    compression = (method = :fmm, tol = 1e-12),\n    correction = (method = :dim,),\n)","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"note: Note\nIn this example we used the Fast Multipole Method (:fmm) to accelerate the operators, and the Density Interpolation Method (:dim) to correct singular and nearly-singular integral.","category":"page"},{"location":"pluto-examples/poisson/#Solving-the-linear-system","page":"Poisson problem","title":"Solving the linear system","text":"","category":"section"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"We are now in a position to solve the original Poisson problem, but for that we need to specify the functions f and g. In order to verify that our numerical approximation is correct, however, we will play a different game and specify instead a manufactured solution u_e from which we will derive the functions f and g:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"# Create a manufactured solution\nu‚Çë = (x) -> cos(2 * x[1]) * sin(2 * x[2])\nf‚Çë = (x) -> 8 * cos(2 * x[1]) * sin(2 * x[2]) # -Œîu‚Çë\ng = map(q -> u‚Çë(q.coords), Œì_quad)\nf = map(q -> f‚Çë(q.coords), Œ©_quad)\nnothing #hide","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"With these, we can compute the right-hand-side of the integral equation for the homogeneous part of the solution:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"rhs = g - V_d2b * f\nnothing #hide","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"and solve the integral equation for the integral density function œÉ:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"using IterativeSolvers, LinearAlgebra\nœÉ = gmres(-I / 2 + D_b2b, rhs; abstol = 1e-8, verbose = true, restart = 1000)\nnothing #hide","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"With the density function at hand, we can now reconstruct our approximate solution:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"G = Inti.SingleLayerKernel(op)\ndG = Inti.DoubleLayerKernel(op)\nùí± = Inti.IntegralPotential(G, Œ©_quad)\nùíü = Inti.IntegralPotential(dG, Œì_quad)\nu = (x) -> ùí±[f](x) + ùíü[œÉ](x)","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"and evaluate it at any point in the domain:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"x = Inti.Point2D(0.1, 0.4)\nprintln(\"error at $x: \", u(x) - u‚Çë(x))","category":"page"},{"location":"pluto-examples/poisson/#Solution-evaluation-and-visualization","page":"Poisson problem","title":"Solution evaluation and visualization","text":"","category":"section"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"Although we have \"solved\" the problem in the previous section, using the anonymous function u to evaluate the field is neither efficient nor accurate when there are either many points to evaluate, or when they lie close to the domain Omega. The fundamental reason for this is the usual: the integral operators in the function u are dense matrices, and their evaluation inside or near to Omega suffers from inaccurate singular and near-singular quadrature.","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"To address this issue, we need to assemble accelerated and corrected versions of the integral operators. Let us suppose we wish to evaluate the solution u at all the quadrature nodes of Omega:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"V_d2d = Inti.volume_potential(;\n    op,\n    target = Œ©_quad,\n    source = Œ©_quad,\n    compression = (method = :fmm, tol = 1e-8),\n    correction = (method = :dim,),\n)","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"Likewise, we need operators mapping densities from our boundary quadrature to our mesh nodes:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"S_b2d, D_b2d = Inti.single_double_layer(;\n    op,\n    target = Œ©_quad,\n    source = Œì_quad,\n    compression = (method = :fmm, tol = 1e-8),\n    correction = (method = :dim, maxdist = 2 * meshsize, target_location = :inside),\n)","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"We now evaluate the solution at all quadrature nodes and compare it to the manufactured:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"u_quad = V_d2d * f + D_b2d * œÉ\ner_quad = u_quad - map(q -> u‚Çë(q.coords), Œ©_quad)\nprintln(\"maximum error at all quadrature nodes: \", norm(er_quad, Inf))\nnothing #hide","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"Lastly, let us visualize the solution and the error on the mesh nodes using quadrature_to_node_vals:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"nodes = Inti.nodes(Œ©_msh)\nu_nodes = Inti.quadrature_to_node_vals(Œ©_quad, u_quad)\ner = u_nodes - map(u‚Çë, nodes)\ncolorrange = extrema(u_nodes)\nfig = Figure(; size = (800, 300))\nax = Axis(fig[1, 1]; aspect = DataAspect())\nviz!(Œ©_msh; colorrange, color = u_nodes, interpolate = true)\ncb = Colorbar(fig[1, 2]; label = \"u\", colorrange)\n# plot error\nlog_er = log10.(abs.(er))\ncolorrange = extrema(log_er)\ncolormap = :inferno\nax = Axis(fig[1, 3]; aspect = DataAspect())\nviz!(Œ©_msh; colorrange, colormap, color = log_er, interpolate = true)\ncb = Colorbar(fig[1, 4]; label = \"log‚ÇÅ‚ÇÄ|u - u‚Çë|\", colormap, colorrange)\nfig #hide","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"TableOfContents()","category":"page"},{"location":"tutorials/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"CurrentModule = Inti","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"note: Important points covered in this tutorial\nCreate a domain and its accompanying mesh\nSolve a basic boundary integral equation\nVisualize the solution","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"This first tutorial will be a guided tour through the basic steps of setting up a boundary integral equation and solving it using Inti.jl. ","category":"page"},{"location":"tutorials/getting_started/#Mathematical-formulation","page":"Getting started","title":"Mathematical formulation","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"We will consider the classic Helmholtz scattering problem in 2D, and solve it using a direct boundary integral formulation. More precisely, letting Omega subset mathbbR^2 be a bounded domain, and denoting by Gamma = partial Omega its boundary, we will solve the following Helmholtz problem:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"beginaligned\n    Delta u + k^2 u  = 0 quad textin quad mathbbR^2 setminus overlineOmega\n    partial_nu u = g quad texton quad Gamma\n    sqrtr left( fracpartial upartial r - i k u right) = o(1) quad textas quad r = boldsymbolx to infty\nendaligned","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"where g is the given boundary datum, nu is the outward unit normal to Gamma, and k is the constant wavenumber. The last condition is the Sommerfeld radiation condition, and is required to ensure the uniqueness of the solution; physically, it means that the solution sought should radiate energy towards infinity.","category":"page"},{"location":"tutorials/getting_started/#PDE,-geometry,-and-mesh","page":"Getting started","title":"PDE, geometry, and mesh","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"The first step is to define the PDE under consideration:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"using Inti\nInti.stack_weakdeps_env!() # add weak dependencies \n# PDE\nk = 2œÄ\nop = Inti.Helmholtz(; dim = 2, k)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Next, we generate the geometry of the problem. For this tutorial, we will manually create parametric curves representing the boundary of the domain using the parametric_curve function:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"using StaticArrays # for SVector\n# Create the geometry as the union of a kite and a circle\nkite = Inti.parametric_curve(0.0, 1.0; labels = [\"kite\"]) do s\n    return SVector(2.5 + cos(2œÄ * s[1]) + 0.65 * cos(4œÄ * s[1]) - 0.65, 1.5 * sin(2œÄ * s[1]))\nend\ncircle = Inti.parametric_curve(0.0, 1.0; labels = [\"circle\"]) do s\n    return SVector(cos(2œÄ * s[1]), sin(2œÄ * s[1]))\nend\nŒì = kite ‚à™ circle","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Inti.jl expects the parametrization of the curve to be a function mapping scalars to points in space represented by SVectors. The labels argument is optional, and can be used to identify the different parts of the boundary. The Domain object Œì represents the boundary of the geometry, and can be used to create a mesh:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# Create a mesh for the geometry\nmsh = Inti.meshgen(Œì; meshsize = 2œÄ / k / 10)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"To visualize the mesh, we can load Meshes.jl and one of Makie's backends:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"using Meshes, GLMakie\nviz(msh; segmentsize = 3, axis = (aspect = DataAspect(), ), figure = (; size = (400,300)))","category":"page"},{"location":"tutorials/getting_started/#Quadrature","page":"Getting started","title":"Quadrature","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Once the mesh is created, we can define a quadrature to be used in the discretization of the integral operators:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# Create a quadrature\nQ = Inti.Quadrature(msh; qorder = 5)\nnothing # hide","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"A Quadrature is simply a collection of QuadratureNode objects:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Q[1]","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"In the constructor above we specified a quadrature order of 5, and Inti.jl internally picked a ReferenceQuadrature suitable for the specified order; for finer control, a quadrature rule can be specified directly.","category":"page"},{"location":"tutorials/getting_started/#Integral-operators","page":"Getting started","title":"Integral operators","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"To continue, we need to reformulate the Helmholtz problem as a boundary integral equation. Among the plethora of options, we will use in this tutorial a simple direct formulation, which uses Green's third identity to relate the values of u and partial_nu u on Gamma:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"    -fracu(boldsymbolx)2 + Du(boldsymbolx) = Spartial_nu u(boldsymbolx) quad boldsymbolx in Gamma","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Here S and D are the single- and double-layer operators, formally defined as:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"    Ssigma(boldsymbolx) = int_Gamma G(boldsymbolx boldsymboly) sigma(boldsymboly)  mathrmds(boldsymboly) quad\n    Dsigma(boldsymbolx) = int_Gamma fracpartial Gpartial nu_boldsymboly(boldsymbolx boldsymboly) sigma(boldsymboly)  mathrmds(boldsymboly)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"where","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"G(boldsymbolx boldsymboly) = fraci4 H^(1)_0(kboldsymbolx -\nboldsymboly)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"is the fundamental solution of the Helmholtz equation, with H^(1)_0 being the Hankel function of the first kind. Note that G is singular when boldsymbolx = boldsymboly, and therefore the numerical discretization of S and D requires special care.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"To approximate S and D, we can proceed as follows:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"S, D = Inti.single_double_layer(;\n    op,\n    target = Q,\n    source = Q,\n    compression = (method = :none,),\n    correction = (method = :dim,),\n)\nnothing # hide","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Much of the complexity involved in the numerical computation is hidden in the function above; later in the tutorials we will discuss in more details the options available for the compression and correction methods, as well as how to define custom kernels and operators. For now, it suffices to know that S and D are matrix-like objects that can be used to solve the boundary integral equation. For that, we need to provide the boundary data g.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"tip: Fast algorithms\nPowered by external libraries, Inti.jl supports several acceleration methods for matrix-vector multiplication, including so far:Fast multipole method (FMM) mapsto correction = (method = :fmm, tol = 1e-8)\nHierarchical matrix (H-matrix) mapsto correction = (method = :hmatrix, tol = 1e-8)Note that in such cases only the matrix-vector product may not be available, and therefore iterative solvers such as GMRES are required for the solution of the resulting linear systems.","category":"page"},{"location":"tutorials/getting_started/#Source-term-and-solution","page":"Getting started","title":"Source term and solution","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"We are interested in the scattered field u produced by an incident plane wave u_i = e^i k boldsymbold cdot boldsymbolx, where boldsymbold is a unit vector denoting the direction of the plane wave. Assuming that the total field u_t = u_i + u satisfies a homogenous Neumann condition on Gamma, and that the scattered field u satisfies the Sommerfeld radiation condition, we can write the boundary condition as:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"    partial_nu u = -partial_nu u_i quad boldsymbolx in Gamma","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"We can thus solve the boundary integral equation to find u on Gamma:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"using LinearAlgebra\n# define the incident field and compute its normal derivative\nŒ∏ = 0\nd = SVector(cos(Œ∏), sin(Œ∏))\ng = map(Q) do q\n    # normal derivative of e^{ik*d‚Éó‚ãÖx}\n    x, ŒΩ = q.coords, q.normal\n    return -im * k * exp(im * k * dot(x, d)) * dot(d, ŒΩ)\nend ## Neumann trace on boundary\nu = (-I / 2 + D) \\ (S * g) # Dirichlet trace on boundary\nnothing # hide","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"note: Iterating over a quadrature\nIn computing g above, we used map to evaluate the incident field at   all quadrature nodes. When iterating over Q, the iterator returns a   QuadratureNode, and not simply the coordinate   of the quadrature node. This is so that we can access additional   information, such as the normal vector, at the quadrature node.","category":"page"},{"location":"tutorials/getting_started/#Integral-representation-and-visualization","page":"Getting started","title":"Integral representation and visualization","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Now that we know both the Dirichlet and Neumann data on the boundary, we can use Green's representation formula, i.e.,","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"    mathcalDu(boldsymbolr) - mathcalSpartial_nu u(boldsymbolr) = begincases\n        u(boldsymbolr)  textif  boldsymbolr in mathbbR^2 setminus overlineOmega\n        0  textif  boldsymbolr in Omega\n    endcases","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"where mathcalD and mathcalS are the double- and single-layer potentials defined as:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"    mathcalSsigma(boldsymbolr) = int_Gamma G(boldsymbolr boldsymboly) sigma(boldsymboly)  mathrmds(boldsymboly) quad\n    mathcalDsigma(boldsymbolr) = int_Gamma fracpartial Gpartial nu_boldsymboly(boldsymbolr boldsymboly) sigma(boldsymboly)  mathrmds(boldsymboly)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"to compute the solution u in the domain:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"ùíÆ, ùíü = Inti.single_double_layer_potential(; op, source = Q)\nu‚Çõ = x -> ùíü[u](x) - ùíÆ[g](x)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"To wrap things up, let's visualize the scattered field:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"xx = yy = range(-5; stop = 5, length = 100)\nU = map(u‚Çõ, Iterators.product(xx, yy))\nUi = map(x -> exp(im*k*dot(x, d)), Iterators.product(xx, yy))\nUt = Ui + U\nfig, ax, hm = heatmap(\n    xx,\n    yy,\n    real(Ut);\n    colormap = :inferno,\n    interpolate = true,\n    axis = (aspect = DataAspect(), xgridvisible = false, ygridvisible = false),\n)\nviz!(msh; segmentsize = 2)\nColorbar(fig[1, 2], hm; label = \"real(u)\")\nfig # hide","category":"page"},{"location":"tutorials/getting_started/#Accuracy-check","page":"Getting started","title":"Accuracy check","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"The scattering example above does not provide an easy way to check the accuracy of the solution. To do so, we can manufacture an exact solution and compare it to the solution obtained numerically, as illustrated below:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# build an exact solution\nG = Inti.SingleLayerKernel(op)\ndG = Inti.DoubleLayerKernel(op)\nxs = map(Œ∏ -> 0.5 * rand() * SVector(cos(Œ∏), sin(Œ∏)), 2œÄ * rand(10))\ncs = rand(ComplexF64, length(xs))\nu‚Çë  = q -> sum(c * G(x, q) for (x, c) in zip(xs, cs))\n‚àÇ‚Çôu = q -> sum(c * dG(x, q) for (x, c) in zip(xs, cs))\ng  = map(‚àÇ‚Çôu, Q) \nu = (-I / 2 + D) \\ (S * g)\nu‚Çõ = x -> ùíü[u](x) - ùíÆ[g](x)\npts = [5*SVector(cos(Œ∏), sin(Œ∏)) for Œ∏ in range(0, 2œÄ, length = 100)]\ner = norm(u‚Çõ.(pts) - u‚Çë.(pts), Inf)\nprintln(\"maximum error on circle of radius 5: $er\")","category":"page"},{"location":"#Inti","page":"Home","title":"Inti","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Inti","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: codecov) (Image: Aqua)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Inti.jl is a Julia library for the numerical solution of boundary and volume integral equations. It offers routines for assembling and solving the linear systems that result from applying the Nystr√∂m discretization method. Designed for flexibility and efficiency, the package currently supports the following features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Specialized integration routines for computing singular and nearly-singular integrals.\nIntegrated support for acceleration routines, including the Fast Multipole Method (FMM) and Hierarchical Matrices, by wrapping external libraries.\nPredefined kernels and integral operators for partial differential equations (PDEs) commonly found in mathematical physics (e.g. Laplace, Helmholtz, Stokes).\nSupport for complex geometries in 2D and 3D, either through native parametric representations or by importing mesh files from external sources.\nEfficient construction of complex integral operators from simpler ones through lazy composition.","category":"page"},{"location":"#Installing-Julia","page":"Home","title":"Installing Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Download Julia from julialang.org, or use juliaup installer. We recommend using the latest stable version of Julia, although Inti.jl should work with >=v1.9.","category":"page"},{"location":"#Installing-Inti.jl","page":"Home","title":"Installing Inti.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Inti.jl is registered in the Julia General registry and can be installed by  launching a Julia REPL and typing the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add Inti","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, one can install the latest version of Inti.jl from the main branch using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(;url = \"https://github.com/IntegralEquations/Inti.jl\", rev = \"main\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Change rev if a different branch or a specific commit hash is desired.","category":"page"},{"location":"#Installing-weak-dependencies","page":"Home","title":"Installing weak dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Inti.jl comes with a set of optional dependencies that can be installed on demand. These provide additional features which can be useful in certain scenarios (e.g. visualization, meshing, acceleration). For convenience, Inti.jl provides the stack_weakdeps_env! function to install all the weak dependencies at once:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Inti\nInti.stack_weakdeps_env!(; verbose = false, update = true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the first time you run this command, it may take a while to download and compile the dependencies. Subsequent runs will be faster. If preferred,  extensions can be manually controlled by Pkg.adding the desired packages from the list above.","category":"page"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Inti.jl can be used to solve a variety of linear partial differential equations by recasting them as integral equations. The general workflow for solving a problem consists of the following steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"    underbracefboxGeometry rightarrow fboxMesh_textbfpre-processing rightarrow fboxcolorredSolver rightarrow underbracefboxVisualization_textbfpost-processing","category":"page"},{"location":"","page":"Home","title":"Home","text":"Geometry: Define the domain of interest using simple shapes (e.g., circles, rectangles) or more complex CAD models.\nMesh: Create a mesh to approximate the geometry. The mesh is used to define a quadrature and discretize the boundary integral equation.\nSolver: With a mesh and an accompanying quadrature, Inti.jl's routines provide ways to assemble and solve the system of equations arising from the discretization of the integral operators. The core of the library lies in service of this step.\nVisualization: Visualize the solution using a plotting library such as Makie.jl, or export it to a file for further analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As a simple example illustrating the steps above, consider an interior Laplace problem, in two dimensions, with Dirichlet boundary conditions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nDelta u = 0 quad textin  Omega \nu = g quad texton  Gamma\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where Omega subset mathbbR^2 is a sufficiently smooth domain, and Gamma = partial Omega its boundary. A boundary integral reformulation can be achieved by e.g. searching for the solution u in the form of a single-layer potential:","category":"page"},{"location":"","page":"Home","title":"Home","text":"u(boldsymbolr) = int_Gamma G(boldsymbolrboldsymboly)sigma(boldsymboly)  mathrmdGamma(boldsymboly)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where sigma  Gamma to mathbbR is an unknown density function, and G is the fundamental solution of the Laplace equation. This ansatz is, by construction, an exact solution to the PDE on Omega. Imposing the boundary condition on Gamma leads to the following integral equation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"    int_Gamma G(boldsymbolxboldsymboly)sigma(boldsymboly)  mathrmdGamma(boldsymboly) = g(boldsymbolx) quad forall boldsymbolx in Gamma","category":"page"},{"location":"","page":"Home","title":"Home","text":"Expressing the problem above in Inti.jl looks like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Inti, LinearAlgebra, StaticArrays\n# create a geometry given by a function f : [0,1] ‚Üí Œì ‚äÇ R^2. \ngeo = Inti.parametric_curve(0, 1) do s\n    SVector(0.25, 0.0) + SVector(cos(2œÄ * s) + 0.65 * cos(4œÄ * s[1]) - 0.65, 1.5 * sin(2œÄ * s))\nend\nŒì = Inti.Domain(geo)\n# create a mesh and quadrature\nmsh = Inti.meshgen(Œì; meshsize = 0.1)\nQ = Inti.Quadrature(msh; qorder = 5)\n# create the integral operators\nop = Inti.Laplace(;dim=2)\nS, _ = Inti.single_double_layer(;\n    op, \n    target = Q,\n    source = Q,\n    compression = (method = :none,),\n    correction = (method = :dim,)\n)\n# manufacture a harmonic function (exact solution) and take its trace on Œì\nu‚Çë = x -> x[1] + x[2] + x[1]*x[2] + x[1]^2 - x[2]^2  - 2 * log(norm(x .- SVector(-0.5, -1.5)))\ng = map(q -> u‚Çë(q.coords), Q) # value at quad nodes\n# solve for œÉ\nœÉ = S \\ g\n# use the single-layer potential to evaluate the solution\nùíÆ, ùíü = Inti.single_double_layer_potential(; op, source = Q)\nu‚Çï = x -> ùíÆ[œÉ](x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The function u‚Çï is now a numerical approximation of the solution to the Laplace equation, and can be evaluated at any point in the domain:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pt = SVector(0.5, 0.1)\nprintln(\"Exact value at $pt:   \", u‚Çë(pt))\nprintln(\"Approx. value at $pt: \", u‚Çï(pt))","category":"page"},{"location":"","page":"Home","title":"Home","text":"If we care about the solution on the entire domain, we can visualize it using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Meshes, GLMakie # trigger the loading of some Inti extensions\nxx = yy = range(-2, 2, length = 100)\nfig = Figure(; size = (600,300))\ninside = x -> Inti.isinside(x, Q) \nopts = (xlabel = \"x\", ylabel = \"y\", aspect = DataAspect())\nax1 = Axis(fig[1, 1]; title = \"Exact solution\", opts...)\nh1 = heatmap!(ax1, xx,yy,(x, y) -> inside((x,y)) ? u‚Çë((x,y)) : NaN)\nviz!(msh; segmentsize = 3)\ncb = Colorbar(fig[1, 3], h1, size = 20, height = 200)\nax2 = Axis(fig[1, 2]; title = \"Approx. solution\", opts...)\nh2 = heatmap!(ax2, xx,yy, (x, y) -> inside((x,y)) ? u‚Çï((x,y)) : NaN, colorrange = cb.limits[])\nviz!(msh; segmentsize = 3)\nfig # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Formulation of the problem as an integral equation\nGiven a PDE and boundary conditions, there are often many ways to recast the problem as an integral equation, and the choice of formulation plays an important role in the unique solvability, efficiency, and accuracy of the numerical solution. Inti.jl provides a flexible framework for experimenting with different formulations, but it is up to the user to choose the most appropriate one for their problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"While the example above is a simple one, Inti.jl can handle significantly more complex problems involving multiple domains, heterogeneous coefficients, vector-valued PDEs, and three-dimensional geometries. The best way to dive deeper into Inti.jl's capabilities is the tutorials section. More advanced usage can be found in the examples section.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are several ways to contribute to Inti.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Reporting bugs: If you encounter a bug, please open an issue on the GitHub. If possible, please include a minimal working example that reproduces the problem.\nExamples: If you have a cool example that showcases Inti.jl's capabilities, consider submitting a PR to add it to the examples section.\nContributing code: If you would like to contribute code to Inti.jl, please fork the repository and submit a pull request. Feel free to open a draft PR early in the development process to get feedback on your changes.\nFeature requests: If you have an idea for a new feature or improvement, we would love to hear about it.\nDocumentation: If you find any part of the documentation unclear or incomplete, please let us know. Or even better, submit a PR with the improved documentation.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"}]
}

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Correction methods · Inti.jl</title><meta name="title" content="Correction methods · Inti.jl"/><meta property="og:title" content="Correction methods · Inti.jl"/><meta property="twitter:title" content="Correction methods · Inti.jl"/><meta name="description" content="Documentation for Inti.jl."/><meta property="og:description" content="Documentation for Inti.jl."/><meta property="twitter:description" content="Documentation for Inti.jl."/><meta property="og:url" content="https://IntegralEquations.github.io/Inti.jl/tutorials/correction_methods/"/><meta property="twitter:url" content="https://IntegralEquations.github.io/Inti.jl/tutorials/correction_methods/"/><link rel="canonical" href="https://IntegralEquations.github.io/Inti.jl/tutorials/correction_methods/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Inti.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../geo_and_meshes/">Geometry and meshes</a></li><li><a class="tocitem" href="../integral_operators/">Integral operators</a></li><li><a class="tocitem" href="../layer_potentials/">Layer potentials</a></li><li><a class="tocitem" href="../compression_methods/">Compression methods</a></li><li class="is-active"><a class="tocitem" href>Correction methods</a><ul class="internal"><li><a class="tocitem" href="#Adaptive-Correction"><span>Adaptive Correction</span></a></li><li><a class="tocitem" href="#Boundary-Density-Interpolation-Method"><span>Boundary Density Interpolation Method</span></a></li><li><a class="tocitem" href="#Volume-density-interpolation-method"><span>Volume density interpolation method</span></a></li></ul></li><li><a class="tocitem" href="../solvers/">Linear solvers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../pluto-examples/toy_example/">Toy example</a></li><li><a class="tocitem" href="../../pluto-examples/helmholtz_scattering/">Helmholtz scattering</a></li><li><a class="tocitem" href="../../pluto-examples/poisson/">Poisson problem</a></li><li><a class="tocitem" href="../../examples/heat_equation/">Heat equation</a></li><li><a class="tocitem" href="../../examples/stokes_drag/">Stokes drag</a></li><li><a class="tocitem" href="../../examples/crack_elasticity/">Elastic crack</a></li><li><a class="tocitem" href="../../examples/pep/">Plasmonic eigenvalues</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../docstrings/">Docstrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Correction methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Correction methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl/blob/main/docs/src/tutorials/correction_methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Correction-methods"><a class="docs-heading-anchor" href="#Correction-methods">Correction methods</a><a id="Correction-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Correction-methods" title="Permalink"></a></h1><div class="admonition is-info" id="Important-Points-Covered-in-This-Tutorial-8fac6d5fa8bdf251"><header class="admonition-header">Important Points Covered in This Tutorial<a class="admonition-anchor" href="#Important-Points-Covered-in-This-Tutorial-8fac6d5fa8bdf251" title="Permalink"></a></header><div class="admonition-body"><ul><li>Overview of the correction methods available in Inti.jl.</li><li>Details and limitations of the various correction methods.</li><li>Guidelines on how to choose a correction method.</li></ul></div></div><p>When the underlying kernel is singular, a <em>correction</em> is usually necessary to obtain accurate results in the approximation of the underlying integral operator by a quadrature. Currently, Inti.jl provides the following functions to correct for singularities:</p><ul><li><a href="../../docstrings/#Inti.adaptive_correction-Tuple{Inti.IntegralOperator}"><code>adaptive_correction</code></a></li><li><a href="../../docstrings/#Inti.bdim_correction-Tuple{Any, Any, Inti.Quadrature, Any, Any}"><code>bdim_correction</code></a></li><li><a href="../../docstrings/#Inti.vdim_correction-Union{Tuple{SHIFT}, Tuple{Any, Any, Inti.Quadrature, Inti.Quadrature, Any, Any, Any}} where SHIFT"><code>vdim_correction</code></a></li></ul><p>Each method has its own strengths and weaknesses, which will be discussed in the following sections.</p><div class="admonition is-info" id="High-Level-API-89ac88d3c9f49450"><header class="admonition-header">High-Level API<a class="admonition-anchor" href="#High-Level-API-89ac88d3c9f49450" title="Permalink"></a></header><div class="admonition-body"><p>The <a href="../../docstrings/#Inti.single_double_layer-Tuple{}"><code>single_double_layer</code></a>, <a href="../../docstrings/#Inti.adj_double_layer_hypersingular-Tuple{}"><code>adj_double_layer_hypersingular</code></a>, and <a href="../../docstrings/#Inti.volume_potential-Tuple{}"><code>volume_potential</code></a> functions provide a high-level API with a <code>correction</code> keyword argument. This allows users to specify the correction method to use when constructing the integral operators. See the documentation of these functions for more details.</p></div></div><h2 id="Adaptive-Correction"><a class="docs-heading-anchor" href="#Adaptive-Correction">Adaptive Correction</a><a id="Adaptive-Correction-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-Correction" title="Permalink"></a></h2><p>The <a href="../../docstrings/#Inti.adaptive_correction-Tuple{Inti.IntegralOperator}"><code>adaptive_correction</code></a> method combines adaptive quadrature for nearly singular integrals with a direct evaluation method for singular integrals, based on [<a href="../../references/#guiggiani1992general">8</a>]. It is a robust method suitable for a wide range of kernels, as long as the singularities are no worse than a Hadamard finite-part (e.g., <span>$1/r^3$</span> in 3D and <span>$1/r^2$</span> in 2D). This makes it a good default choice for most problems.</p><h3 id="Strengths"><a class="docs-heading-anchor" href="#Strengths">Strengths</a><a id="Strengths-1"></a><a class="docs-heading-anchor-permalink" href="#Strengths" title="Permalink"></a></h3><ul><li>Robust method that works for a wide range of kernels.</li><li>Conceptually straightforward and easy to use.</li><li>Handles open surfaces.</li></ul><h3 id="Weaknesses"><a class="docs-heading-anchor" href="#Weaknesses">Weaknesses</a><a id="Weaknesses-1"></a><a class="docs-heading-anchor-permalink" href="#Weaknesses" title="Permalink"></a></h3><ul><li>Can be slow for large problems and high accuracy requirements.</li><li>Sometimes difficult to tune parameters for optimal performance.</li><li>Round-off errors in certain cases can make achieving high accuracy challenging.</li></ul><h3 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.adaptive_correction-tutorials-correction_methods" href="#Inti.adaptive_correction-tutorials-correction_methods"><code>Inti.adaptive_correction</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adaptive_correction(iop::IntegralOperator; [maxdist, atol, rtol, threads = true, kwargs...])
adaptive_correction(iop::IntegralOperator, maxdist, quads_dict::Dict, threads = true)</code></pre><p>This function computes a sparse correction for the integral operator <code>iop</code>, addressing its singular or nearly singular entries.</p><p>The parameter <code>maxdist</code> specifies the maximum distance between target points and source elements to be considered for correction (only interactions within this distance are corrected).</p><p>The parameters <code>atol</code> and <code>rtol</code> define the absolute and relative tolerances for the adaptive quadrature used to compute the corrections for singular or nearly singular entries.</p><p>Additional <code>kwargs</code> arguments are passed to <a href="../../docstrings/#Inti.adaptive_quadrature-Tuple{Inti.ReferenceHyperCube{1}}"><code>adaptive_quadrature</code></a>; see its documentation for more information.</p><p>Selecting <code>maxdist</code> and <code>(atol,rtol)</code> involves balancing accuracy and computational cost. A smaller <code>maxdist</code> reduces the number of corrections but may impact accuracy. Conversely, a smaller tolerance improves correction accuracy but increases computational expense. The ideal values depend on the kernel and the mesh/quadrature rule applied.</p><p>By default, <code>maxdist</code> and <code>(atol,rtol)</code> are estimated using the <a href="../../docstrings/#Inti.local_correction_dist_and_tol"><code>local_correction_dist_and_tol</code></a>, but it is often possible to improve performance by manually tuning these parameters.</p><p><strong>Advanced usage</strong></p><p>For finer control, you can provide a dictionary <code>quads_dict</code> that contains quadrature rules for each reference element type present in the mesh of <code>source(iop)</code>. This allows you to fine-tune the quadrature rules for specific element types (e.g. use a fixed quadrature rule instead of an adaptive one).</p><p>The dictionary <code>quads_dict</code> must adhere to the following structure:</p><ul><li><code>quads_dict[E].nearfield_quad</code>: A function that integrates over the nearfield of the reference element type <code>E</code>. Used in the nearly-singular correction.</li><li><code>quads_dict[E].radial_quad</code>: A function that integrates over the radial direction of the reference element type <code>E</code>. Used in the singular correction.</li><li><code>quads_dict[E].angular_quad</code>: A function that integrates over the angular direction of the reference element type <code>E</code>. Used in the singular correction.</li></ul><p>Here is an example of how to implement a custom <code>quads_dict</code> given an <code>iop</code>:</p><pre><code class="language-julia hljs">quads_dict = Dict()
msh = Inti.mesh(source(iop))
for E in Inti.element_types(msh)
    ref_domain = Inti.reference_domain(E)
    quads = (
        nearfield_quad = Inti.adaptive_quadrature(ref_domain; atol),
        radial_quad    = Inti.GaussLegendre(;order=5),
        angular_quad   = Inti.GaussLegendre(;order=20),
    )
    quads_dict[E] = quads
end</code></pre><p>This will use an adaptive quadrature rule for the nearfield and fixed Gauss-Legendre quadrature rules for the radial and angular directions when computing the singular correction in polar coordinates on the reference domain. You can then call <code>adaptive_correction(iop, maxdist, quads_dict)</code> to use the custom quadrature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/451edc6eee0a9c4dc50eaeab9e5143b9f101abde/src/adaptive_correction.jl#L1-L63">source</a></section></article><h2 id="Boundary-Density-Interpolation-Method"><a class="docs-heading-anchor" href="#Boundary-Density-Interpolation-Method">Boundary Density Interpolation Method</a><a id="Boundary-Density-Interpolation-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Density-Interpolation-Method" title="Permalink"></a></h2><p>The <a href="../../docstrings/#Inti.bdim_correction-Tuple{Any, Any, Inti.Quadrature, Any, Any}"><code>bdim_correction</code></a> method implements the general-purpose version of the density interpolation method proposed in [<a href="../../references/#faria2021general">9</a>]. Is a global correction method that uses solutions of the underlying PDE, together with Green&#39;s identities, to interpolate the density on the boundary. It works best for low to moderate-order quadratures and is particularly useful for smooth boundaries when the PDE.</p><h3 id="Strengths-2"><a class="docs-heading-anchor" href="#Strengths-2">Strengths</a><a class="docs-heading-anchor-permalink" href="#Strengths-2" title="Permalink"></a></h3><ul><li>Can be faster and more accurate for standard problems, such as scattering by closed surfaces.</li><li>Easier parameter tuning, as it only requires knowing whether the target surface is inside, outside, or on the boundary of the source.</li></ul><h3 id="Weaknesses-2"><a class="docs-heading-anchor" href="#Weaknesses-2">Weaknesses</a><a class="docs-heading-anchor-permalink" href="#Weaknesses-2" title="Permalink"></a></h3><ul><li>Only suitable for closed surfaces.</li><li>The underlying kernel must be related to the fundamental solution of a PDE.</li></ul><h3 id="Docstrings-2"><a class="docs-heading-anchor" href="#Docstrings-2">Docstrings</a><a class="docs-heading-anchor-permalink" href="#Docstrings-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.bdim_correction-tutorials-correction_methods" href="#Inti.bdim_correction-tutorials-correction_methods"><code>Inti.bdim_correction</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bdim_correction(op,X,Y,S,D; green_multiplier, kwargs...)</code></pre><p>Given a <code>op</code> and a (possibly inaccurate) discretizations of its single and double-layer operators <code>S</code> and <code>D</code> (taking a vector of values on <code>Y</code> and returning a vector on of values on <code>X</code>), compute corrections <code>δS</code> and <code>δD</code> such that <code>S + δS</code> and <code>D + δD</code> are more accurate approximations of the underlying single- and double-layer integral operators.</p><p>See [<a href="../../references/#faria2021general">9</a>] for more details on the method.</p><p><strong>Arguments</strong></p><p><strong>Required:</strong></p><ul><li><code>op</code> must be an <a href="../../docstrings/#Inti.AbstractDifferentialOperator"><code>AbstractDifferentialOperator</code></a></li><li><code>Y</code> must be a <a href="../getting_started/#Quadrature"><code>Quadrature</code></a> object of a closed surface</li><li><code>X</code> is either inside, outside, or on <code>Y</code></li><li><code>S</code> and <code>D</code> are approximations to the single- and double-layer operators for <code>op</code> taking densities in <code>Y</code> and returning densities in <code>X</code>.</li><li><code>green_multiplier</code> (keyword argument) is a vector with the same length as <code>X</code> storing the value of <code>μ(x)</code> for <code>x ∈ X</code> in the Green identity <code>S\[γ₁u\](x) - D\[γ₀u\](x) + μ*u(x) = 0</code>. See <a href="../../docstrings/#Inti._green_multiplier-Tuple{Symbol}"><code>_green_multiplier</code></a>.</li></ul><p><strong>Optional <code>kwargs</code>:</strong></p><ul><li><code>parameters::DimParameters</code>: parameters associated with the density interpolation method</li><li><code>derivative</code>: if true, compute the correction to the adjoint double-layer and hypersingular operators instead. In this case, <code>S</code> and <code>D</code> should be replaced by a (possibly innacurate) discretization of adjoint double-layer and hypersingular operators, respectively.</li><li><code>maxdist</code>: distance beyond which interactions are considered sufficiently far so that no correction is needed. This is used to determine a threshold for nearly-singular corrections when <code>X</code> and <code>Y</code> are different surfaces. When <code>X === Y</code>, this is not needed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/451edc6eee0a9c4dc50eaeab9e5143b9f101abde/src/bdim.jl#L12-L49">source</a></section></article><h2 id="Volume-density-interpolation-method"><a class="docs-heading-anchor" href="#Volume-density-interpolation-method">Volume density interpolation method</a><a id="Volume-density-interpolation-method-1"></a><a class="docs-heading-anchor-permalink" href="#Volume-density-interpolation-method" title="Permalink"></a></h2><p>TODO</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../compression_methods/">« Compression methods</a><a class="docs-footer-nextpage" href="../solvers/">Linear solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Thursday 23 October 2025 19:06">Thursday 23 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

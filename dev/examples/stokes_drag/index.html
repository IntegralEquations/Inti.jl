<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stokes drag ¬∑ Inti.jl</title><meta name="title" content="Stokes drag ¬∑ Inti.jl"/><meta property="og:title" content="Stokes drag ¬∑ Inti.jl"/><meta property="twitter:title" content="Stokes drag ¬∑ Inti.jl"/><meta name="description" content="Documentation for Inti.jl."/><meta property="og:description" content="Documentation for Inti.jl."/><meta property="twitter:description" content="Documentation for Inti.jl."/><meta property="og:url" content="https://IntegralEquations.github.io/Inti.jl/examples/stokes_drag/"/><meta property="twitter:url" content="https://IntegralEquations.github.io/Inti.jl/examples/stokes_drag/"/><link rel="canonical" href="https://IntegralEquations.github.io/Inti.jl/examples/stokes_drag/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Inti.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/getting_started/">Getting started</a></li><li><a class="tocitem" href="../../tutorials/geo_and_meshes/">Geometry and meshes</a></li><li><a class="tocitem" href="../../tutorials/integral_operators/">Integral operators</a></li><li><a class="tocitem" href="../../tutorials/layer_potentials/">Layer potentials</a></li><li><a class="tocitem" href="../../tutorials/compression_methods/">Compression methods</a></li><li><a class="tocitem" href="../../tutorials/correction_methods/">Correction methods</a></li><li><a class="tocitem" href="../../tutorials/solvers/">Linear solvers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../pluto-examples/toy_example/">Toy example</a></li><li><a class="tocitem" href="../../pluto-examples/helmholtz_scattering/">Helmholtz scattering</a></li><li><a class="tocitem" href="../../pluto-examples/poisson/">Poisson problem</a></li><li><a class="tocitem" href="../heat_equation/">Heat equation</a></li><li class="is-active"><a class="tocitem" href>Stokes drag</a><ul class="internal"><li><a class="tocitem" href="#Problem-description"><span>Problem description</span></a></li><li><a class="tocitem" href="#Discretization"><span>Discretization</span></a></li><li><a class="tocitem" href="#Solution-and-drag-force-computation"><span>Solution and drag force computation</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../crack_elasticity/">Elastic crack</a></li><li><a class="tocitem" href="../pep/">Plasmonic eigenvalues</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../docstrings/">Docstrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Stokes drag</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Stokes drag</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl/blob/main/docs/src/examples/stokes_drag.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Stokes-Drag"><a class="docs-heading-anchor" href="#Stokes-Drag">Stokes Drag</a><a id="Stokes-Drag-1"></a><a class="docs-heading-anchor-permalink" href="#Stokes-Drag" title="Permalink"></a></h1><div class="admonition is-info" id="Important-points-covered-in-this-example-270adbf6892f55de"><header class="admonition-header">Important points covered in this example<a class="admonition-anchor" href="#Important-points-covered-in-this-example-270adbf6892f55de" title="Permalink"></a></header><div class="admonition-body"><ul><li>Solving a vector-valued problem</li><li>Usage of curved triangular mesh</li><li>Post-processing integral quantities</li></ul></div></div><h2 id="Problem-description"><a class="docs-heading-anchor" href="#Problem-description">Problem description</a><a id="Problem-description-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-description" title="Permalink"></a></h2><p>In this example, we solve the classical Stokes drag problem, which models the drag force experienced by a sphere moving through a viscous fluid. The governing equations are the Stokes equations:</p><p class="math-container">\[\begin{align*}
-\nabla p + \mu \Delta \mathbf{u} &amp;= 0, \quad &amp;&amp; \text{in } \Omega^c, \\
\nabla \cdot \mathbf{u} &amp;= 0, \quad &amp;&amp; \text{in } \Omega^c,
\end{align*}\]</p><p>where:</p><ul><li><span>$\mathbf{u}$</span> is the velocity field,</li><li><span>$p$</span> is the pressure,</li><li><span>$\mu$</span> is the dynamic viscosity,</li><li><span>$\Omega$</span> is the sphere, and <span>$\Omega^c = \mathbb{R}^3 \setminus \overline{\Omega}$</span> is the fluid domain.</li></ul><p>The boundary conditions are:</p><ul><li><span>$\mathbf{u} = \mathbf{U}$</span> on the sphere&#39;s surface, where <span>$\mathbf{U}$</span> is the velocity of the sphere. This is a no-slip condition.</li><li><span>$\mathbf{u} \to \mathbf{0}$</span> at infinity, which means that the fluid is at rest far away from the sphere.</li></ul><p>The drag force experienced by the sphere is described by <a href="https://en.wikipedia.org/wiki/Stokes%27_law">Stokes&#39; law</a>:</p><p class="math-container">\[\mathbf{F}_d = -6\pi\mu R \mathbf{U},\]</p><p>where <span>$R$</span> is the sphere&#39;s radius. This drag force, <span>$\mathbf{F}_d$</span>, is the primary quantity of interest in this example. We will compute it using Hebeker&#39;s formulation [<a href="../../references/#hebeker1986efficient">10</a>], which expresses the velocity field <span>$\mathbf{u}$</span> as a combination of single- and double-layer potentials:</p><p class="math-container">\[\mathbf{u}(\mathbf{x}) = \mathcal{D}[\boldsymbol{\sigma}](\mathbf{x}) + \eta \mathcal{S}[\boldsymbol{\sigma}](\mathbf{x}),\]</p><p>Here, <span>$\boldsymbol{\sigma}$</span> is the unknown density, <span>$\mathcal{S}$</span> and <span>$\mathcal{D}$</span> denote the single- and double-layer potentials, respectively, and <span>$\eta &gt; 0$</span> is a coupling parameter, which we set to <span>$\eta = \mu$</span> throughout this example.</p><h2 id="Discretization"><a class="docs-heading-anchor" href="#Discretization">Discretization</a><a id="Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization" title="Permalink"></a></h2><p>To discretize the boundary <span>$\Gamma := \partial \Omega$</span>, we employ a second-order triangular mesh created using Gmsh:</p><pre><code class="language-julia hljs">using Inti, Gmsh
meshsize = 0.4
R = 2.0
gmsh.initialize()
gmsh.option.setNumber(&quot;Mesh.MeshSizeMax&quot;, meshsize)
gmsh.model.occ.addSphere(0, 0, 0, R)
gmsh.model.occ.synchronize()
gmsh.model.mesh.generate(2)
gmsh.model.mesh.setOrder(2)
msh = Inti.import_mesh()
gmsh.finalize()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Info    : Meshing 1D...
Info    : [ 40%] Meshing curve 2 (Circle)
Info    : Done meshing 1D (Wall 9.4046e-05s, CPU 9.4e-05s)
Info    : Meshing 2D...
Info    : Meshing surface 1 (Sphere, Frontal-Delaunay)
Info    : Done meshing 2D (Wall 0.0215325s, CPU 0.021529s)
Info    : 412 nodes 838 elements
Info    : Meshing order 2 (curvilinear on)...
Info    : [  0%] Meshing curve 1 order 2
Info    : [ 30%] Meshing curve 2 order 2
Info    : [ 50%] Meshing curve 3 order 2
Info    : [ 70%] Meshing surface 1 order 2
Info    : [ 90%] Meshing volume 1 order 2
Info    : Surface mesh: worst distortion = 0.976791 (0 elements in ]0, 0.2]); worst gamma = 0.354711
Info    : Done meshing order 2 (Wall 0.00261662s, CPU 0.002617s)</code></pre><div class="admonition is-success" id="Second-order-mesh-62bcf735dc8a143"><header class="admonition-header">Second-order mesh<a class="admonition-anchor" href="#Second-order-mesh-62bcf735dc8a143" title="Permalink"></a></header><div class="admonition-body"><p>Using <code>gmsh.model.mesh.setOrder(2)</code> creates a second-order mesh, which is crucial for accurately capturing the curved surface of the sphere and significantly enhances the numerical solution&#39;s precision. For simple geometries like spheres, an exact (isogeometric) representation can also be achieved using <code>Inti</code>&#39;s parametric entities. See the <a href="../../tutorials/geo_and_meshes/#Geometry-and-meshes">Geometry and meshes</a> section for more details.</p></div></div><p>Next we extract the <code>Domain</code> <span>$\Gamma$</span> from the mesh, and create a <code>Quadrature</code> on it:</p><pre><code class="language-julia hljs">Œ© = Inti.Domain(e -&gt; Inti.geometric_dimension(e) == 3, Inti.entities(msh)) # the 3D volume
Œì = Inti.boundary(Œ©) # its boundary
Œì_msh = view(msh, Œì)
Œì_quad = Inti.Quadrature(Œì_msh; qorder = 2) # quadrature on the boundary</code></pre><p>With the quadrature prepared, we can now define the Stokes operator along with its associated integral operators. We use the <a href="https://fmm3d.readthedocs.io/en/latest/">FMM3D</a> library to accelerate the evaluation of the integral operators:</p><pre><code class="language-julia hljs">using FMM3D
# pick a correction and compression method
correction = (method = :adaptive, )
compression = (method = :fmm, )

# define the Stokes operator
Œº = Œ∑ = 2.0
op = Inti.Stokes(; dim = 3, Œº)

# assemble integral operators
S, D = Inti.single_double_layer(;
    op,
    target = Œì_quad,
    source = Œì_quad,
    compression,
    correction,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(2460√ó2460 LinearMaps.LinearCombination{StaticArraysCore.SMatrix{3, 3, Float64, 9}} with 2 maps:
  2460√ó2460 LinearMaps.FunctionMap{StaticArraysCore.SMatrix{3, 3, Float64, 9},true}(#31; issymmetric=false, ishermitian=false, isposdef=false)
  2460√ó2460 LinearMaps.WrappedMap{StaticArraysCore.SMatrix{3, 3, Float64, 9}} of
    2460√ó2460 SparseArrays.SparseMatrixCSC{StaticArraysCore.SMatrix{3, 3, Float64, 9}, Int64} with 133944 stored entries, 2460√ó2460 LinearMaps.LinearCombination{StaticArraysCore.SMatrix{3, 3, Float64, 9}} with 2 maps:
  2460√ó2460 LinearMaps.FunctionMap{StaticArraysCore.SMatrix{3, 3, Float64, 9},true}(#33; issymmetric=false, ishermitian=false, isposdef=false)
  2460√ó2460 LinearMaps.WrappedMap{StaticArraysCore.SMatrix{3, 3, Float64, 9}} of
    2460√ó2460 SparseArrays.SparseMatrixCSC{StaticArraysCore.SMatrix{3, 3, Float64, 9}, Int64} with 133944 stored entries)</code></pre><h2 id="Solution-and-drag-force-computation"><a class="docs-heading-anchor" href="#Solution-and-drag-force-computation">Solution and drag force computation</a><a id="Solution-and-drag-force-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-and-drag-force-computation" title="Permalink"></a></h2><p>We are now ready to set up and solve the problem. First, we define the boundary conditions (a constant velocity on the sphere):</p><pre><code class="language-julia hljs">using StaticArrays
v = 2.0
U = SVector(v,0,0)
f = fill(U, length(Œì_quad))</code></pre><p>To solve the linear system, we will use the <code>gmres</code> function from <code>IterativeSolvers</code>. Since the function requires scalar types, we need to convert the vector-valued quantities into scalars and vice versa. We can achieve this by using <code>reinterpret</code> to convert between the vector of <code>SVector</code>s and a vector of <code>Float64</code>s types.</p><pre><code class="language-julia hljs">using IterativeSolvers, LinearAlgebra, LinearMaps
T = SVector{3, Float64} # vector type
L = I/2 + D + Œ∑ * S
L_ = LinearMap{Float64}(3 * size(L, 1)) do y, x
    œÉ = reinterpret(T, x)
    Œº = reinterpret(T, y)
    mul!(Œº, L, œÉ)
    return y
end
œÉ  = zeros(T, length(Œì_quad))
œÉ_ = reinterpret(Float64, œÉ)
f_ = reinterpret(Float64, f)
_, hist = gmres!(œÉ_, L_, f_; reltol = 1e-8, maxiter = 200, restart = 200, log = true)
hist</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Converged after 5 iterations.</code></pre><p>Note that <code>gmres</code> converges in very few iterations, highlighting the favorable spectral properties of the Hebeker formulation for this problem.</p><h3 id="Drag-force-computation"><a class="docs-heading-anchor" href="#Drag-force-computation">Drag force computation</a><a id="Drag-force-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Drag-force-computation" title="Permalink"></a></h3><p>Now that we have the density <code>œÉ</code>, we can compute the drag force. As pointed out in [<a href="../../references/#hebeker1986efficient">10</a>, Theorem 2.4], the drag force of the body <span>$\Omega$</span> is given by:</p><p class="math-container">\[    \mathbf{F}_d = \eta \int_{\Gamma} \boldsymbol{\sigma} \, d\Gamma,\]</p><p>which can be approximated using our knowledge of <code>œÉ</code> and the quadrature <code>Œì_quad</code>:</p><pre><code class="language-julia hljs">drag = Œº * sum(eachindex(Œì_quad)) do i
    return œÉ[i] * Œì_quad[i].weight
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):
 150.79618237312064
  -4.3791296762091166e-5
  -3.03894033001109e-5</code></pre><p>A quick comparison with the analytical solution indicates a good agreement.</p><pre><code class="language-julia hljs">exact = 6œÄ * Œº * R * U
relative_error = norm(drag - exact) / norm(exact)
println(&quot;Relative error: &quot;, relative_error)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Relative error: 1.7925276131823062e-6</code></pre><p>The relative error in this example is less than <code>1e-4</code>, indicating that the numerical solution is very close to the analytical solution.</p><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><p>Finally, to visualize the flow field, we need to evaluate our integral representation at points off the boundary. The easiest way to achieve this is to use <a href="../../docstrings/#Inti.IntegralPotential"><code>IntegralPotential</code></a>s, or the convenient <a href="../../docstrings/#Inti.SingleLayerPotential-Tuple{Inti.AbstractDifferentialOperator, Inti.Quadrature}"><code>SingleLayerPotential</code></a> and <a href="../../docstrings/#Inti.DoubleLayerPotential-Tuple{Inti.AbstractDifferentialOperator, Inti.Quadrature}"><code>DoubleLayerPotential</code></a> wrappers:</p><pre><code class="language-julia hljs">ùíÆ = Inti.SingleLayerPotential(op, Œì_quad)
ùíü = Inti.DoubleLayerPotential(op, Œì_quad)
u(x) = ùíü[œÉ](x) + Œ∑*ùíÆ[œÉ](x) - U # fluid velocity relative to the sphere</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">u (generic function with 1 method)</code></pre><p>In the code above, we have created a function <code>u</code> that evaluates the velocity at any point <code>x</code>:</p><pre><code class="language-julia hljs">u(SVector(1,2,3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):
 -1.0809497995092923
  0.081815503726576
  0.12272345340501137</code></pre><p>With <code>u</code> defined, we can visualize the flow field around the sphere. For this example we will simply sample points on a grid in the <code>xz</code> plane, and plot the velocity vectors at those points:</p><pre><code class="language-julia hljs">using Meshes
using GLMakie
L = 5
targets     = [SVector(x, 0, z) for x in -L:meshsize:L, z in -L:meshsize:L] |&gt; vec
filter!(x -&gt; norm(x) &gt; 1.1 * R, targets) # remove points inside or close to the sphere
directions  = u.(targets)
strength    = norm.(directions)
fig = Figure(size = (1000, 800))
ax  = Axis3(fig[1, 1]; title = &quot;Velocity field&quot;, aspect = :data, limits = ([-L, L], [-R, R], [-L, L]))
viz!(msh[Œì], showsegments=true)
arrows!(ax, Point3.(targets), Point3.(directions), arrowsize = 0.15, lengthscale = 0.4, arrowcolor = strength, linecolor = strength)
current_figure()
fig</code></pre><img src="e49ca52c.png" alt="Example block output"/><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>This tutorial demonstrates how to solve the Stokes drag problem using the Inti library. The approach combines boundary integral equations with numerical quadrature and iterative solvers to compute the drag force on a sphere in a viscous fluid.</p><div class="admonition is-success" id="Extensions-952aaa700fc00796"><header class="admonition-header">Extensions<a class="admonition-anchor" href="#Extensions-952aaa700fc00796" title="Permalink"></a></header><div class="admonition-body"><ul><li>Experiment with different geometries or boundary conditions.</li><li>Use higher-order quadrature for improved accuracy.</li><li>Explore the effect of mesh refinement on the solution.</li></ul></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../heat_equation/">¬´ Heat equation</a><a class="docs-footer-nextpage" href="../crack_elasticity/">Elastic crack ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 11 February 2026 09:18">Wednesday 11 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

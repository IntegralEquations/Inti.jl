<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Elastic crack · Inti.jl</title><meta name="title" content="Elastic crack · Inti.jl"/><meta property="og:title" content="Elastic crack · Inti.jl"/><meta property="twitter:title" content="Elastic crack · Inti.jl"/><meta name="description" content="Documentation for Inti.jl."/><meta property="og:description" content="Documentation for Inti.jl."/><meta property="twitter:description" content="Documentation for Inti.jl."/><meta property="og:url" content="https://IntegralEquations.github.io/Inti.jl/examples/crack_elasticity/"/><meta property="twitter:url" content="https://IntegralEquations.github.io/Inti.jl/examples/crack_elasticity/"/><link rel="canonical" href="https://IntegralEquations.github.io/Inti.jl/examples/crack_elasticity/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Inti.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/getting_started/">Getting started</a></li><li><a class="tocitem" href="../../tutorials/geo_and_meshes/">Geometry and meshes</a></li><li><a class="tocitem" href="../../tutorials/integral_operators/">Integral operators</a></li><li><a class="tocitem" href="../../tutorials/layer_potentials/">Layer potentials</a></li><li><a class="tocitem" href="../../tutorials/compression_methods/">Compression methods</a></li><li><a class="tocitem" href="../../tutorials/correction_methods/">Correction methods</a></li><li><a class="tocitem" href="../../tutorials/solvers/">Linear solvers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../pluto-examples/toy_example/">Toy example</a></li><li><a class="tocitem" href="../../pluto-examples/helmholtz_scattering/">Helmholtz scattering</a></li><li><a class="tocitem" href="../../pluto-examples/poisson/">Poisson problem</a></li><li><a class="tocitem" href="../heat_equation/">Heat equation</a></li><li><a class="tocitem" href="../stokes_drag/">Stokes drag</a></li><li class="is-active"><a class="tocitem" href>Elastic crack</a><ul class="internal"><li><a class="tocitem" href="#Problem-definition"><span>Problem definition</span></a></li><li><a class="tocitem" href="#Geometry-and-mesh"><span>Geometry and mesh</span></a></li><li><a class="tocitem" href="#Integral-operators"><span>Integral operators</span></a></li><li><a class="tocitem" href="#Boundary-conditions"><span>Boundary conditions</span></a></li><li><a class="tocitem" href="#Solution"><span>Solution</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li><a class="tocitem" href="#Improving-the-accuracy"><span>Improving the accuracy</span></a></li></ul></li><li><a class="tocitem" href="../pep/">Plasmonic eigenvalues</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../docstrings/">Docstrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Elastic crack</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Elastic crack</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl/blob/main/docs/src/examples/crack_elasticity.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Elastic-crack-in-2D"><a class="docs-heading-anchor" href="#Elastic-crack-in-2D">Elastic crack in 2D</a><a id="Elastic-crack-in-2D-1"></a><a class="docs-heading-anchor-permalink" href="#Elastic-crack-in-2D" title="Permalink"></a></h1><div class="admonition is-info" id="Important-points-covered-in-this-example-5f1efec874d68892"><header class="admonition-header">Important points covered in this example<a class="admonition-anchor" href="#Important-points-covered-in-this-example-5f1efec874d68892" title="Permalink"></a></header><div class="admonition-body"><ul><li>Solving a problem with an open surface (crack)</li><li>Using the hypersingular operator</li><li>Defining a custom kernel with a weight function</li><li>Dealing with vector-valued problems</li></ul></div></div><h2 id="Problem-definition"><a class="docs-heading-anchor" href="#Problem-definition">Problem definition</a><a id="Problem-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-definition" title="Permalink"></a></h2><p>In this example, we solve a disk crack problem in the context of linear elasticity using boundary integral equations. The problem involves determining the displacement jump field <span>$\boldsymbol{\phi}$</span> in an infinite elastic domain containing a disk-shaped crack. It is possible to show that the problem can be reduced to a boundary integral equation of the form (e.g. [<a href="../../references/#bonnet1995">11</a>, Chapter 13]):</p><p class="math-container">\[T[\boldsymbol{\phi}] = -\boldsymbol{f},\]</p><p>where <span>$T$</span> represents the integral operator associated with the hypersingular kernel, defined on the crack surface <span>$\Gamma$</span>; <span>$\boldsymbol{f}$</span> is the applied traction on the boundary, which is symmetric on the two crack lips; and <span>$\boldsymbol{\phi}$</span> is the so-called crack opening displacement (COD), defined as the &quot;displacement&quot; jump that occurs through the crack : <span>$\boldsymbol{\phi}=\boldsymbol u^+-\boldsymbol u^-$</span>.</p><details class="admonition is-details" id="Details-80a73dd44a03dd69"><summary class="admonition-header">Details<a class="admonition-anchor" href="#Details-80a73dd44a03dd69" title="Permalink"></a></summary><div class="admonition-body"><p>Being considered an open surface, the crack <span>$\Gamma$</span> is arbitrarily extended onto a closed surface <span>$\tilde\Gamma$</span>. Then, we consider <span>$\boldsymbol{u}^+$</span> and <span>$\boldsymbol{u}^-$</span> as the interior and exterior displacements, depending on the convention used. The crack opening displacement is then defined as the difference between the two displacements at the two crack lips, mathematically superposed. It has to be understood as a mathematical limit of the displacement field as a point approaches one lip or the other. This method is called the Displacement Discontinuity Method.</p></div></details><p>This example demonstrates the formulation, solution, and visualization of the problem, highlighting the use of integral operators.</p><h2 id="Geometry-and-mesh"><a class="docs-heading-anchor" href="#Geometry-and-mesh">Geometry and mesh</a><a id="Geometry-and-mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry-and-mesh" title="Permalink"></a></h2><p>The domain is a disk of radius 1 on the plane <span>$z=0$</span>. We use the GMSH library to create the mesh, and <code>Inti</code>&#39;s <a href="../../docstrings/#Inti.import_mesh-Tuple"><code>import_mesh</code></a> function to import it.</p><pre><code class="language-julia hljs">using Inti
using StaticArrays
using Gmsh

meshsize = 0.2
qorder  = 2 # avoid 3 since it contains a negative weight
rx = ry = 1
gmsh.initialize(String[], false)
gmsh.option.setNumber(&quot;Mesh.MeshSizeMin&quot;, meshsize)
gmsh.option.setNumber(&quot;Mesh.MeshSizeMax&quot;, meshsize)
gmsh.model.occ.addDisk(0.0, 0.0, 0.0, rx, ry)
gmsh.model.occ.synchronize()
gmsh.model.mesh.generate(2)
gmsh.model.mesh.setOrder(1)
msh = Inti.import_mesh(; dim = 3)
Γ = Inti.Domain(e -&gt; Inti.geometric_dimension(e) == 2, msh)
Γ_msh = msh[Γ]
Q = Inti.Quadrature(Γ_msh; qorder = 2)
gmsh.finalize()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Info    : Meshing 1D...
Info    : Meshing curve 1 (Ellipse)
Info    : Done meshing 1D (Wall 0.000150075s, CPU 0.000149s)
Info    : Meshing 2D...
Info    : Meshing surface 1 (Plane, Frontal-Delaunay)
Info    : Done meshing 2D (Wall 0.00812442s, CPU 0.008124s)
Info    : 123 nodes 245 elements</code></pre><p>Note that we have used second-order elements for the mesh, which is useful for better representing the edges of the circular crack.</p><h2 id="Integral-operators"><a class="docs-heading-anchor" href="#Integral-operators">Integral operators</a><a id="Integral-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Integral-operators" title="Permalink"></a></h2><p>We will now build an approximation to <span>$T$</span> using:</p><ul><li>A hierarchical matrix representation for the integral operator</li><li>An adaptive correction to account for the singular and nearly singular interactions</li></ul><pre><code class="language-julia hljs">using HMatrices
using LinearMaps
using LinearAlgebra
#Elastic properties
μ = 1; ν = 0.15;
E = 2*μ*(1+ν)
λ = ν*E / ((1+ν)*(1-2*ν))
op = Inti.Elastostatic(; λ, μ, dim = 3)
K = Inti.HyperSingularKernel(op)
Top = Inti.IntegralOperator(K, Q)
T₀ = Inti.assemble_hmatrix(Top)
δT = Inti.adaptive_correction(Top)</code></pre><h2 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h2><p>For the boundary conditions, we consider a constant normal loading on the crack surface, simply given by:</p><pre><code class="language-julia hljs">f = 1.0
t = -[SVector(0,0,f) for _ in Q]</code></pre><p>Note that we used an <code>SVector</code> to represent the traction at a point on the crack surface. For vector-valued problems, <code>SVector</code>s and <code>SMatrix</code>s are often used to represent vectors and tensors, respectively, since their size is known at compile time (and small). This avoids the overhead of dynamic arrays.</p><p>We are now ready to compute the approximate solution.</p><h2 id="Solution"><a class="docs-heading-anchor" href="#Solution">Solution</a><a id="Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Solution" title="Permalink"></a></h2><p>The exact solution for this problem can be obtained by separation of variables in cylindrical coordinates, and can be shown to be:</p><pre><code class="language-julia hljs">σ = 1
φ₃(r) = 4*(1-ν)*σ / (π*μ) * sqrt(1-r^2)
uexact(x) = SVector(0, 0, φ₃(norm(x)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">uexact (generic function with 1 method)</code></pre><p>To compute the approximate solution, we will need to solve the linear system:</p><p class="math-container">\[T[\boldsymbol{\phi}] = \boldsymbol{f},\]</p><p>where <span>$\boldsymbol{\phi}$</span> is the unknown vector of displacements. One difficulty that arises is related to the fact that in our implementation, both <code>\phi</code> and <code>f</code> are represented as <code>Vector</code>s of <code>SVector</code>s. While convenient for some operations, this can lead to difficulties when trying to solve the linear system since most linear algebra libraries expect matrices over a scalar field (usually either <span>$\mathbb{R}$</span> or <span>$\mathbb{C}$</span>). To address this, we will write a short function <code>solve</code> that will convert between the <em>vector of vectors</em> and the vector of <em>scalars</em>.</p><pre><code class="language-julia hljs">using IterativeSolvers
function solve!(u, T₀, δT, t)
    @assert eltype(T₀) == eltype(δT) == SMatrix{3,3,Float64,9}
    @assert eltype(t) == eltype(u) == SVector{3,Float64}
    # write a LinearMap over scalars by reinterpreting them as vectors of SVectors,
    # applying our operators T₀ and δT, and converting back before returning
    L_ = LinearMap{Float64}(3 * size(T₀, 1)) do y, x
        σ = reinterpret(SVector{3,Float64}, x)
        μ = reinterpret(SVector{3,Float64}, y)
        mul!(μ, T₀, σ)
        mul!(μ, δT, σ, 1, 1)
        return y
    end
    # flatten our input vectors and call gmres on the Float64 version
    u_ = reinterpret(Float64, u)
    t_ = reinterpret(Float64, t)
    u_, gmres_hist = gmres!(u_, L_, t_, restart = 1000, maxiter = 1000, log=true)
    @show gmres_hist
    # since u_ is just a reinterpretation of u, we can simply return u when done
    return u
end
solve(T₀, δT, t) = solve!(zero(t), T₀, δT, t)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">solve (generic function with 1 method)</code></pre><p>We can now easily call <code>solve</code> to obtain our approximate solution:</p><pre><code class="language-julia hljs">φ = solve(T₀, δT, t)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">gmres_hist = Converged after 28 iterations.</code></pre><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><p>Next we show a crude visualization by plotting the displacement value at each point of the quadrature (as a function of the radius), and comparing it to the exact solution. The displacement is a vector, but we will only plot the <span>$z$</span> component, which is the only one that is non-zero in this case.</p><pre><code class="language-julia hljs">using LinearAlgebra
using GLMakie
r    = map(q -&gt; norm(Inti.coords(q)), Q)
vals = getindex.(φ, 3)
scatter(r, vals, label = &quot;Numerical solution&quot;)
lines!(0:0.01:1, φ₃, label = &quot;Exact solution&quot;, color = :red, linewidth = 4)
axislegend()
current_figure()</code></pre><img src="d2a97f3f.png" alt="Example block output"/><p>Although the solution is not perfect, it captures the general behavior of the displacement field. One way to make the error smaller is to use a finer mesh and/or higher order quadrature. An alternative way, however, is to use a weight function to incorporate the singular behavior of the displacement field near the edge of the crack, as shown next.</p><h2 id="Improving-the-accuracy"><a class="docs-heading-anchor" href="#Improving-the-accuracy">Improving the accuracy</a><a id="Improving-the-accuracy-1"></a><a class="docs-heading-anchor-permalink" href="#Improving-the-accuracy" title="Permalink"></a></h2><p>It is beneficial to add a weight function to help the solution being more accurate near the crack, where the displacement is singular, asymptotically equal to <span>$d^{1/2}$</span> (<span>$d$</span> is the distance from a point to the crack front) according to the Williams&#39; asymptotic expansion. For this simple example we take the weight function as:</p><p class="math-container">\[w(\boldsymbol x):=\sqrt{1-||\boldsymbol x||}\underset{d\rightarrow
0}{\sim}\sqrt{d(\boldsymbol x)}\]</p><pre><code class="language-julia hljs">weight(x) = sqrt(1 - norm(x))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">weight (generic function with 1 method)</code></pre><p>and define a modified kernel <span>$K_w$</span> as:</p><pre><code class="language-julia hljs">Kw = let w = weight, K = K
    (p,q) -&gt;  K(p,q) * w(q.coords)
end
Inti.singularity_order(::typeof(Kw)) = -3</code></pre><p>With this new kernel, we can build our new integral operator <span>$T_w$</span> and solve the displacement jump equation for a modified density <span>$\boldsymbol{\phi}_w = \boldsymbol{\phi} / w$</span>:</p><pre><code class="language-julia hljs">Tw_op = Inti.IntegralOperator(Kw, Q)
Tw₀ = Inti.assemble_hmatrix(Tw_op)
δTw = Inti.adaptive_correction(Tw_op; maxdist = 2*meshsize, atol = 1e-2)
φw = solve(Tw₀, δTw, t)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">636-element Vector{StaticArraysCore.SVector{3, Float64}}:
 [0.0, 0.0, 1.3912659478409293]
 [0.0, 0.0, 1.4230567294518057]
 [0.0, 0.0, 1.3809584076114676]
 [0.0, 0.0, 1.4116170801962638]
 [0.0, 0.0, 1.3698133032462294]
 [0.0, 0.0, 1.3704999520737509]
 [0.0, 0.0, 1.4392142218993644]
 [0.0, 0.0, 1.409148720188811]
 [0.0, 0.0, 1.4483720684161865]
 [0.0, 0.0, 1.4431300600062533]
 ⋮
 [0.0, 0.0, 1.4548197639169271]
 [0.0, 0.0, 1.4552150922420264]
 [0.0, 0.0, 1.430067090172073]
 [0.0, 0.0, 1.4577597060750604]
 [0.0, 0.0, 1.4539393647159513]
 [0.0, 0.0, 1.4320257957785982]
 [0.0, 0.0, 1.4507071175959196]
 [0.0, 0.0, 1.4572171195709727]
 [0.0, 0.0, 1.4324810549864933]</code></pre><p>We now plot the displacement field again, but this with the weighted kernel approach, and compare it to the previous approach. Note that we must multiply the solution <code>φw</code> by the weight function to obtain the actual displacement jump <code>φ</code>.</p><pre><code class="language-julia hljs">weights = [weight(q.coords) for q in Q]
scatter(r, getindex.(φw,3) .* weights, label = &quot;Numerical solution (weighted)&quot;)
lines!(0:0.01:1, φ₃, label = &quot;Exact solution&quot;, color = :red, linewidth = 4)
axislegend()
current_figure()</code></pre><img src="75c16bc1.png" alt="Example block output"/><p>The solution is now much more accurate, especially near the crack front, even though the same mesh and quadrature were used. This is a common technique in boundary integral equation: factoring out the asymptotic (non-smooth) behavior of the solution using a weight function.</p><p>Finally, we can visualize the displacement field on the mesh by interpolating the computed values on the quadrature points to the mesh nodes. We use <code>Meshes</code> to visualize the solution:</p><pre><code class="language-julia hljs">using Meshes
φ3w_nodes = Inti.quadrature_to_node_vals(Q, getindex.(φw, 3))
msh_nodes = Inti.nodes(Q.mesh)
w_nodes = [weight(x) for x in msh_nodes]
φ3_nodes = φ3w_nodes .* w_nodes
colorrange = extrema(φ3_nodes)
fig = Figure(; size = (800, 600))
ax = Axis3(fig[1, 1])
n = length(Q.mesh.nodes)
viz!(Q.mesh; color = φ3_nodes, interpolate = false, showsegments=true)
cb = Colorbar(fig[1, 2]; label = &quot;φ₃&quot;, colorrange)
fig</code></pre><img src="ffc5f92a.png" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../stokes_drag/">« Stokes drag</a><a class="docs-footer-nextpage" href="../pep/">Plasmonic eigenvalues »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 11 October 2025 16:52">Saturday 11 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

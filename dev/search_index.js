var documenterSearchIndex = {"docs":
[{"location":"tutorials/solvers/#Linear-solvers","page":"Linear solvers","title":"Linear solvers","text":"warning: Work in progress\nThis tutorial is still a work in progress. We will update it with more details and examples in the future.\n\nInti.jl does not provide its own linear solvers, but relies on external libraries such as IterativeSolvers.jl or the LinearAlgebra standard library for the solving the linear systems that arise in the discretization of integral equations.","category":"section"},{"location":"references/#References","page":"References","title":"References","text":"C.¬†Bernardi. Optimal finite-element interpolation on curved domains. SIAM¬†Journal¬†on¬†Numerical¬†Analysis 26, 1212‚Äì1240 (1989).\n\n\n\nJ.-C.¬†N√©d√©lec. Acoustic and electromagnetic equations: integral representations for harmonic problems. Vol.¬†144 (Springer, 2001).\n\n\n\nD.¬†Colton and R.¬†Kress. Integral equation methods in scattering theory (SIAM, 2013).\n\n\n\nM.¬†Bebendorf. Hierarchical matrices (Springer, 2008).\n\n\n\nW.¬†Hackbusch and others. Hierarchical matrices: algorithms and analysis. Vol.¬†49 (Springer, 2015).\n\n\n\nV.¬†Rokhlin. Rapid solution of integral equations of classical potential theory. Journal¬†of¬†computational¬†physics 60, 187‚Äì207 (1985).\n\n\n\nL.¬†Greengard and V.¬†Rokhlin. A fast algorithm for particle simulations. Journal¬†of¬†computational¬†physics 73, 325‚Äì348 (1987).\n\n\n\nM.¬†Guiggiani, G.¬†Krishnasamy, T.¬†J.¬†Rudolphi and F.¬†J.¬†Rizzo. A general algorithm for the numerical solution of hypersingular boundary              integral equations. Journal¬†of¬†Applied¬†Mechanics 59, 604‚Äì614 (1992).\n\n\n\nL.¬†M.¬†Faria, C.¬†P√©rez-Arancibia and M.¬†Bonnet. General-purpose kernel regularization of boundary integral equations via density interpolation. Computer¬†Methods¬†in¬†Applied¬†Mechanics¬†and¬†Engineering 378, 113703 (2021).\n\n\n\nF.-K.¬†Hebeker. Efficient boundary element methods for three-dimensional exterior viscous flows. Numerical¬†Methods¬†for¬†Partial¬†Differential¬†Equations 2, 273‚Äì297 (1986).\n\n\n\nM.¬†Bonnet. Boundary Integral Equations Methods for Solids and Fluids (Wiley, 1995).\n\n\n\nD.¬†Grieser. The plasmonic eigenvalue problem. Reviews¬†in¬†Mathematical¬†Physics 26, 1450005 (2014).\n\n\n\nS.¬†A.¬†Maier and others. Plasmonics: fundamentals and applications. Vol.¬†1 (Springer, 2007).\n\n\n\nL.¬†M.¬†Faria and F.¬†Monteghetti. A complex-scaled boundary integral equation for the embedded eigenvalues and complex resonances of the Neumann-Poincar√© operator on domains with corners, working paper or preprint.\n\n\n\nT.¬†G.¬†Anderson, M.¬†Bonnet, L.¬†M.¬†Faria and C.¬†P√©rez-Arancibia. Fast, high-order numerical evaluation of volume potentials via polynomial density interpolation. Journal¬†of¬†Computational¬†Physics, 113091 (2024).\n\n\n\n","category":"section"},{"location":"tutorials/layer_potentials/#Layer-potentials","page":"Layer potentials","title":"Layer potentials","text":"note: Important points covered in this tutorial\nNearly singular evaluation of layer potentials\nCreating a smooth domain with splines using Gmsh's API\nPlotting values on a mesh\n\nIn this tutorial we focus on evaluating the layer potentials given a source density. This is a common post-processing task in boundary integral equation methods, and while most of it is straightforward, some subtleties arise when the target points are close to the boundary (nearly-singular integrals).","category":"section"},{"location":"tutorials/layer_potentials/#Integral-potentials","page":"Layer potentials","title":"Integral potentials","text":"IntegralPotential represent the following mathematical objects:\n\nmathcalPsigma(boldsymbolr) = int_Gamma K(boldsymbolr boldsymbolr) sigma(boldsymbolr)  dboldsymbolr\n\nwhere K is the kernel of the operator, Gamma is the source's boundary, boldsymbolr not in Gamma is a target point, and sigma is the source density.\n\nHere is a simple example of how to create a kernel representing a Laplace double-layer potential:\n\nusing Inti, StaticArrays, LinearAlgebra\n# define a kernel function\nfunction K(target,source)\n    r = Inti.coords(target) - Inti.coords(source)\n    ny = Inti.normal(source)\n    return 1 / (2œÄ * norm(r)^2) * dot(r, ny)\nend\n# define a domain\nŒì = Inti.parametric_curve(s -> SVector(cos(2œÄ * s), sin(2œÄ * s)), 0, 1) |> Inti.Domain\n# and a quadrature of Œì\nQ = Inti.Quadrature(Œì; meshsize = 0.1, qorder = 5)\nùíÆ = Inti.IntegralPotential(K, Q)\n\nIf we have a source density sigma, defined on the quadrature nodes of Gamma, we can create a function that evaluates the layer potential at an arbitrary point:\n\nœÉ = map(q -> 1.0, Q)\nu = ùíÆ[œÉ]\n\nu is now an anonymous function that evaluates the layer potential at any point:\n\nr = SVector(0.1, 0.2)\n@assert u(r) ‚âà -1 # hide\nu(r)\n\nAlthough we created the single-layer potential for the Laplace kernel manually, it is often more convenient to use the single_layer_potential when working with a supported PDE, e.g.:\n\nop = Inti.Laplace(; dim = 2)\nùíÆ, ùíü = Inti.single_double_layer_potential(; op, source = Q)\n\ncreates the single and double layer potentials for the Laplace equation in 2D.","category":"section"},{"location":"tutorials/layer_potentials/#Direct-evaluation-of-layer-potentials","page":"Layer potentials","title":"Direct evaluation of layer potentials","text":"We now show how to evaluate the layer potentials of an exact solution on a mesh created through the Gmsh API. Do to so, let us first define the PDE:g\n\nusing Inti, StaticArrays, LinearAlgebra, Meshes, GLMakie, Gmsh\n# define the PDE\nk = 4œÄ\nop = Inti.Helmholtz(; dim = 2, k)\n\nWe will now use the gmsh_curve function to create a smooth domain of a kite using splines:\n\ngmsh.initialize()\nmeshsize = 2œÄ / k / 4\nkite = Inti.gmsh_curve(0, 1; meshsize) do s\n    SVector(0.25, 0.0) + SVector(cos(2œÄ * s) + 0.65 * cos(4œÄ * s[1]) - 0.65, 1.5 * sin(2œÄ * s))\nend\ncl = gmsh.model.occ.addCurveLoop([kite])\nsurf = gmsh.model.occ.addPlaneSurface([cl])\ngmsh.model.occ.synchronize()\ngmsh.model.mesh.generate(2)\nmsh = Inti.import_mesh(; dim = 2)\ngmsh.finalize()\n\ntip: Tip\nThe GMSH API is a powerful tool to create complex geometries and meshes directly from Julia (the gmsh_curve function above is just a simple wrapper around some spline functionality). For more information, see the official documentation.\n\nWe can visualize the triangular mesh using:\n\nusing Meshes, GLMakie\n# extract the domain Œ© from the mesh entities\nents = Inti.entities(msh)\nŒ© = Inti.Domain(e->Inti.geometric_dimension(e) == 2, ents)\nviz(msh[Œ©]; showsegments = true, axis = (aspect = DataAspect(), ))\n\nFor the purpose of testing the accuracy of the layer potential evaluation, we will construct an exact solution of the Helmholtz equation on the interior domain and plot it:\n\n# construct an exact interior solution as a sum of random plane waves\ndirs  = [SVector(cos(Œ∏), sin(Œ∏)) for Œ∏ in 2œÄ*rand(10)]\ncoefs = rand(ComplexF64, 10)\nu  =  (x)   -> sum(c*exp(im*k*dot(x, d)) for (c,d) in zip(coefs, dirs))\ndu =  (x,ŒΩ) -> sum(c*im*k*dot(d, ŒΩ)*exp(im*k*dot(x, d)) for (c,d) in zip(coefs, dirs))\n# plot the exact solution\nŒ©_msh = view(msh, Œ©)\ntarget = Inti.nodes(Œ©_msh)\nviz(Œ©_msh; showsegments = false, axis = (aspect = DataAspect(), ), color = real(u.(target)))\n\nSince u satisfies the Helmholtz equation, we know that the following representation holds:\n\nu(boldsymbolr) = mathcalSgamma_1 u(boldsymbolr) - mathcalDgamma_0 u(boldsymbolr) quad boldsymbolr in Omega\n\nwhere gamma_0 u and gamma_1 u are the respective Dirichlet and Neumann traces of u, and mathcalS and mathcalD are the respective single and double layer potentials over Gamma = partial Omega.\n\nLet's compare next the exact solution with the layer potential evaluation, based on a quadrature of Gamma:\n\nŒì = Inti.boundary(Œ©)\nQ = Inti.Quadrature(view(msh,Œì); qorder = 5)\n# evaluate the layer potentials\nùíÆ, ùíü = Inti.single_double_layer_potential(; op, source = Q)\nŒ≥‚ÇÄu = map(q -> u(q.coords), Q)\nŒ≥‚ÇÅu = map(q -> du(q.coords, q.normal), Q)\nu‚Çï = x -> ùíÆ[Œ≥‚ÇÅu](x) - ùíü[Œ≥‚ÇÄu](x)\n# plot the error on the target nodes\ner_log10 = log10.(abs.(u.(target) - u‚Çï.(target)))\ncolorrange = extrema(er_log10)\nfig, ax, pl = viz(Œ©_msh;\n    color = er_log10,\n    colormap = :viridis,\n    colorrange,\n    axis = (aspect = DataAspect(),),\n    interpolate=true\n)\nColorbar(fig[1, 2]; label = \"log‚ÇÅ‚ÇÄ(error)\", colorrange)\nfig\n\nWe see a common pattern of potential evaluation: the error is small away from the boundary, but grows near it. This is due to the nearly-singular nature of the layer potential integrals, which can be mitigated by using a correction method that accounts for the singularity of the kernel as boldsymbolr to Gamma.","category":"section"},{"location":"tutorials/layer_potentials/#Near-field-correction-of-layer-potentials","page":"Layer potentials","title":"Near-field correction of layer potentials","text":"There are two cases where the direct evaluation of layer potentials is not recommended:\n\nWhen the target point is close to the boundary (nearly-singular integrals).\nWhen evaluation at many target points is desired (computationally burdensome)and take advantage of an acceleration routine.\n\nIn such contexts, it is recommended to use the single_double_layer function (alternately, one can directly assemble an IntegralOperator) with a correction, for the first case, and/or a compression (acceleration) method, for the latter case, as appropriate. Here is an example of how to use the FMM acceleration with a near-field correction to evaluate the layer potentials::\n\nusing FMM2D\nS, D = Inti.single_double_layer(; op, target, source = Q,\n    compression = (method = :fmm, tol = 1e-12),\n    correction = (method = :dim, target_location = :inside, maxdist = 0.2)\n)\ner_log10_cor = log10.(abs.(S*Œ≥‚ÇÅu - D*Œ≥‚ÇÄu - u.(target)))\ncolorrange = extrema(er_log10) # use scale without correction\nfig = Figure(resolution = (800, 400))\nax1 = Axis(fig[1, 1], aspect = DataAspect(), title = \"Naive evaluation\")\nviz!(Œ©_msh; color = er_log10, colormap = :viridis, colorrange,interpolate=true)\nax2 = Axis(fig[1, 2], aspect = DataAspect(), title = \"Nearfield correction\")\nviz!(Œ©_msh; color = er_log10_cor, colormap = :viridis, colorrange, interpolate=true)\nColorbar(fig[1, 3]; label = \"log‚ÇÅ‚ÇÄ(error)\", colorrange)\nfig\n\nAs can be seen, the near-field correction significantly reduces the error near the boundary, making if feasible to evaluate the layer potential near Gamma if necessary.","category":"section"},{"location":"tutorials/integral_operators/#Integral-operators","page":"Integral operators","title":"Integral operators","text":"note: Important points covered in this tutorial\nDefine layer potentials and the four integral operators of Calder√≥n calculus\nConstruct block operators\nSet up a custom kernel\n\nA central piece of integral equation methods is the efficient and accurate computation of integral operators. In the first part of this tutorial we will cover how to assemble and manipulate the four integral operators of Calder√≥n calculus, namely the single-layer, double-layer, hypersingular, and adjoint operators [2, 3], for some predefined kernels in Inti.jl. In the second part we will show how to extend the package to handle custom kernels.","category":"section"},{"location":"tutorials/integral_operators/#Predefined-kernels-and-integral-operators","page":"Integral operators","title":"Predefined kernels and integral operators","text":"To simplify the construction of integral operators for some commonly used PDEs, Inti.jl defines a few AbstractDifferentialOperators types. For each of these PDEs, the package provides a SingleLayerKernel, DoubleLayerKernel, HyperSingularKernel, and AdjointDoubleLayerKernel that can be used to construct the corresponding kernel functions, e.g.:\n\nusing Inti, StaticArrays, LinearAlgebra\nop = Inti.Helmholtz(; dim = 2, k = 2œÄ)\nG   = Inti.SingleLayerKernel(op)\n\nTypically, we are not interested in the kernels themselves, but in the integral operators they define. Two functions, single_double_layer and adj_double_layer_hypersingular, are provided as a high-level syntax to construct the four integral operators of Calder√≥n calculus:\n\nŒì = Inti.parametric_curve(s -> SVector(cos(s), sin(s)), 0, 2œÄ) |> Inti.Domain\nQ = Inti.Quadrature(Œì; meshsize = 0.1, qorder = 7)\nS, D = Inti.single_double_layer(; \n    op, \n    target = Q, \n    source = Q, \n    compression = (method = :none,), \n    correction = (method = :dim,)\n)\nK, N = Inti.adj_double_layer_hypersingular(; \n    op, \n    target = Q, \n    source = Q, \n    compression = (method = :none,), \n    correction = (method = :dim,)\n)\nnothing # hide\n\nMuch goes on under the hood in the function above, and the sections on correction and compression methods will provide more details on the options available. The important thing to keep in mind is that S, D, K, and N are discrete approximations of the following (linear) operators:\n\nbeginaligned\n    Ssigma(boldsymbolx) = int_Gamma G(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly quad \n    Dsigma(boldsymbolx) = mathrmpv int_Gamma fracpartial Gpartial nu_boldsymboly(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly \n    Ksigma(boldsymbolx) =  mathrmpv int_Gamma fracpartial Gpartial nu_boldsymbolx(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly quad\n    Nsigma(boldsymbolx) = mathrmfp int_Gamma fracpartial^2 Gpartial nu_boldsymbolx partial nu_boldsymboly(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly\nendaligned\n\nThe actual type of S, D, K, and N depends on the compression and correction methods. In the simple case above, these are simply matrices:\n\n@assert all(T -> T == Matrix{ComplexF64}, map(typeof, (S, D, K, N))) # hide\nmap(typeof, (S, D, K, N))\n\nIf we turn on a compression method, such as :fmm, the types may change into something different:\n\nusing FMM2D # will load the extension\nSfmm, Dfmm = Inti.single_double_layer(; \n    op, \n    target = Q, \n    source = Q, \n    compression = (method = :fmm, tol = 1e-10), \n    correction = (method = :dim,)\n)\nKfmm, Nfmm = Inti.adj_double_layer_hypersingular(; \n    op, \n    target = Q, \n    source = Q, \n    compression = (method = :fmm, tol = 1e-10), \n    correction = (method = :dim, )\n)\ntypeof(Sfmm)\n\nThis is because the FMM method is used to approximate the matrix-vector in a matrix-free way: the only thing guaranteed is that S and D can be applied to a vector:\n\nx = map(q -> cos(q.coords[1] + q.coords[2]), Q)\n@assert norm(Sfmm*x - S*x, Inf) / norm(S*x, Inf) < 1e-8 # hide\nnorm(Sfmm*x - S*x, Inf)\n\nThe Sfmm object above in fact combines two linear maps:\n\nSfmm\n\nThe FunctionMap computes a matrix-vector by performing a function call to the FMM2D library. The WrappedMap accounts for a sparse matrix used to correct for singular and nearly singular interactions. These two objects are added lazily using LinearMaps.","category":"section"},{"location":"tutorials/integral_operators/#Operator-composition","page":"Integral operators","title":"Operator composition","text":"Effortlessly and efficiently composing operators is a powerful abstraction for integral equations, as it allows for the construction of complex systems from simple building blocks. To show this, let us show how to construct the Calder√≥n projectors:\n\nbeginaligned\nH = beginbmatrix\n    -D  S \n    -N  K\nendbmatrix \nendaligned\n\nAs is well-known [2, Theorem 3.1.3], the operators C_pm = I2 pm H are the projectors (i.e. C_pm^2 = C_pm):\n\nusing LinearMaps\n# create the block operator\nH = [-Dfmm Sfmm; -Nfmm Kfmm]\nC‚Çä = I / 2 + H\nC‚Çã = I / 2 - H\n# define two density functions on Œì\nu = map(q -> cos(q.coords[1] + q.coords[2]), Q)\nv = map(q-> q.coords[1], Q)\nx = [u; v]\n# compute the error in the projector identity\ne‚Çä = norm(C‚Çä*(C‚Çä*x) - C‚Çä*x, Inf)\ne‚Çã = norm(C‚Çã*(C‚Çã*x) - C‚Çã*x, Inf)\n@assert e‚Çä < 1e-4 && e‚Çã < 1e-4 # hide\nprintln(\"projection error for C‚Çä: $e‚Çä\")\nprintln(\"projection error for C‚Çã: $e‚Çã\")\n\nWe see that the error in the projector identity is small, as expected. Note that such compositions are not limited to the Calder√≥n projectors, and can be used e.g. to construct the combined field integral equation (CFIE), or to compose a formulation with an operator preconditioner.","category":"section"},{"location":"tutorials/integral_operators/#Custom-kernels","page":"Integral operators","title":"Custom kernels","text":"So far we have focused on problems for which Inti.jl provides predefined kernels, and used the high-level syntax of e.g. single_double_layer to construct the integral operators. We will now dig into the details of how to set up a custom kernel function, and how to build an integral operator from it.\n\nnote: Integral operators coming from PDEs\nIf the integral operator of interest arises from a PDE, it is recommended to define a new AbstractDifferentialOperator type, and implement the required methods for SingleLayerKernel, DoubleLayerKernel, AdjointDoubleLayerKernel, and HyperSingularKernel. This will enable the use of the high-level syntax for constructing boundary integral operators, as well as the use of the compression and correction methods specific to integral operators arising from PDEs.\n\nFor the sake of simplicity, let us consider the following kernel representing the half-space Dirichlet Green function for Helmholtz's equation in 2D:\n\n    G_D(boldsymbolx boldsymboly) = fraci4 H^(1)_0(k boldsymbolx - boldsymboly) - fraci4 H^(1)_0(k boldsymbolx - boldsymboly^*)\n\nwhere boldsymboly^* = (y_1 -y_2). We can define this kernel as a\n\nusing SpecialFunctions # for hankelh1\nfunction helmholtz_kernel(target, source, k)\n    x, y  = Inti.coords(target), Inti.coords(source)\n    yc = SVector(y[1], -y[2])\n    d, dc  = norm(x-y), norm(x-yc)\n    # the singularity at x = y needs to be handled separately, so just put a zero to avoid division by zero\n    d == 0 ? zero(ComplexF64) : im / 4 * ( hankelh1(0, k * d) - hankelh1(0, k * dc))\nend\n\nLet us now consider the integral operator S defined by:\n\n    Ssigma(boldsymbolx) = int_Gamma G_D(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly quad boldsymbolx in Gamma\n\nWe can represent S by an IntegralOperator type:\n\nk = 50œÄ\nŒª = 2œÄ/k\nmeshsize = Œª / 10\ngeo = Inti.parametric_curve(s -> SVector(cos(s), 2 + sin(s)), 0, 2œÄ)\nŒì = Inti.Domain(geo)\nmsh = Inti.meshgen(Œì; meshsize)\nQ = Inti.Quadrature(msh; qorder = 5)\n# create a local scope to capture `k`\nK = let k = k\n    (t,q) -> helmholtz_kernel(t,q,k)\nend\nSop = Inti.IntegralOperator(K, Q, Q)\n\nnote: Signature of custom kernels\nKernel functions passed to IntegralOperator should always take two arguments, target and source, which are both of QuadratureNode. This allows for extracting not only the coords of the nodes, but also the normal vector if needed (e.g. for double-layer or hypersingular kernels).\n\nThe approximation of Sop now involves two steps:\n\nbuild a dense operator S‚ÇÄ that efficiently computes the matrix-vector product Sop * x for any vector x\ncorrect for the inaccuracies of S‚ÇÄ due to singular/nearly-singular interactions by adding to it a correction matrix Œ¥S\n\nFor the first step, we will use a hierarchical matrix:\n\nusing HMatrices\nS‚ÇÄ = Inti.assemble_hmatrix(Sop; rtol = 1e-4)\n\nThe correction matrix Œ¥S will be constructed using adaptive_correction:\n\nŒ¥S = Inti.adaptive_correction(Sop; rtol = 1e-4, maxdist = 3*meshsize)\n\nHow exactly one adds S‚ÇÄ and Œ¥S to get the final operator depends on the intended usage. For instance, one can use the LinearMap type to simply add them lazily:\n\nusing LinearMaps\nS = LinearMap(S‚ÇÄ) + LinearMap(Œ¥S)\n\nOr, one can add Œ¥S to S‚ÇÄ to create a new object:\n\nS = S‚ÇÄ + Œ¥S\n\nor if performance/memory is a concern, one may want to directly add Œ¥S to S‚ÇÄ in-place:\n\naxpy!(1.0, Œ¥S, S‚ÇÄ)\n\nAll of these should give an identical matrix-vector product, but the latter two allow e.g. for the use of direct solvers though an LU factorization.\n\nwarning: Limitations\nIntegral operators defined from custom kernel functions do not support all the features of the predefined ones. In particular, some singular integration methods (e.g. the Density Interpolation Method) and acceleration routines (e.g. Fast Multipole Method) used to correct for singular and nearly singular integral operators, and to accelerate the matrix vector products, are only available for specific kernels. Check the corrections and compression for more details concerning which methods are compatible with custom kernels.","category":"section"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"(Image: Pluto notebook)","category":"section"},{"location":"pluto-examples/helmholtz_scattering/#Helmholtz-scattering","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"note: Important points covered in this example\nCreating a geometry using the Gmsh API\nAssembling integral operators and integral potentials\nSetting up a sound-soft problem in both 2 and 3 spatial dimensions\nUsing GMRES to solve the linear system\nExporting the solution to Gmsh for visualization\n\nIn this tutorial we will show how to solve an acoustic scattering problem in the context of Helmholtz equation. We will focus on a smooth sound-soft obstacle for simplicity, and introduce along the way the necessary techniques used to handle some difficulties encountered. We will use various packages throughout this example (including of course Inti.jl); if they are not on your environment, you can install them using ] add <package> in the REPL.\n\nIn the following section, we will provide a brief mathematical description of the problem (valid in both 2 and 3 dimensions). We will tackle the two-dimensional problem first, for which we do not need to worry much about performance issues (e.g. compressing the integral operators). Finally, we present a three-dimensional example, where we will use HMatrices.jl to compress the underlying integral operators.","category":"section"},{"location":"pluto-examples/helmholtz_scattering/#Sound-soft-problem","page":"Helmholtz scattering","title":"Sound-soft problem","text":"This example concerns the sound-soft acoustic scattering problem. Mathematically, this means solving an exterior problem governed by Helmholtz equation (time-harmonic acoustics) with a Dirichlet boundary condition. More precisely, letting Omega subset mathbbR^d be a bounded domain, and denoting by Gamma = partial Omega its boundary, we wish to solve\n\nDelta u + k^2 u = 0 quad texton quad mathbbR^d setminus barOmega\n\nsubject to Dirichlet boundary conditions on Gamma\n\n\tu(boldsymbolx) = g(boldsymbolx) quad textfor quad boldsymbolx in Gamma\n\nand the Sommerfeld radiation condition at infinity\n\n\tlim_boldsymbolx to infty boldsymbolx^(d-1)2 left( fracpartial upartial boldsymbolx - i k u right) = 0\n\nHere g is a (given) boundary datum, and k is the constant wavenumber.\n\nFor simplicity, we will take Gamma circle/sphere, and focus on the plane-wave scattering problem. This means we will seek a solution u of the form u = u_s + u_i, where u_i is a known incident field, and u_s is the scattered field we wish to compute.\n\nnote: Complex geometries\nThe main reason for focusing on such a simple example is twofold. First, it alleviates the complexities associated with the mesh generation. Second, since exact solutions are known for this problem (in the form of a series), it is easy to assess the accuracy of the solution obtained. In practice, you can use the same techniques to solve the problem on more complex geometries by providing a .msh file containing the mesh.\n\nUsing the theory of boundary integral equations, we can express u_s as\n\n\tu_s(boldsymbolr) = mathcalDsigma(boldsymbolr) - i k mathcalSsigma(boldsymbolr)\n\nwhere mathcalS is the so-called single layer potential, mathcalD is the double-layer potential, and sigma  Gamma to mathbbC is a surface density. This is an indirect formulation (because sigma is an auxiliary density, not necessarily physical) commonly referred to as a combined field formulation. Taking the limit mathbbR^d setminus bar Omega ni x to Gamma, it can be shown that the following equation holds on Gamma:\n\n\tleft( fracmathrmI2 + mathrmD - i k mathrmS right)sigma = g\n\nwhere mathrmI is the identity operator, and mathrmS and mathrmD are the single- and double-layer operators. This is the combined field integral equation that we will solve. The boundary data g is obtained by applying the sound-soft condition u=0 on Gamma, from which it readily follows that u_s = -u_i on Gamma.\n\nWe are now have the necessary background to solve this problem in both 2 and 3 spatial dimensions. Let's load Inti.jl as well as the required dependencies\n\nusing Inti\nusing LinearAlgebra\nusing StaticArrays\nusing Gmsh\nusing Meshes\nusing GLMakie\nusing SpecialFunctions\nusing GSL\nusing IterativeSolvers\nusing LinearMaps\n\nand setup some of the (global) problem parameters:\n\nk = 4œÄ\nŒª = 2œÄ / k\nqorder = 4 # quadrature order\ngorder = 2 # order of geometrical approximation\nnothing #hide","category":"section"},{"location":"pluto-examples/helmholtz_scattering/#Two-dimensional-scattering","page":"Helmholtz scattering","title":"Two-dimensional scattering","text":"We will use Gmsh API for creating .msh file containing the desired geometry and mesh. Here is a function to mesh the circle:\n\nfunction gmsh_circle(; name, meshsize, order = 1, radius = 1, center = (0, 0))\n    return try\n        gmsh.initialize()\n        gmsh.model.add(\"circle-mesh\")\n        gmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\n        gmsh.option.setNumber(\"Mesh.MeshSizeMin\", meshsize)\n        gmsh.model.occ.addDisk(center[1], center[2], 0, radius, radius)\n        gmsh.model.occ.synchronize()\n        gmsh.model.mesh.generate(1)\n        gmsh.model.mesh.setOrder(order)\n        gmsh.write(name)\n    finally\n        gmsh.finalize()\n    end\nend\nnothing #hide\n\nLet us now use gmsh_circle to create a circle.msh file. As customary in wave-scattering problems, we will choose a mesh size that is proportional to wavelength:\n\nname = joinpath(@__DIR__, \"circle.msh\")\nmeshsize = Œª / 5\ngmsh_circle(; meshsize, order = gorder, name)\n\nWe can now import the file and parse the mesh and domain information into Inti.jl using the import_mesh function:\n\nInti.clear_entities!() # empty the entity cache\nmsh = Inti.import_mesh(name; dim = 2)\n\nThe code above will import the mesh with all of its geometrical entities. The dim=2 projects all points to two dimensions by ignoring the third component. To extract the domain Omega we need to filter the entities in the mesh; here we will simply filter them based on the geometric_dimension:\n\nŒ© = Inti.Domain(e -> Inti.geometric_dimension(e) == 2, Inti.entities(msh))\n\nTo solve our boundary integral equation usign a Nystr√∂m method, we actually need a quadrature of our curve/surface (and possibly the normal vectors at the quadrature nodes). Once a mesh is available, creating a quadrature object can be done via the Quadrature constructor, which requires passing a mesh of the domain that one wishes to generate a quadrature for:\n\nŒì = Inti.boundary(Œ©)\nŒì_msh = view(msh, Œì)\nQ = Inti.Quadrature(Œì_msh; qorder)\nnothing #hide\n\ntip: Views of a mesh\nIn Inti.jl, you can use domain to create a view of a mesh containing only the elements in the domain. For example view(msh,Œì) will return an SubMesh type that you can use to iterate over the elements in the boundary of the disk without actually creating a new mesh. You can use msh[Œì], or collect(view(msh,Œì)) to create a new mesh containing only the elements and nodes in Œì.\n\nThe object Q now contains a quadrature (of order 4) that can be used to solve a boundary integral equation on Œì. As a sanity check, let's make sure integrating the function x->1 over Q gives an approximation to the perimeter:\n\nabs(Inti.integrate(x -> 1, Q) - 2œÄ)\n\nWith the Quadrature constructed, we now can define discrete approximation to the integral operators mathrmS and mathrmD as follows:\n\nop = Inti.Helmholtz(; k, dim = 2)\nS, D = Inti.single_double_layer(;\n    op,\n    target = Q,\n    source = Q,\n    compression = (method = :none,),\n    correction = (method = :dim,),\n)\nnothing #hide\n\nThere are two well-known difficulties related to the discretization of the boundary integral operators S and D:\n\nThe kernel of the integral operator is not smooth, and thus specialized quadrature rules are required to accurately approximate the matrix entries for which the target and source point lie close (relative to some scale) to each other.\nThe underlying matrix is dense, and thus the storage and computational cost of the operator is prohibitive for large problems unless acceleration techniques such as Fast Multipole Methods or Hierarchical Matrices are employed.\n\nInti.jl tries to provide a modular and transparent interface for dealing with both of these difficulties, where the general approach for solving a BIE will be to first construct a (possible compressed) naive representation of the integral operator where singular and nearly-singular integrals are ignored, followed by a the creation of a (sparse) correction intended to account for such singular interactions. See single_double_layer for more details on the various options available.\n\nWe can now combine S and D to form the combined-field operator:\n\nL = I / 2 + D - im * k * S\nnothing #hide\n\nwhere I is the identity matrix. Assuming an incident field along the x_1 direction of the form u_i =e^ikx_1, the right-hand side of the equation can be construted using:\n\nu·µ¢ = x -> exp(im * k * x[1]) # plane-wave incident field\nrhs = map(Q) do q\n    x = q.coords\n    return -u·µ¢(x)\nend\nnothing #hide\n\nnote: Iterating over a quadrature\nIn computing rhs above, we used map to evaluate the incident field at all quadrature nodes. When iterating over Q, the iterator returns a QuadratureNode, and not simply the coordinate of the quadrature node. This is so that you can access additional information, such as the normal vector, at the quadrature node.\n\nWe can now solve the integral equation using e.g. the backslash operator:\n\nœÉ = L \\ rhs\nnothing #hide\n\nThe variable œÉ contains the value of the approximate density at the quadrature nodes. To reconstruct a continuous approximation to the solution, we can use single_double_layer_potential to obtain the single- and double-layer potentials, and then combine them as follows:\n\nùíÆ, ùíü = Inti.single_double_layer_potential(; op, source = Q)\nu‚Çõ = x -> ùíü[œÉ](x) - im * k * ùíÆ[œÉ](x)\nnothing #hide\n\nThe variable u‚Çõ is an anonymous/lambda function representing the approximate scattered field.\n\nTo assess the accuracy of the solution, we can compare it to the exact solution (obtained by separation of variables in polar coordinates):\n\nfunction circle_helmholtz_soundsoft(pt; radius = 1, k, Œ∏in)\n    x = pt[1]\n    y = pt[2]\n    r = sqrt(x^2 + y^2)\n    Œ∏ = atan(y, x)\n    u = 0.0\n    r < radius && return u\n    c(n) = -exp(im * n * (œÄ / 2 - Œ∏in)) * besselj(n, k * radius) / besselh(n, k * radius)\n    u = c(0) * besselh(0, k * r)\n    n = 1\n    while (abs(c(n)) > 1.0e-12)\n        u +=\n            c(n) * besselh(n, k * r) * exp(im * n * Œ∏) +\n            c(-n) * besselh(-n, k * r) * exp(-im * n * Œ∏)\n        n += 1\n    end\n    return u\nend\nnothing #hide\n\nHere is the maximum error on some points located on a circle of radius 2:\n\nu‚Çë = x -> circle_helmholtz_soundsoft(x; k, radius = 1, Œ∏in = 0) # exact solution\ner = maximum(0:0.01:2œÄ) do Œ∏\n    R = 2\n    x = (R * cos(Œ∏), R * sin(Œ∏))\n    return abs(u‚Çõ(x) - u‚Çë(x))\nend\n@info \"maximum error = $er\"\n\nAs we can see, the error is quite small! Let's use Makie to visualize the solution in this simple (2d) example:\n\nxx = yy = range(-4; stop = 4, length = 200)\nvals = map(\n    pt -> Inti.isinside(pt, Q) ? NaN : real(u‚Çõ(pt) + u·µ¢(pt)),\n    Iterators.product(xx, yy),\n)\nfig, ax, hm = heatmap(\n    xx,\n    yy,\n    vals;\n    colormap = :inferno,\n    interpolate = true,\n    axis = (aspect = DataAspect(), xgridvisible = false, ygridvisible = false),\n)\nviz!(Œì_msh; color = :white, segmentsize = 5)\nColorbar(fig[1, 2], hm)\nfig\n\nWhile here we simply used a heatmap to visualize the solution, more complex problems may require a mesh-based visualization, where we would first create a mesh for the places where we want to visualize the solution.\n\nBefore moving on to the 3D example let us simply mention that, besides the fact that an analytic solution was available for comparisson, there was nothing special about the unit disk (or the use of GMSH). We could have, for instance, replaced the disk by shapes created parametrically:\n\nlet\n    # vertices of an equilateral triangle centered at the origin with a vertex at (0,1)\n    a, b, c = SVector(0, 1), SVector(sqrt(3) / 2, -1 / 2), SVector(-sqrt(3) / 2, -1 / 2)\n    function circle_f(center, radius)\n        return s -> center + radius * SVector(cospi(2 * s[1]), sinpi(2 * s[1]))\n    end\n    disk1 = Inti.parametric_curve(circle_f(a, 1 / 2), 0, 1)\n    disk2 = Inti.parametric_curve(circle_f(b, 1 / 2), 0, 1)\n    disk3 = Inti.parametric_curve(circle_f(c, 1 / 2), 0, 1)\n    Œì = disk1 ‚à™ disk2 ‚à™ disk3\n    msh = Inti.meshgen(Œì; meshsize)\n    Œì_msh = view(msh, Œì)\n    Q = Inti.Quadrature(Œì_msh; qorder)\n    S, D = Inti.single_double_layer(;\n        op,\n        target = Q,\n        source = Q,\n        compression = (method = :none,),\n        correction = (method = :dim,),\n    )\n    L = I / 2 + D - im * k * S\n    rhs = map(q -> -u·µ¢(q.coords), Q)\n    œÉ = L \\ rhs\n    ùíÆ, ùíü = Inti.single_double_layer_potential(; op, source = Q)\n    u‚Çõ = x -> ùíü[œÉ](x) - im * k * ùíÆ[œÉ](x)\n    vals = map(\n        pt -> Inti.isinside(pt, Q) ? NaN : real(u‚Çõ(pt) + u·µ¢(pt)),\n        Iterators.product(xx, yy),\n    )\n    colorrange = (-2, 2)\n    fig, ax, hm = heatmap(\n        xx,\n        yy,\n        vals;\n        colormap = :inferno,\n        colorrange,\n        interpolate = true,\n        axis = (aspect = DataAspect(), xgridvisible = false, ygridvisible = false),\n    )\n    viz!(Œì_msh; color = :black, segmentsize = 4)\n    Colorbar(fig[1, 2], hm)\n    fig\nend\n\nnote: Near-field evaluation\nIn the example above we employed a naive evaluation of the integral potentials, and therefore the computed solution is expected to become innacurate near the obstacles. See the layer potential tutorial for more information on how to correct for this.","category":"section"},{"location":"pluto-examples/helmholtz_scattering/#Three-dimensional-scattering","page":"Helmholtz scattering","title":"Three-dimensional scattering","text":"We now consider the same problem in 3D. Unlike the 2D case, assembling dense matrix representations of the integral operators quickly becomes unfeasiable as the problem size increases. Inti adds support for compressing the underlying linear operators by wrapping external libraries. In this example, we will rely on HMatrices.jl to handle the compression.\n\nThe visualization is also more involved, and we will use the Gmsh API to create a not only a mesh of the scatterer, but also of a punctured plane where we will visualize the solution. Here is the function that setups up the mesh:\n\nfunction gmsh_sphere(; meshsize, order = gorder, radius = 1, visualize = false, name)\n    gmsh.initialize()\n    gmsh.model.add(\"sphere-scattering\")\n    gmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\n    gmsh.option.setNumber(\"Mesh.MeshSizeMin\", meshsize)\n    sphere_tag = gmsh.model.occ.addSphere(0, 0, 0, radius)\n    xl, yl, zl = -2 * radius, -2 * radius, 0\n    Œîx, Œîy = 4 * radius, 4 * radius\n    rectangle_tag = gmsh.model.occ.addRectangle(xl, yl, zl, Œîx, Œîy)\n    outDimTags, _ =\n        gmsh.model.occ.cut([(2, rectangle_tag)], [(3, sphere_tag)], -1, true, false)\n    gmsh.model.occ.synchronize()\n    gmsh.model.addPhysicalGroup(3, [sphere_tag], -1, \"omega\")\n    gmsh.model.addPhysicalGroup(2, [dt[2] for dt in outDimTags], -1, \"sigma\")\n    gmsh.model.mesh.generate(2)\n    gmsh.model.mesh.setOrder(order)\n    visualize && gmsh.fltk.run()\n    gmsh.option.setNumber(\"Mesh.SaveAll\", 1) # otherwise only the physical groups are saved\n    gmsh.write(name)\n    return gmsh.finalize()\nend\nnothing #hide\n\nAs before, lets write a file with our mesh, and import it into Inti.jl:\n\nname_sphere = joinpath(@__DIR__, \"sphere.msh\")\ngmsh_sphere(; meshsize = (Œª / 5), order = gorder, name = name_sphere, visualize = false)\nmsh_3d = Inti.import_mesh(name_sphere; dim = 3)\n\ntip: Tip\nIf you pass visualize=true to gmsh_sphere, it will open a window with the current model. This is done by calling gmsh.fltk.run(). Note that the main julia thread will be blocked until the window is closed.\n\nSince we created physical groups in Gmsh, we can use them to extract the relevant domains Œ© and Œ£:\n\nŒ©_3d = Inti.Domain(e -> \"omega\" ‚àà Inti.labels(e), Inti.entities(msh_3d))\nŒ£_3d = Inti.Domain(e -> \"sigma\" ‚àà Inti.labels(e), Inti.entities(msh_3d))\nŒì_3d = Inti.boundary(Œ©_3d)\nnothing #hide\n\nWe can now create a quadrature as before\n\nŒì_msh_3d = view(msh_3d, Œì_3d)\nQ_3d = Inti.Quadrature(Œì_msh_3d; qorder)\nnothing #hide\n\ntip: Writing/reading a mesh from disk\nWriting and reading a mesh to/from disk can be time consuming. You can avoid doing so by using import_mesh without a file name to import the mesh from the current gmsh session without the need to write it to disk.\n\nNext we assemble the integral operators, indicating that we wish to compress them using hierarchical matrices:\n\nusing HMatrices\nop_3d = Inti.Helmholtz(; k, dim = 3)\nS_3d, D_3d = Inti.single_double_layer(;\n    op = op_3d,\n    target = Q_3d,\n    source = Q_3d,\n    compression = (method = :hmatrix, tol = 1.0e-4),\n    correction = (method = :dim,),\n)\nnothing #hide\n\nHere is how much memory it would take to store the dense representation of these matrices:\n\nmem = 2 * length(S_3d) * 16 / 1.0e9 # 16 bytes per complex number, 1e9 bytes per GB, two matrices\nprintln(\"memory required to store S and D: $(mem) GB\")\n\nEven for this simple example, the dense representation of the integral operators as matrix is already quite expensive!\n\nnote: Compression methods\nIt is worth mentioning that hierchical matrices are not the only way to compress such integral operators, and may in fact not even be the best for the problem at hand. For example, one could use a fast multipole method (FMM), which has a much lighter memory footprint. See the the tutorial on compression methods for more information.\n\nWe will use the generalized minimal residual (GMRES) iterative solver, for the linear system. This requires us to define a linear operator L, approximating the combined-field operator, that supports the matrix-vector product. While it is possible to add two HMatrix objects to obtain a new HMatrix, this is somewhat more involved due to the addition of low-rank blocks (which requires a recompression). To keep things simple, we will use LinearMaps to lazily compose the operators:\n\nL_3d = I / 2 + LinearMap(D_3d) - im * k * LinearMap(S_3d)\nnothing #hide\n\nWe can now solve the linear system using GMRES solver:\n\nrhs_3d = map(Q_3d) do q\n    x = q.coords\n    return -u·µ¢(x)\nend\nœÉ_3d, hist = gmres(\n    L_3d,\n    rhs_3d;\n    log = true,\n    abstol = 1.0e-6,\n    verbose = false,\n    restart = 100,\n    maxiter = 100,\n)\n@show hist\n\nAs before, let us represent the solution using IntegralPotentials:\n\nùíÆ_3d, ùíü_3d = Inti.single_double_layer_potential(; op = op_3d, source = Q_3d)\nu‚Çõ_3d = x -> ùíü_3d[œÉ_3d](x) - im * k * ùíÆ_3d[œÉ_3d](x)\nnothing #hide\n\nTo check the result, we compare against the exact solution obtained through a series:\n\nsphbesselj(l, r) = sqrt(œÄ / (2r)) * besselj(l + 1 / 2, r)\nsphbesselh(l, r) = sqrt(œÄ / (2r)) * besselh(l + 1 / 2, r)\nsphharmonic(l, m, Œ∏, œï) = GSL.sf_legendre_sphPlm(l, abs(m), cos(Œ∏)) * exp(im * m * œï)\nfunction sphere_helmholtz_soundsoft(xobs; radius = 1, k = 1, Œ∏in = 0, œïin = 0)\n    x = xobs[1]\n    y = xobs[2]\n    z = xobs[3]\n    r = sqrt(x^2 + y^2 + z^2)\n    Œ∏ = acos(z / r)\n    œï = atan(y, x)\n    u = 0.0\n    r < radius && return u\n    function c(l, m)\n        return -4œÄ * im^l * sphharmonic(l, -m, Œ∏in, œïin) * sphbesselj(l, k * radius) /\n            sphbesselh(l, k * radius)\n    end\n    l = 0\n    for l in 0:60\n        for m in -l:l\n            u += c(l, m) * sphbesselh(l, k * r) * sphharmonic(l, m, Œ∏, œï)\n        end\n        l += 1\n    end\n    return u\nend\nnothing #hide\n\nWe will compute the error on some point on the sphere of radius 2:\n\nu‚Çë_3d = (x) -> sphere_helmholtz_soundsoft(x; radius = 1, k = k, Œ∏in = œÄ / 2, œïin = 0)\ner_3d = maximum(1:100) do _\n    xÃÇ = rand(Inti.Point3D) |> normalize # an SVector of unit norm\n    x = 2 * xÃÇ\n    return abs(u‚Çõ_3d(x) - u‚Çë_3d(x))\nend\n@info \"error with correction = $er_3d\"\n\nWe see that, once again, the approximation is quite accurate. Let us now visualize the solution on the punctured plane (which we labeled as \"sigma\"). Since evaluating the integral representation of the solution at many points is expensive, we will use again use a method to accelerate the evaluation:\n\nŒ£_msh = view(msh_3d, Œ£_3d)\ntarget = Inti.nodes(Œ£_msh)\n\nS_viz, D_viz = Inti.single_double_layer(;\n    op = op_3d,\n    target,\n    source = Q_3d,\n    compression = (method = :hmatrix, tol = 1.0e-4),\n    # correction for the nearfield (for visual purposes, set to `:none` to disable)\n    correction = (method = :dim, maxdist = meshsize, target_location = :outside),\n)\n\nui_eval_msh = u·µ¢.(target)\nus_eval_msh = D_viz * œÉ_3d - im * k * S_viz * œÉ_3d\nu_eval_msh = ui_eval_msh + us_eval_msh\nnothing #hide\n\nFinalize, we use Meshes.viz to visualize the scattered field:\n\nnv = length(Inti.nodes(Œì_msh_3d))\ncolorrange = extrema(real(u_eval_msh))\ncolormap = :inferno\nfig_3d = Figure(; size = (800, 500))\nax_3d = Axis3(fig_3d[1, 1]; aspect = :data)\nviz!(Œì_msh_3d; colorrange, colormap, color = zeros(nv), interpolate = true)\nviz!(Œ£_msh; colorrange, colormap, color = real(u_eval_msh))\ncb = Colorbar(fig_3d[1, 2]; label = \"real(u)\", colormap, colorrange)\nfig_3d #hide","category":"section"},{"location":"pluto-examples/toy_example/","page":"Toy example","title":"Toy example","text":"(Image: Pluto notebook)","category":"section"},{"location":"pluto-examples/toy_example/#Toy-example","page":"Toy example","title":"Toy example","text":"All examples in Inti.jl are autogenerated by executing the make.jl script in the docs folder. The workflow uses Pluto.jl to generate markdown files passed to Documenter.jl. The original pluto notebook files are downloadable from the example's page.\n\nusing Inti","category":"section"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/#Inti.Inti","page":"Docstrings","title":"Inti.Inti","text":"module Inti\n\nLibrary for solving integral equations using Nystr√∂m methods.\n\n\n\n\n\n","category":"module"},{"location":"docstrings/#Inti.COMPRESSION_METHODS","page":"Docstrings","title":"Inti.COMPRESSION_METHODS","text":"const COMPRESSION_METHODS = [:none, :hmatrix, :fmm]\n\nAvailable compression methods for the dense linear operators in Inti.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#Inti.CORRECTION_METHODS","page":"Docstrings","title":"Inti.CORRECTION_METHODS","text":"const CORRECTION_METHODS = [:none, :dim, :adaptive]\n\nAvailable correction methods for the singular and nearly-singular integrals in Inti.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#Inti.ENTITIES","page":"Docstrings","title":"Inti.ENTITIES","text":"const ENTITIES\n\nDictionary mapping EntityKey to GeometricEntity. Contains all entities created in a given session.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#Inti.SAME_POINT_TOLERANCE","page":"Docstrings","title":"Inti.SAME_POINT_TOLERANCE","text":"SAME_POINTS_TOLERANCE\n\nTwo points x and y are considerd the same if norm(x-y) ‚â§ SAME_POINT_TOLERANCE.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#Inti.AbstractDifferentialOperator","page":"Docstrings","title":"Inti.AbstractDifferentialOperator","text":"abstract type AbstractDifferentialOperator{N}\n\nA partial differential operator in dimension N.\n\nAbstractDifferentialOperator types are used to define AbstractKernels related to fundamental solutions of differential operators.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.AbstractKernel","page":"Docstrings","title":"Inti.AbstractKernel","text":"abstract type AbstractKernel{T}\n\nA kernel functions K with the signature K(target,source)::T.\n\nSee also: SingleLayerKernel, DoubleLayerKernel, AdjointDoubleLayerKernel, HyperSingularKernel\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.AbstractMesh","page":"Docstrings","title":"Inti.AbstractMesh","text":"abstract type AbstractMesh{N,T}\n\nAn abstract mesh structure in dimension N with primite data of type T (e.g. Float64 for double precision representation).\n\nConcrete subtypes of AbstractMesh should implement ElementIterator for accessing the mesh elements.\n\nSee also: Mesh\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.AdjointDoubleLayerKernel","page":"Docstrings","title":"Inti.AdjointDoubleLayerKernel","text":"struct AdjointDoubleLayerKernel{T,Op} <: AbstractKernel{T}\n\nGiven an operator Op, construct its free-space adjoint double-layer kernel. This corresponds to the transpose(Œ≥‚ÇÅ,‚Çì[G]), where G is the SingleLayerKernel. For operators such as Laplace or Helmholtz, this is simply the normal derivative of the fundamental solution respect to the target variable.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.BlockArray","page":"Docstrings","title":"Inti.BlockArray","text":"struct BlockArray{T<:StaticArray,N,S} <: AbstractMatrix{T,N}\n\nA struct which behaves like an  Array{T,N}, but with the underlying data stored as a Matrix{S}, where S::Number = eltype(T) is the scalar type associated with T. This allows for the use of many blas routines under-the-hood, while providing a convenient interface for handling arrays over StaticArrays.\n\nusing StaticArrays\nT = SMatrix{2,2,Int,4}\nB = Inti.BlockArray{T}([i*j for i in 1:4, j in 1:4])\n\n# output\n\n2√ó2 Inti.BlockArray{SMatrix{2, 2, Int64, 4}, 2, Int64, 2}:\n [1 2; 2 4]  [3 4; 6 8]\n [3 6; 4 8]  [9 12; 12 16]\n\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.DimParameters","page":"Docstrings","title":"Inti.DimParameters","text":"struct DimParameters\n\nParameters associated with the density interpolation method used in bdim_correction.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Domain","page":"Docstrings","title":"Inti.Domain","text":"struct Domain\n\nRepresentation of a geometrical domain formed by a set of entities with the same geometric dimension. For basic set operations on domains are supported (union, intersection, difference, etc), and they all return a new Domain object.\n\nCalling keys(Œ©) returns the set of EntityKeys that make up the domain; given a key, the underlying entities can be accessed with global_get_entity(key).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Domain-Tuple{Function, Any}","page":"Docstrings","title":"Inti.Domain","text":"Domain([f::Function,] keys)\n\nCreate a domain from a set of EntityKeys. Optionally, a filter function f can be passed to filter the entities.\n\nNote that all entities in a domain must have the same geometric dimension.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.Domain-Tuple{Function, Inti.AbstractMesh}","page":"Docstrings","title":"Inti.Domain","text":"Domain(f::Function, msh::AbstractMesh)\n\nCall Domain(f, ents) on ents = entities(msh).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.DoubleLayerKernel","page":"Docstrings","title":"Inti.DoubleLayerKernel","text":"struct DoubleLayerKernel{T,Op} <: AbstractKernel{T}\n\nGiven an operator Op, construct its free-space double-layer kernel. This corresponds to the Œ≥‚ÇÅ trace of the SingleLayerKernel. For operators such as Laplace or Helmholtz, this is simply the normal derivative of the fundamental solution with respect to the source variable.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Elastostatic","page":"Docstrings","title":"Inti.Elastostatic","text":"struct Elastostatic{N,T} <: AbstractDifferentialOperator{N}\n\nElastostatic operator in N dimensions: -ŒºŒîu - (Œº+Œª)‚àá(‚àá‚ãÖu)\n\nNote that the displacement u is a vector of length N since this is a vectorial problem.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ElementIterator","page":"Docstrings","title":"Inti.ElementIterator","text":"struct ElementIterator{E,M} <: AbstractVector{E}\n\nStructure to lazily access elements of type E in a mesh of type M. This is particularly useful for LagrangeElements, where the information to reconstruct the element is stored in the mesh connectivity matrix.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.EmbeddedQuadrature","page":"Docstrings","title":"Inti.EmbeddedQuadrature","text":"struct EmbeddedQuadrature{L,H,D} <: ReferenceQuadrature{D}\n\nA quadrature rule for the reference shape D based on a high-order quadrature of type H and a low-order quadrature of type L. The low-order quadrature rule is embedded in the sense that its n nodes are exactly the first n nodes of the high-order quadrature rule.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.EntityKey","page":"Docstrings","title":"Inti.EntityKey","text":"EntityKey\n\nUsed to represent the key of a GeometricEntity, comprised of a dim and a tag field, where dim is the geometrical dimension of the entity, and tag is a unique integer identifying the entity.\n\nThe sign of the tag field is used to distinguish the orientation of the entity, and is ignored when comparing two EntityKeys for equality.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Fejer","page":"Docstrings","title":"Inti.Fejer","text":"struct Fejer{N}\n\nN-point Fejer's first quadrature rule for integrating a function over [0,1]. Exactly integrates all polynomials of degree ‚â§ N-1.\n\nusing Inti\n\nq = Inti.Fejer(;order=10)\n\nInti.integrate(cos,q) ‚âà sin(1) - sin(0)\n\n# output\n\ntrue\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Gauss","page":"Docstrings","title":"Inti.Gauss","text":"struct Gauss{D,N} <: ReferenceQuadrature{D}\n\nTabulated N-point symmetric Gauss quadrature rule for integration over D.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.GaussLegendre","page":"Docstrings","title":"Inti.GaussLegendre","text":"struct GaussLegendre{N,T}\n\nN-point Gauss-Legendre quadrature rule for integrating a function over [0,1]. Exactly integrates all polynomials of degree ‚â§ 2N-1.\n\nusing Inti\n\nq = Inti.GaussLegendre(;order=10)\n\nInti.integrate(cos,q) ‚âà sin(1) - sin(0)\n\n# output\n\ntrue\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.GeometricEntity","page":"Docstrings","title":"Inti.GeometricEntity","text":"struct GeometricEntity\n\nGeometrical objects such as lines, surfaces, and volumes.\n\nGeometrical entities are stored in a global ENTITIES dictionary mapping EntityKey to the corresponding GeometricEntity, and usually entities are manipulated through their keys.\n\nA GeometricEntity can also contain a pushforward field used to parametrically represent the entry as the image of a reference domain (pushforward.domain) under some function (pushforward.parametrization).\n\nNote that entities are manipulated through their keys, and the GeometricEntity constructor returns the key of the created entity; to retrieve the entity, use the global_get_entity function.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.GeometricEntity-Tuple{String}","page":"Docstrings","title":"Inti.GeometricEntity","text":"GeometricEntity(shape::String [; translation, rotation, scaling, kwargs...])\n\nConstructs a geometric entity with the specified shape and optional parameters, and returns its key.\n\nArguments\n\nshape::String: The shape of the geometric entity.\ntranslation: The translation vector of the geometric entity. Default is SVector(0, 0, 0).\nrotation: The rotation vector of the geometric entity. Default is SVector(0, 0, 0).\nscaling: The scaling vector of the geometric entity. Default is SVector(1, 1, 1).\nkwargs...: Additional keyword arguments to be passed to the shape constructor.\n\nSupported shapes\n\nellipsoid\ntorus\nbean\nacorn\ncushion\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.Helmholtz-Tuple{}","page":"Docstrings","title":"Inti.Helmholtz","text":"Helmholtz(; k, dim)\n\nHelmholtz operator in dim dimensions: -Œîu - k¬≤u.\n\nThe parameter k can be a real or complex number. For purely imaginary wavenumbers, consider using the Yukawa kernel.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.HyperRectangle","page":"Docstrings","title":"Inti.HyperRectangle","text":"struct HyperRectangle{N,T} <: ReferenceInterpolant{ReferenceHyperCube{N},T}\n\nAxis-aligned hyperrectangle in N dimensions given by low_corner::SVector{N,T} and high_corner::SVector{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.HyperSingularKernel","page":"Docstrings","title":"Inti.HyperSingularKernel","text":"struct HyperSingularKernel{T,Op} <: AbstractKernel{T}\n\nGiven an operator Op, construct its free-space hypersingular kernel. This corresponds to the transpose(Œ≥‚ÇÅ,‚ÇìŒ≥‚ÇÅ[G]), where G is the SingleLayerKernel. For operators such as Laplace or Helmholtz, this is simply the normal derivative respect to the target variable of the DoubleLayerKernel.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.IntegralOperator","page":"Docstrings","title":"Inti.IntegralOperator","text":"struct IntegralOperator{T} <: AbstractMatrix{T}\n\nA discrete linear integral operator given by\n\nIu(x) = int_Gamma_s K(xy)u(y) ds_y x in Gamma_t\n\nwhere Gamma_s and Gamma_t are the source and target domains, respectively.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.IntegralPotential","page":"Docstrings","title":"Inti.IntegralPotential","text":"struct IntegralPotential\n\nRepresent a potential given by a kernel and a quadrature over which integration is performed.\n\nIntegralPotentials are created using IntegralPotential(kernel, quadrature).\n\nEvaluating an integral potential requires a density œÉ (defined over the quadrature nodes of the source mesh) and a point x at which to evaluate the integral\n\nint_Gamma K(oldsymbolxoldsymboly)sigma(y) ds_y x not in Gamma\n\nAssuming ùíÆ is an integral potential and œÉ is a vector of values defined on quadrature, calling ùíÆ[œÉ] creates an anonymous function that can be evaluated at any point x.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeCube","page":"Docstrings","title":"Inti.LagrangeCube","text":"const LagrangeCube = LagrangeElement{ReferenceCube}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeElement","page":"Docstrings","title":"Inti.LagrangeElement","text":"struct LagrangeElement{D,Np,T} <: ReferenceInterpolant{D,T}\n\nA polynomial p : D ‚Üí T uniquely defined by its Np values on the Np reference nodes of D.\n\nThe return type T should be a vector space (i.e. support addition and multiplication by scalars). For istance, T could be a number or a vector, but not a Tuple.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeLine","page":"Docstrings","title":"Inti.LagrangeLine","text":"const LagrangeLine = LagrangeElement{ReferenceLine}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeSquare","page":"Docstrings","title":"Inti.LagrangeSquare","text":"const LagrangeSquare = LagrangeElement{ReferenceSquare}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeTetrahedron","page":"Docstrings","title":"Inti.LagrangeTetrahedron","text":"const LagrangeTetrahedron = LagrangeElement{ReferenceTetrahedron}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeTriangle","page":"Docstrings","title":"Inti.LagrangeTriangle","text":"const LagrangeTriangle = LagrangeElement{ReferenceTriangle}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Laplace-Tuple{}","page":"Docstrings","title":"Inti.Laplace","text":"Laplace(; dim)\n\nLaplace's differential operator in dim dimension: -Œîu. ```\n\nNote the negative sign in the definition.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.LaplacePeriodic1D-Tuple{}","page":"Docstrings","title":"Inti.LaplacePeriodic1D","text":"LaplacePeriodic1D(; dim, period = 2œÄ)\n\nLaplace's differential operator -Œîu in dim dimension with periodic boundary conditions along the first dimension. The period is set to 2œÄ by default, and the periodic cell is defined as [-period/2, period/2].\n\nThe negative sign is used to match the convention of coercive operators.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.Mesh","page":"Docstrings","title":"Inti.Mesh","text":"struct Mesh{N,T} <: AbstractMesh{N,T}\n\nUnstructured mesh defined by a set of nodes(of typeSVector{N,T}`), and a dictionary mapping element types to connectivity matrices. Each column of a given connectivity matrix stores the integer tags of the nodes in the mesh comprising the element.\n\nAdditionally, the mesh contains a mapping from EntityKeys to the tags of the elements composing the entity. This can be used to extract submeshes from a given mesh using e.g. view(msh,Œì) or msh[Œì], where Œì is a Domain.\n\nSee elements for a way to iterate over the elements of a mesh.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ModifiedHelmholtz","page":"Docstrings","title":"Inti.ModifiedHelmholtz","text":"const ModifiedHelmholtz\n\nType alias for the Yukawa operator.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.MultiIndex","page":"Docstrings","title":"Inti.MultiIndex","text":"MultiIndex{N}\n\nWrapper around NTuple{N,Int} mimicking a multi-index in ‚Ñ§‚ÇÄ·¥∫.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ParametricElement","page":"Docstrings","title":"Inti.ParametricElement","text":"ParametricElement{D,T,F} <: ReferenceInterpolant{D,T}\n\nAn element represented through a explicit function f mapping D into the element. For performance reasons, f should take as input a StaticVector and return a StaticVector or StaticArray.\n\nSee also: ReferenceInterpolant, LagrangeElement\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ParametricElement-Union{Tuple{T}, Tuple{N}, Tuple{Any, Inti.HyperRectangle{N, T}}} where {N, T}","page":"Docstrings","title":"Inti.ParametricElement","text":"ParametricElement(f, d::HyperRectangle)\n\nConstruct the element defined as the image of f over d.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.PolynomialSpace","page":"Docstrings","title":"Inti.PolynomialSpace","text":"struct PolynomialSpace{D,K}\n\nThe space of all polynomials of degree ‚â§K, commonly referred to as ‚Ñô‚Çñ.\n\nThe type parameter D, of singleton type, is used to determine the reference domain of the polynomial basis. In particular, when D is a hypercube in d dimensions, the precise definition is ‚Ñô‚Çñ = span{ùê±·∂ø : 0‚â§max(Œ∏)‚â§ K}; when D is a d-dimensional simplex, the space is ‚Ñô‚Çñ = span{ùê±·∂ø : 0‚â§sum(Œ∏)‚â§ K}, where Œ∏ ‚àà ùêç·µà is a multi-index.\n\nSee also: monomial_basis, lagrange_basis\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Quadrature","page":"Docstrings","title":"Inti.Quadrature","text":"struct Quadrature{N,T} <: AbstractVector{QuadratureNode{N,T}}\n\nA collection of QuadratureNodes used to integrate over an AbstractMesh.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Quadrature-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.Quadrature","text":"Quadrature(Œ©::Domain; meshsize, qorder)\n\nConstruct a Quadrature over the domain Œ© with a mesh of size meshsize and quadrature order qorder.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.Quadrature-Union{Tuple{T}, Tuple{N}, Tuple{Inti.AbstractMesh{N, T}, OrderedCollections.OrderedDict}} where {N, T}","page":"Docstrings","title":"Inti.Quadrature","text":"Quadrature(msh::AbstractMesh, etype2qrule::Dict)\nQuadrature(msh::AbstractMesh, qrule::ReferenceQuadrature)\nQuadrature(msh::AbstractMesh; qorder)\n\nConstruct a Quadrature for msh, where for each element type E in msh the reference quadrature q = etype2qrule[E] is used. When a single qrule is passed, it is used for all element types in msh.\n\nIf an order keyword is passed, a default quadrature of the desired order is used for each element type using _qrule_for_reference_shape.\n\nFor co-dimension one elements, the normal vector is also computed and stored in the QuadratureNodes.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.QuadratureNode","page":"Docstrings","title":"Inti.QuadratureNode","text":"QuadratureNode{N,T<:Real}\n\nA point in ‚Ñù·¥∫ with a weight for performing numerical integration. A QuadratureNode can optionally store a normal vector.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceCube","page":"Docstrings","title":"Inti.ReferenceCube","text":"const ReferenceCube = ReferenceHyperCube{3}\n\nSingleton type representing the unit cube [0,1]¬≥.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceHyperCube","page":"Docstrings","title":"Inti.ReferenceHyperCube","text":"struct ReferenceHyperCube{N} <: ReferenceShape{N}\n\nSingleton type representing the axis-aligned hypercube in N dimensions with the lower corner at the origin and the upper corner at (1,1,‚Ä¶,1).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceInterpolant","page":"Docstrings","title":"Inti.ReferenceInterpolant","text":"abstract type ReferenceInterpolant{D,T}\n\nInterpolating function mapping points on the domain D<:ReferenceShape (of singleton type) to a value of type T.\n\nInstances el of ReferenceInterpolant are expected to implement:\n\nel(xÃÇ): evaluate the interpolation scheme at the (reference) coordinate xÃÇ ‚àà D.\njacobian(el,xÃÇ) : evaluate the jacobian matrix of the interpolation at the (reference) coordinate x ‚àà D.\n\nnote: Note\nFor performance reasons, both el(xÃÇ) and jacobian(el,xÃÇ) should take as input a StaticVector and output a static vector or static array.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceLine","page":"Docstrings","title":"Inti.ReferenceLine","text":"const ReferenceLine = ReferenceHyperCube{1}\n\nSingleton type representing the [0,1] segment.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceQuadrature","page":"Docstrings","title":"Inti.ReferenceQuadrature","text":"abstract type ReferenceQuadrature{D}\n\nA quadrature rule for integrating a function over the domain D <: ReferenceShape.\n\nCalling x,w = q() returns the nodes x, given as SVectors, and weights w, for performing integration over domain(q).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceShape","page":"Docstrings","title":"Inti.ReferenceShape","text":"abstract type ReferenceShape\n\nA fixed reference domain/shape. Used mostly for defining more complex shapes as transformations mapping an ReferenceShape to some region of ‚Ñú·¥π.\n\nSee e.g. ReferenceLine or ReferenceTriangle for some examples of concrete subtypes.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceSimplex","page":"Docstrings","title":"Inti.ReferenceSimplex","text":"struct ReferenceSimplex{N}\n\nSingleton type representing the N-simplex with N+1 vertices (0,...,0),(0,...,0,1),(0,...,0,1,0),(1,0,...,0)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceSquare","page":"Docstrings","title":"Inti.ReferenceSquare","text":"const ReferenceSquare = ReferenceHyperCube{2}\n\nSingleton type representing the unit square [0,1]¬≤.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceTetrahedron","page":"Docstrings","title":"Inti.ReferenceTetrahedron","text":"struct ReferenceTetrahedron\n\nSingleton type representing the tetrahedron with vertices (0,0,0),(0,0,1),(0,1,0),(1,0,0)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceTriangle","page":"Docstrings","title":"Inti.ReferenceTriangle","text":"struct ReferenceTriangle\n\nSingleton type representing the triangle with vertices (0,0),(1,0),(0,1)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.SingleLayerKernel","page":"Docstrings","title":"Inti.SingleLayerKernel","text":"struct SingleLayerKernel{T,Op} <: AbstractKernel{T}\n\nThe free-space single-layer kernel (i.e. the fundamental solution) of an Op <: AbstractDifferentialOperator.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Stokes-Tuple{}","page":"Docstrings","title":"Inti.Stokes","text":"Stokes(; Œº, dim)\n\nStokes operator in dim dimensions: -ŒºŒîu + p u.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.SubMesh","page":"Docstrings","title":"Inti.SubMesh","text":"struct SubMesh{N,T} <: AbstractMesh{N,T}\n\nView into a parent mesh over a given domain.\n\nA submesh implements the interface for AbstractMesh; therefore you can iterate over elements of the submesh just like you would with a mesh.\n\nConstruct SubMeshs using view(parent,Œ©::Domain).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.TensorProductQuadrature","page":"Docstrings","title":"Inti.TensorProductQuadrature","text":"TensorProductQuadrature{N,Q}\n\nA tensor-product of one-dimension quadrature rules. Integrates over [0,1]^N.\n\nExamples\n\nqx = Inti.Fejer(10)\nqy = Inti.Fejer(15)\nq  = Inti.TensorProductQuadrature(qx,qy)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.VioreanuRokhlin","page":"Docstrings","title":"Inti.VioreanuRokhlin","text":"struct VioreanuRokhlin{D,N} <: ReferenceQuadrature{D}\n\nTabulated N-point Vioreanu-Rokhlin quadrature rule for integration over D.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Yukawa-Tuple{}","page":"Docstrings","title":"Inti.Yukawa","text":"Yukawa(; Œª, dim)\n\nYukawa operator, also known as modified Helmholtz, in dim dimensions: -Œîu + Œª¬≤u.\n\nThe parameter Œª is a positive number. Note the negative sign in front of the Laplacian.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.iterate","page":"Docstrings","title":"Base.iterate","text":"iterate(Œ©::Domain)\n\nIterating over a domain means iterating over its entities.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.DoubleLayerPotential-Tuple{Inti.AbstractDifferentialOperator, Inti.Quadrature}","page":"Docstrings","title":"Inti.DoubleLayerPotential","text":"DoubleLayerPotential(op::AbstractDifferentialOperator, source::Quadrature)\n\nAn IntegralPotential over source with kernel given by DoubleLayerKernel(op).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.SingleLayerPotential-Tuple{Inti.AbstractDifferentialOperator, Inti.Quadrature}","page":"Docstrings","title":"Inti.SingleLayerPotential","text":"SingleLayerPotential(op::AbstractDifferentialOperator, source::Quadrature)\n\nAn IntegralPotential over source with kernel given by SingleLayerKernel(op).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._blocksize_normalized-Union{Tuple{Inti.BlockArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Docstrings","title":"Inti._blocksize_normalized","text":"_blocksize_normalized(A::BlockArray)\n\nLike blocksize, but appends 1s if A is a higher-dimensional.\n\nFor example, a BlockArray{SVector{3,Float64}, 2} has a blocksize of (3,), but a normalized_blocksize of (3, 1).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._get_gauss_qcoords_and_qweights-Tuple{Type{<:Inti.ReferenceShape}, Any}","page":"Docstrings","title":"Inti._get_gauss_qcoords_and_qweights","text":"_get_gauss_and_qweights(R::Type{<:ReferenceShape{D}}, N) where D\n\nReturns the N-point symmetric gaussian qnodes and qweights (x, w) for integration over R.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._get_vioreanurokhlin_qcoords_and_qweights-Tuple{Type{<:Inti.ReferenceShape}, Any}","page":"Docstrings","title":"Inti._get_vioreanurokhlin_qcoords_and_qweights","text":"_get_vioreanurokhlin_qcoords_and_qweights(R::Type{<:ReferenceShape{D}}, N) where D\n\nReturns the N-point Vioreanu-Rokhlin qnodes and qweights (x, w) for integration over R.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._green_multiplier-Tuple{Symbol}","page":"Docstrings","title":"Inti._green_multiplier","text":"_green_multiplier(s::Symbol)\n\nReturn -1.0 if s == :inside, 0.0 if s == :outside, and -0.5 if s == :on; otherwise, throw an error. The orientation is relative to the normal of the bounding curve/surface.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._green_multiplier-Union{Tuple{N}, Tuple{StaticArraysCore.SVector, Inti.Quadrature{N}}} where N","page":"Docstrings","title":"Inti._green_multiplier","text":"_green_multiplier(x, quad)\n\nHelper function to help determine the constant œÉ in the Green identity S[Œ≥‚ÇÅu](x)\n\nD[Œ≥‚ÇÄu](x) + œÉ*u(x) = 0. This can be used as a predicate to determine whether a\n\npoint is inside a domain or not.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._meshgen-Tuple{Any, Inti.HyperRectangle, NTuple{N, T} where {N, T}}","page":"Docstrings","title":"Inti._meshgen","text":"_meshgen(f,d::HyperRectangle,sz)\n\nCreate prod(sz) elements of ParametricElement type representing the push forward of f on each of the subdomains defined by a uniform cartesian mesh of d of size sz.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._normal-Union{Tuple{StaticArraysCore.SMatrix{N, M}}, Tuple{M}, Tuple{N}, Tuple{StaticArraysCore.SMatrix{N, M}, Any}} where {N, M}","page":"Docstrings","title":"Inti._normal","text":"_normal(jac::SMatrix{M,N}, s = 1)\n\nGiven a an M by N matrix representing the jacobian of a codimension one object, compute the normal vector. If s=-1, the normal vector is flipped.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._qrule_for_reference_shape-Tuple{Any, Any}","page":"Docstrings","title":"Inti._qrule_for_reference_shape","text":"_qrule_for_reference_shape(ref,order)\n\nGiven a reference shape and a desired quadrature order, return an appropiate quadrature rule.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.acorn-Tuple{}","page":"Docstrings","title":"Inti.acorn","text":"acorn(; translation, rotation, scaling, labels)\n\nCreate an acorn entity in 3D, and apply optional transformations. Returns the key.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.adaptive_correction-Tuple{Inti.IntegralOperator}","page":"Docstrings","title":"Inti.adaptive_correction","text":"adaptive_correction(iop::IntegralOperator; [maxdist, atol, rtol, threads = true, kwargs...])\nadaptive_correction(iop::IntegralOperator, maxdist, quads_dict::Dict, threads = true)\n\nThis function computes a sparse correction for the integral operator iop, addressing its singular or nearly singular entries.\n\nThe parameter maxdist specifies the maximum distance between target points and source elements to be considered for correction (only interactions within this distance are corrected).\n\nThe parameters atol and rtol define the absolute and relative tolerances for the adaptive quadrature used to compute the corrections for singular or nearly singular entries.\n\nAdditional kwargs arguments are passed to adaptive_quadrature; see its documentation for more information.\n\nSelecting maxdist and (atol,rtol) involves balancing accuracy and computational cost. A smaller maxdist reduces the number of corrections but may impact accuracy. Conversely, a smaller tolerance improves correction accuracy but increases computational expense. The ideal values depend on the kernel and the mesh/quadrature rule applied.\n\nBy default, maxdist and (atol,rtol) are estimated using the local_correction_dist_and_tol, but it is often possible to improve performance by manually tuning these parameters.\n\nAdvanced usage\n\nFor finer control, you can provide a dictionary quads_dict that contains quadrature rules for each reference element type present in the mesh of source(iop). This allows you to fine-tune the quadrature rules for specific element types (e.g. use a fixed quadrature rule instead of an adaptive one).\n\nThe dictionary quads_dict must adhere to the following structure:\n\nquads_dict[E].nearfield_quad: A function that integrates over the nearfield of the reference element type E. Used in the nearly-singular correction.\nquads_dict[E].radial_quad: A function that integrates over the radial direction of the reference element type E. Used in the singular correction.\nquads_dict[E].angular_quad: A function that integrates over the angular direction of the reference element type E. Used in the singular correction.\n\nHere is an example of how to implement a custom quads_dict given an iop:\n\nquads_dict = OrderedDict()\nmsh = Inti.mesh(source(iop))\nfor E in Inti.element_types(msh)\n    ref_domain = Inti.reference_domain(E)\n    quads = (\n        nearfield_quad = Inti.adaptive_quadrature(ref_domain; atol),\n        radial_quad    = Inti.GaussLegendre(;order=5),\n        angular_quad   = Inti.GaussLegendre(;order=20),\n    )\n    quads_dict[E] = quads\nend\n\nThis will use an adaptive quadrature rule for the nearfield and fixed Gauss-Legendre quadrature rules for the radial and angular directions when computing the singular correction in polar coordinates on the reference domain. You can then call adaptive_correction(iop, maxdist, quads_dict) to use the custom quadrature.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.adaptive_quadrature-Tuple{Inti.ReferenceHyperCube{1}}","page":"Docstrings","title":"Inti.adaptive_quadrature","text":"adaptive_quadrature(ref_domain::ReferenceShape; kwargs...)\n\nReturn a function quad callable as quad(f) that integrates the function f over the reference shape ref_domain. The keyword arguments are passed to HAdaptiveIntegration.integrate.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.adj_double_layer_hypersingular-Tuple{}","page":"Docstrings","title":"Inti.adj_double_layer_hypersingular","text":"adj_double_layer_hypersingular(; op, target, source, compression,\ncorrection)\n\nSimilar to single_double_layer, but for the adjoint double-layer and hypersingular operators. See the documentation of [single_double_layer] for a description of the arguments.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.ambient_dimension","page":"Docstrings","title":"Inti.ambient_dimension","text":"ambient_dimension(x)\n\nDimension of the ambient space where x lives. For geometrical objects this can differ from its geometric_dimension; for example a triangle in ‚Ñù¬≥ has ambient dimension 3 but geometric dimension 2, while a curve in ‚Ñù¬≥ has ambient dimension 3 but geometric dimension 1.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.assemble_fmm-Tuple{Inti.IntegralOperator}","page":"Docstrings","title":"Inti.assemble_fmm","text":"assemble_fmm(iop; rtol)\n\nSet up a 2D or 3D FMM for evaluating the discretized integral operator iop associated with the op. In 2D the FMM2D or FMMLIB2D library is used (whichever was most recently loaded) while in 3D FMM3D is used.\n\nwarning: FMMLIB2D\nFMMLIB2D does no checking for if the targets and sources coincide, and will return Inf values if iop.target !== iop.source, but there is a point x ‚àà iop.target such that x ‚àà iop.source.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.assemble_hmatrix-Tuple","page":"Docstrings","title":"Inti.assemble_hmatrix","text":"assemble_hmatrix(iop[; atol, rank, rtol, eta])\n\nAssemble an H-matrix representation of the discretized integral operator iop using the HMatrices.jl library.\n\nSee the documentation of HMatrices for more details on usage and other keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.assemble_matrix-Tuple{Inti.IntegralOperator}","page":"Docstrings","title":"Inti.assemble_matrix","text":"assemble_matrix(iop::IntegralOperator; threads = true)\n\nAssemble a dense matrix representation of an IntegralOperator.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.bdim_correction-Tuple{Any, Any, Inti.Quadrature, Any, Any}","page":"Docstrings","title":"Inti.bdim_correction","text":"bdim_correction(op,X,Y,S,D; green_multiplier, kwargs...)\n\nGiven a op and a (possibly inaccurate) discretizations of its single and double-layer operators S and D (taking a vector of values on Y and returning a vector on of values on X), compute corrections Œ¥S and Œ¥D such that S + Œ¥S and D + Œ¥D are more accurate approximations of the underlying single- and double-layer integral operators.\n\nSee [9] for more details on the method.\n\nArguments\n\nRequired:\n\nop must be an AbstractDifferentialOperator\nY must be a Quadrature object of a closed surface\nX is either inside, outside, or on Y\nS and D are approximations to the single- and double-layer operators for op taking densities in Y and returning densities in X.\ngreen_multiplier (keyword argument) is a vector with the same length as X storing the value of Œº(x) for x ‚àà X in the Green identity S\\[Œ≥‚ÇÅu\\](x) - D\\[Œ≥‚ÇÄu\\](x) + Œº*u(x) = 0. See _green_multiplier.\n\nOptional kwargs:\n\nparameters::DimParameters: parameters associated with the density interpolation method\nderivative: if true, compute the correction to the adjoint double-layer and hypersingular operators instead. In this case, S and D should be replaced by a (possibly innacurate) discretization of adjoint double-layer and hypersingular operators, respectively.\nmaxdist: distance beyond which interactions are considered sufficiently far so that no correction is needed. This is used to determine a threshold for nearly-singular corrections when X and Y are different surfaces. When X === Y, this is not needed.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.bean-Tuple{}","page":"Docstrings","title":"Inti.bean","text":"bean(; translation, rotation, scaling, labels)\n\nCreate a bean entity in 3D, and apply optional transformations. Returns the key.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.blocksize-Union{Tuple{Inti.BlockArray{T}}, Tuple{T}} where T","page":"Docstrings","title":"Inti.blocksize","text":"blocksize(A::BlockArray)\n\nThe size of an individual entry of A.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.boundary-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.boundary","text":"boundary(Œ©::Domain)\n\nReturn the external boundaries of a domain.\n\nSee also: external_boundary, internal_boundary, skeleton.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.boundary_idxs-Tuple{Inti.LagrangeElement{Inti.ReferenceHyperCube{1}}}","page":"Docstrings","title":"Inti.boundary_idxs","text":"boundary_idxs(el::LagrangeElement)\n\nThe indices of the nodes in el that define the boundary of the element.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.cart2sph-Tuple{Any, Any, Any}","page":"Docstrings","title":"Inti.cart2sph","text":"cart2sph(x,y,z)\n\nMap cartesian coordinates x,y,z to spherical ones r, Œ∏, œÜ representing the radius, elevation, and azimuthal angle respectively. The convention followed is that 0 ‚â§ Œ∏ ‚â§ œÄ and -œÄ < œÜ ‚â§ œÄ. Same as the cart2sph function in MATLAB.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.connectivity-Tuple{Inti.Mesh, DataType}","page":"Docstrings","title":"Inti.connectivity","text":"connectivity(msh::AbstractMesh,E::DataType)\n\nReturn the connectivity matrix for elements of type E in msh. The integer tags in the matrix refer to the points in nodes(msh)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.coords-Tuple{T} where T","page":"Docstrings","title":"Inti.coords","text":"coords(q)\n\nReturn the spatial coordinates of q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.cushion-Tuple{}","page":"Docstrings","title":"Inti.cushion","text":"cushion(; translation, rotation, scaling, labels)\n\nCreate a cushion entity in 3D, and apply optional transformations. Returns the key.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.dimension-Union{Tuple{Type{Inti.PolynomialSpace{D, K}}}, Tuple{K}, Tuple{D}} where {D, K}","page":"Docstrings","title":"Inti.dimension","text":"dimension(space)\n\nThe length of a basis for space; i.e. the number of linearly independent elements required to span space.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.dom2elt-Tuple{Inti.AbstractMesh, Inti.Domain, DataType}","page":"Docstrings","title":"Inti.dom2elt","text":"dom2elt(m::Mesh,Œ©,E)::Vector{Int}\n\nCompute the element indices idxs of the elements of type E composing Œ©.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.dom2qtags-Tuple{Inti.Quadrature, Inti.Domain}","page":"Docstrings","title":"Inti.dom2qtags","text":"dom2qtags(Q::Quadrature, dom::Domain)\n\nGiven a domain, return the indices of the quadratures nodes in Q associated to its quadrature.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.domain","page":"Docstrings","title":"Inti.domain","text":"domain(f)\n\nGiven a function-like object f: Œ© ‚Üí R, return Œ©.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.domain-Tuple{Inti.AbstractMesh}","page":"Docstrings","title":"Inti.domain","text":"domain(msh::AbstractMesh)\n\nReturn a [Domain] containing of all entities covered by the mesh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.domain-Tuple{Inti.Quadrature}","page":"Docstrings","title":"Inti.domain","text":"domain(Q::Quadrature)\n\nThe Domain over which Q performs integration.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.domain-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D","page":"Docstrings","title":"Inti.domain","text":"domain(q::ReferenceQuadrature)\n\nThe domain of integratino for quadrature rule q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.element_types","page":"Docstrings","title":"Inti.element_types","text":"element_types(msh::AbstractMesh)\n\nReturn the element types present in the msh.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.elements","page":"Docstrings","title":"Inti.elements","text":"elements(msh::AbstractMesh [, E::DataType])\n\nReturn the elements of a msh. Passing and element type E will restricts to elements of that type.\n\nA common pattern to avoid type-instabilies in performance critical parts of the code is to use a function barrier, as illustrated below:\n\nfor E in element_types(msh)\n    _long_computation(elements(msh, E), args...)\nend\n\n@noinline function _long_computation(iter, args...)\n    for el in iter # the type of el is known at compile time\n        # do something with el\n    end\nend\n\nwhere a dynamic dispatch is performed only on the element types (typically small for a given mesh).\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.ellipsoid-Tuple{}","page":"Docstrings","title":"Inti.ellipsoid","text":"ellipsoid(; translation, rotation, scaling, labels)\n\nCreate an ellipsoid entity in 3D, and apply optional transformations. Returns the key of the created entity.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.ent2etags-Tuple{Inti.Mesh}","page":"Docstrings","title":"Inti.ent2etags","text":"ent2etags(msh::AbstractMesh)\n\nReturn a dictionary mapping entities to a dictionary of element types to element tags.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.entities-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.entities","text":"entities(Œ©::Domain)\n\nReturn all entities making up a domain (as a set of EntityKeys).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.etype_to_nearest_points-Tuple{Any, Inti.Quadrature}","page":"Docstrings","title":"Inti.etype_to_nearest_points","text":"etype_to_nearest_points(X,Y::Quadrature; maxdist)\n\nFor each element el in Y.mesh, return a list with the indices of all points in X for which el is the nearest element. Ignore indices for which the distance exceeds maxdist.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.external_boundary-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.external_boundary","text":"external_boundary(Œ©::Domain)\n\nReturn the external boundaries inside a domain. These are entities in the skeleton of Œ© which are not in the internal boundaries of Œ©.\n\nSee also: internal_boundary, skeleton.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.fibonnaci_points_sphere-Tuple{Any, Any, Any}","page":"Docstrings","title":"Inti.fibonnaci_points_sphere","text":"fibonnaci_points_sphere(N,r,c)\n\nReturn N points distributed (roughly) in a uniform manner on the sphere of radius r centered at c.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.flip_normal-Tuple{Inti.QuadratureNode}","page":"Docstrings","title":"Inti.flip_normal","text":"flip_normal(q::QuadratureNode)\n\nReturn a new QuadratureNode with the normal vector flipped.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.gauss_curvature-Tuple{Inti.Quadrature}","page":"Docstrings","title":"Inti.gauss_curvature","text":"gauss_curvature(Q::Quadrature)\n\nCompute the gauss_curvature at each quadrature node in Q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.gauss_curvature-Tuple{Inti.ReferenceInterpolant, Any}","page":"Docstrings","title":"Inti.gauss_curvature","text":"gauss_curvature(œÑ, xÃÇ)\n\nCalculate the Gaussian curvature of the element œÑ at the parametric coordinate xÃÇ.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.geometric_dimension","page":"Docstrings","title":"Inti.geometric_dimension","text":"geometric_dimension(x)\n\nNNumber of degrees of freedom necessary to locally represent the geometrical object. For example, lines have geometric dimension of 1 (whether in ‚Ñù¬≤ or in ‚Ñù¬≥), while surfaces have geometric dimension of 2.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.global_get_entity-Tuple{Inti.EntityKey}","page":"Docstrings","title":"Inti.global_get_entity","text":"global_get_entity(k::EntityKey)\n\nRetrieve the GeometricEntity corresponding to the EntityKey k from the global ENTITIES dictionary.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.gmsh_curve-Tuple","page":"Docstrings","title":"Inti.gmsh_curve","text":"gmsh_curve(f::Function, a, b; npts=100, meshsize = 0, tag=-1)\n\nCreate a curve in the current gmsh model given by {f(t) : t ‚àà (a,b) } where f is a function from ‚Ñù to ‚Ñù^3. The curve is approximated by C¬≤ b-splines passing through npts equispaced in parameter space. If a meshsize is given, gmsh will use it when meshing the curve.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.hessian-Tuple{Inti.ReferenceInterpolant, Any}","page":"Docstrings","title":"Inti.hessian","text":"hessian(el,x)\n\nGiven a (possibly vector-valued) functor f : ùêë·µê ‚Üí ùêÖ‚Åø, return the n √ó m √ó m matrix A·µ¢‚±º‚±º = ‚àÇ¬≤f·µ¢/‚àÇx‚±º‚àÇx‚±º. By default ForwardDiff is used to compute the hessian, but you should overload this method for specific f if better performance and/or precision is required.\n\nNote: both x and f(x) are expected to be of SVector type.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.image","page":"Docstrings","title":"Inti.image","text":"image(f)\n\nGiven a function-like object f: Œ© ‚Üí R, return f(Œ©).\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.import_mesh-Tuple","page":"Docstrings","title":"Inti.import_mesh","text":"import_mesh(filename = nothing; dim=3)\n\nOpen filename and create a Mesh from the gmsh model in it.\n\nIf filename is nothing, the current gmsh model is used. Note that this assumes that the Gmsh API has been initialized through gmsh.initialize.\n\nPassing dim=2 will create a two-dimensional mesh by projecting the original mesh onto the x,y plane.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.integrate-Tuple{Any, Inti.Quadrature}","page":"Docstrings","title":"Inti.integrate","text":"integrate(f,quad::Quadrature)\n\nCompute ‚àë·µ¢ f(q·µ¢)w·µ¢, where the q·µ¢ are the quadrature nodes of quad, and w·µ¢ are the quadrature weights.\n\nNote that you must define f(::QuadratureNode): use q.coords and q.normal if you need to access the coordinate or normal vector at que quadrature node.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.integrate-Tuple{Any, Inti.ReferenceQuadrature}","page":"Docstrings","title":"Inti.integrate","text":"integrate(f,q::ReferenceQuadrature)\nintegrate(f,x,w)\n\nIntegrate the function f using the quadrature rule q. This is simply sum(f.(x) .* w), where x and w are the quadrature nodes and weights, respectively.\n\nThe function f should take an SVector as input.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.integrate_with_error_estimate","page":"Docstrings","title":"Inti.integrate_with_error_estimate","text":"integrate_with_error_estimate(f, quad::EmbeddedQuadrature, norm = LinearAlgebra.norm)\n\nReturn I, E where I is the estimated integral of f over domain(quad) using the high-order quadrature and E is the error estimate obtained by taking the norm of the difference between the high and low-order quadratures in quad.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.integration_measure-Tuple{Any, Any}","page":"Docstrings","title":"Inti.integration_measure","text":"integration_measure(f, xÃÇ)\n\nGiven the Jacobian matrix J of a transformation f : ‚Ñù·¥π ‚Üí ‚Ñù·¥∫ compute the integration measure ‚àödet(J·µÄJ) at the parametric coordinate xÃÇ\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.interface_method-Tuple{DataType}","page":"Docstrings","title":"Inti.interface_method","text":"interface_method(x)\n\nA method of an abstract type for which concrete subtypes are expected to provide an implementation.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.internal_boundary-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.internal_boundary","text":"internal_boundary(Œ©::Domain)\n\nReturn the internal boundaries of a Domain. These are entities in skeleton(Œ©) which appear at least twice as a boundary of entities in Œ©.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.interpolation_order-Tuple{Inti.ReferenceQuadrature{Inti.ReferenceHyperCube{1}}}","page":"Docstrings","title":"Inti.interpolation_order","text":"interpolation_order(qrule::ReferenceQuadrature)\n\nThe interpolation order of a quadrature rule is defined as the the smallest k such that there exists a polynomial (not necessarily unique) in PolynomialSpace{D,k} that interpolates the function f at the quadrature nodes.\n\nFor example, a triangle quadrature containing 3 nodes has an interpolation order of 1, but a triangle quadrature containing 4 nodes has an interpolation order of 2.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.jacobian-Tuple{Any, Any}","page":"Docstrings","title":"Inti.jacobian","text":"jacobian(f,x)\n\nGiven a (possibly vector-valued) functor f : ùêë·µê ‚Üí ùêÖ‚Åø, return the n √ó m matrix A·µ¢‚±º = ‚àÇf·µ¢/‚àÇx‚±º. By default ForwardDiff is used to compute the jacobian, but you should overload this method for specific f if better performance and/or precision is required.\n\nNote: both x and f(x) are expected to be of SVector type.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.kress_change_of_variables-Tuple{Any}","page":"Docstrings","title":"Inti.kress_change_of_variables","text":"kress_change_of_variables(P)\n\nReturn a change of variables mapping [0,1] to [0,1] with the property that the first P-1 derivatives of the transformation vanish at x=0.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.kress_change_of_variables_periodic-Tuple{Any}","page":"Docstrings","title":"Inti.kress_change_of_variables_periodic","text":"kress_change_of_variables_periodic(P)\n\nLike kress_change_of_variables, this change of variables maps the interval [0,1] onto itself, but the first P derivatives of the transformation vanish at both endpoints (thus making it a periodic function).\n\nThis change of variables can be used to periodize integrals over the interval [0,1] by mapping the integrand into a new integrand that vanishes (to order P) at both endpoints.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.lagrange_basis-Tuple{Any, Inti.PolynomialSpace}","page":"Docstrings","title":"Inti.lagrange_basis","text":"lagrange_basis(nodes,[sp::AbstractPolynomialSpace])\n\nReturn the set of n polynomials in sp taking the value of 1 on node i and 0 on nodes j ‚âÇÃ∏ i for 1 ‚â§ i ‚â§ n.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.lagrange_basis-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D","page":"Docstrings","title":"Inti.lagrange_basis","text":"lagrange_basis(qrule::ReferenceQuadrature)\n\nReturn a function L : ‚Ñù·¥∫ ‚Üí ‚Ñù·µñ where N is the dimension of the domain of qrule, and p is the number of nodes in qrule. The function L is a polynomial in polynomial_space(qrule), and L(x‚±º)[i] = Œ¥·µ¢‚±º (i.e. the ith component of L is the ith Lagrange basis).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.lagrange_basis-Union{Tuple{Type{Inti.LagrangeElement{D, N, T}}}, Tuple{T}, Tuple{N}, Tuple{D}} where {D, N, T}","page":"Docstrings","title":"Inti.lagrange_basis","text":"lagrange_basis(E::Type{<:LagrangeElement})\n\nReturn the Lagrange basis B for the element E. Evaluating B(x) yields the value of each basis function at x.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.laurent_coefficients-Tuple{Any, Any, Val{-2}}","page":"Docstrings","title":"Inti.laurent_coefficients","text":"laurent_coefficients(f, h, order) --> f‚Çã‚ÇÇ, f‚Çã‚ÇÅ, f‚ÇÄ\n\nGiven a one-dimensional function f, return f‚Çã‚ÇÇ, f‚Çã‚ÇÅ, f‚ÇÄ such that f(x) = f‚Çã‚ÇÇ / x^2 + f‚Çã‚ÇÅ / x + f‚ÇÄ + ùí™(x) as x -> 0, where we assume that f‚Çô = 0 for n < N.\n\nThe order argument is an integer that indicates the order of the singularity at the origin:\n\nVal{-2}: The function has a singularity of order -2 at the origin.\nVal{-1}: The function has a singularity of order -1 at the origin, so f‚Çã‚ÇÇ = 0.\nVal{0}: The function has a finite part at the origin, so f‚Çã‚ÇÇ = f‚Çã‚ÇÅ = 0.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.line-Tuple{Any, Any}","page":"Docstrings","title":"Inti.line","text":"line(a,b)\n\nCreate a [GeometricEntity] representing a straight line connecting points a and b. The points a and b can be either SVectors or a Tuple.\n\nThe parametrization of the line is given by f(u) = a + u(b - a), where 0 ‚â§ u ‚â§ 1.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.local_correction_dist_and_tol","page":"Docstrings","title":"Inti.local_correction_dist_and_tol","text":"local_correction_dist_and_tol(iop::IntegralOperator, kmax = 10, ratio = 8)\n\nTry to estimate resonable maxdist and rtol parameters for the adaptive_correction function, where maxdist is at most kmax times the radius of the largest element in the source mesh of iop. See the Extended help for more details.\n\nnote: Note\nThis is a heuristic and may not be accurate/efficient in all cases. It is recommended to test different values of maxdist and rtol to find the optimal values for your problem.\n\nExtended help\n\nThe heuristic works as follows, where we let K = kernel(iop) and msh = mesh(source(iop)):\n\nPick the largest element in msh\nLet h be the radius of el\nFor k between 1 and kmax, estimate the (relative) quadrature error when integrating y -> K(x,y) for x at a distance k * h from the center of the element using a regular quadrature rule\nFind a k such that ratio between errors at distances k * h and (k + 1) * h is below ratio. This indicates stagnation in the error, and suggests that little is gained by increasing the distance.\nReturn maxdist = k * h and rtol as the error at distance k * h.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.mean_curvature-Tuple{Inti.Quadrature}","page":"Docstrings","title":"Inti.mean_curvature","text":"mean_curvature(Q::Quadrature)\n\nCompute the mean_curvature at each quadrature node in Q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.mean_curvature-Tuple{Inti.ReferenceInterpolant, Any}","page":"Docstrings","title":"Inti.mean_curvature","text":"mean_curvature(œÑ, xÃÇ)\n\nCalculate the mean curvature of the element œÑ at the parametric coordinate xÃÇ.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.measure","page":"Docstrings","title":"Inti.measure","text":"measure(k::EntityKey, rtol)\n\nCompute the length/area/volume of the entity k using an adaptive quadrature with a relative tolerance rtol. Assumes that the entity has an explicit parametrization.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.meshgen!-Tuple{Inti.Mesh, Inti.Domain, Int64}","page":"Docstrings","title":"Inti.meshgen!","text":"meshgen!(mesh,Œ©,sz)\n\nSimilar to meshgen, but append entries to mesh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.meshgen-Tuple{Inti.Domain, Vararg{Any}}","page":"Docstrings","title":"Inti.meshgen","text":"meshgen(Œ©, n; T = Float64)\nmeshgen(Œ©, n_dict; T = Float64)\nmeshgen(Œ©; meshsize, T = Float64)\n\nGenerate a Mesh for the domain Œ© where each curve is meshed using n elements. Passing a dictionary allows for a finer control; in such cases, n_dict[ent] should return an integer for each entity ent in Œ© of geometric_dimension one.\n\nAlternatively, a meshsize can be passed, in which case, the number of elements is computed as so as to obtain an average mesh size of meshsize. Note that the actual mesh size may vary significantly for each element if the parametrization is far from uniform.\n\nThe mesh is created with primitive data of type T.\n\nThis function requires the entities forming Œ© to have an explicit parametrization.\n\nwarning: Mesh quality\nThe quality of the generated mesh created using meshgen depends on the quality of the underlying parametrization. For complex surfaces, you are better off using a proper mesher such as gmsh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.monomial_basis","page":"Docstrings","title":"Inti.monomial_basis","text":"monomial_basis(sp::PolynomialSpace)\n\nReturn a function f : ‚Ñù·¥∫ ‚Üí ‚Ñù·µà, where N is the dimension of the domain of sp     containing a basis of monomials ùê±·∂ø spanning the polynomial space PolynomialSpace.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.near_interaction_list-Union{Tuple{N}, Tuple{AbstractVector{<:StaticArraysCore.SVector{N}}, Inti.AbstractMesh{N}}} where N","page":"Docstrings","title":"Inti.near_interaction_list","text":"near_interaction_list(X,Y::AbstractMesh; tol)\n\nFor each element el of type E in Y, return the indices of the points in X which are closer than tol to the center of el.\n\nThis function returns a dictionary where e.g. dict[E][5] --> Vector{Int} gives the indices of points in X which are closer than tol to the center of the fifth element of type E.\n\nIf tol is a Dict, then tol[E] is the tolerance for elements of type E.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.new_tag-Tuple{Integer}","page":"Docstrings","title":"Inti.new_tag","text":"new_tag(dim)\n\nReturn a new tag for an entity of dimension dim so that EntityKey(dim, tag) is not already in ENTITIES.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.node_vals_to_quadrature-Tuple{Inti.Quadrature, AbstractVector}","page":"Docstrings","title":"Inti.node_vals_to_quadrature","text":"node_vals_to_quadrature(Q::Quadrature, vals::AbstractVector)\n\nGiven a vector of vals at the interpolation nodes of Q.mesh, return a vector of values at the quadrature nodes of Q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.nodes-Tuple{Inti.SubMesh}","page":"Docstrings","title":"Inti.nodes","text":"nodes(msh::SubMesh)\n\nA view of the nodes of the parent mesh belonging to the submesh. The ordering is given by the nodetags function.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.nodetags-Tuple{Inti.SubMesh}","page":"Docstrings","title":"Inti.nodetags","text":"nodetags(msh::SubMesh)\n\nReturn the tags of the nodes in the parent mesh belonging to the submesh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.normal-Tuple{Any, Any}","page":"Docstrings","title":"Inti.normal","text":"normal(el, xÃÇ)\n\nReturn the normal vector of el at the parametric coordinate xÃÇ.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.normal-Tuple{T} where T","page":"Docstrings","title":"Inti.normal","text":"normal(q)\n\nReturn the normal vector of q, if it exists.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.notimplemented-Tuple{}","page":"Docstrings","title":"Inti.notimplemented","text":"notimplemented()\n\nThings which should probably be implemented at some point.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.order-Union{Tuple{Inti.Fejer{N}}, Tuple{N}} where N","page":"Docstrings","title":"Inti.order","text":"order(q::ReferenceQuadrature)\n\nA quadrature of order p (sometimes called degree of precision) integrates all polynomials of degree ‚â§ p but not ‚â§ p + 1.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.order-Union{Tuple{Type{<:Inti.LagrangeElement{D, Np}}}, Tuple{Np}, Tuple{D}} where {D, Np}","page":"Docstrings","title":"Inti.order","text":"order(el::LagrangeElement)\n\nThe order of the element's interpolating polynomial (e.g. a LagrangeLine with 2 nodes defines a linear polynomial, and thus has order 1).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.orientation-Tuple{Inti.AbstractMesh, DataType}","page":"Docstrings","title":"Inti.orientation","text":"orientation(msh::AbstractMesh,E::DataType)\n\nReturn the orientation of the elements of type E in msh (1 if normal and -1 if inverted).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.parametric_curve-Union{Tuple{F}, Tuple{F, Real, Real}} where F","page":"Docstrings","title":"Inti.parametric_curve","text":"parametric_curve(f, a::Real, b::Real)\n\nCreate a [GeometricEntity] representing a parametric curve defined by the {f(t) | a ‚â§ t ‚â§ b}. The function f should map a scalar to an SVector.\n\nFlipping the orientation is supported by passing a > b.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.parametric_surface","page":"Docstrings","title":"Inti.parametric_surface","text":"    parametric_surface(f, lc, hc, boundary = nothing; kwargs...)\n\nCreate a parametric surface defined by the function f over the rectangular domain defined by the lower corner lc and the upper corner hc. The optional boundary argument can be used to specify the boundary curves of the surface.\n\nArguments\n\nf: A function that takes two arguments x and y and returns a tuple (u, v)   representing the parametric coordinates of the surface at (x, y).\nlc: A 2-element array representing the lower corner of the rectangular domain.\nhc: A 2-element array representing the upper corner of the rectangular domain.\nboundary: An optional array of boundary curves that define the surface.\n\nKeyword Arguments\n\nkwargs: Additional keyword arguments that can be passed to the GeometricEntity   constructor.\n\nReturns\n\nThe key of the created GeometricEntity.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.polar_decomposition-Tuple{Inti.ReferenceHyperCube{2}, StaticArraysCore.SVector{2, <:Number}}","page":"Docstrings","title":"Inti.polar_decomposition","text":"polar_decomposition(shape::ReferenceSquare, xÃÇ::SVector{2,Float64})\n\nDecompose the square [0,1] √ó [0,1] into four triangles, and return four tuples of the form Œ∏‚Çõ, Œ∏‚Çë, œÅ where Œ∏‚Çõ and Œ∏‚Çë are the initial and final angles of the triangle, and œÅ is the function that gives the distance from xÃÇ to the border of the square in the direction Œ∏.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.polar_decomposition-Tuple{Inti.ReferenceSimplex{2}, StaticArraysCore.SVector{2, <:Number}}","page":"Docstrings","title":"Inti.polar_decomposition","text":"polar_decomposition(shape::ReferenceTriangle, xÃÇ::SVector{2,Float64})\n\nDecompose the triangle {x,y ‚â• 0, x + y ‚â§ 1} into three triangles, and return three tuples of the form Œ∏‚Çõ, Œ∏‚Çë, œÅ where Œ∏‚Çõ and Œ∏‚Çë are the initial and final angles of the triangle, and œÅ is the function that gives the distance from xÃÇ to the border of the triangle in the direction Œ∏.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.polynomial_solutions_vdim","page":"Docstrings","title":"Inti.polynomial_solutions_vdim","text":"polynomial_solutions_vdim(op, order[, center])\n\nFor every monomial term p‚Çô of degree order, compute a polynomial P‚Çô such that ‚Ñí[P‚Çô] = p‚Çô, where ‚Ñí is the differential operator associated with op. This function returns {p‚Çô,P‚Çô,Œ≥‚ÇÅP‚Çô}, where Œ≥‚ÇÅP‚Çô is the generalized Neumann trace of P‚Çô.\n\nPassing a point center will shift the monomials and solutions accordingly.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.polynomial_space-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D","page":"Docstrings","title":"Inti.polynomial_space","text":"polynomial_space(qrule::ReferenceQuadrature)\n\nReturn a PolynomialSpace associated with the interpolation_order of the quadrature nodes of qrule.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.qcoords-Tuple{Inti.ReferenceQuadrature}","page":"Docstrings","title":"Inti.qcoords","text":"qcoords(q)\n\nReturn the coordinate of the quadrature nodes associated with q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.quadrature_to_node_vals-Tuple{Inti.Quadrature, AbstractVector}","page":"Docstrings","title":"Inti.quadrature_to_node_vals","text":"quadrature_to_node_vals(Q::Quadrature, qvals::AbstractVector)\n\nGiven a vector qvals of scalar values at the quadrature nodes of Q, return a vector ivals of scalar values at the interpolation nodes of Q.mesh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.qweights-Tuple{Inti.ReferenceQuadrature}","page":"Docstrings","title":"Inti.qweights","text":"qweights(q)\n\nReturn the quadrature weights associated with q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.reference_nodes-Tuple{Inti.LagrangeElement}","page":"Docstrings","title":"Inti.reference_nodes","text":"reference_nodes(el::LagrangeElement)\nreference_nodes(::Type{<:LagrangeElement})\n\nReturn the reference nodes on domain(el) used for the polynomial interpolation. The function values on these nodes completely determines the interpolating polynomial.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.return_type-Tuple{Any, Vararg{Any}}","page":"Docstrings","title":"Inti.return_type","text":"return_type(f[,args...])\n\nThe type returned by f(args...), where args is a tuple of types. Falls back to Base.promote_op by default.\n\nA functors of type T with a knonw return type should extend return_type(::T,args...) to avoid relying on promote_op.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.rotation_matrix-Tuple{Any}","page":"Docstrings","title":"Inti.rotation_matrix","text":"rotation_matrix(rot)\n\nConstructs a rotation matrix given the rotation angles around the x, y, and z axes.\n\nArguments\n\nrot: A tuple or vector containing the rotation angles in radians for each axis.\n\nReturns\n\nR::SMatrix: The resulting rotation matrix.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.single_double_layer-Tuple{}","page":"Docstrings","title":"Inti.single_double_layer","text":"single_double_layer(; op, target, source::Quadrature, compression,\ncorrection, derivative = false)\n\nConstruct a discrete approximation to the single- and double-layer integral operators for op, mapping values defined on the quadrature nodes of source to values defined on the nodes of target. If derivative = true, return instead the adjoint double-layer and hypersingular operators (which are the generalized Neumann trace of the single- and double-layer, respectively).\n\nFor finer control, you must choose a compression method and a correction method, as described below.\n\nCompression\n\nThe compression argument is a named tuple with a method field followed by method-specific fields. It specifies how the dense linear operators should be compressed. The available options are:\n\n(method = :none, ): no compression is performed, the resulting matrices are dense. This is the default, but not recommended for large problems.\n(method =:hmatrix, tol): the resulting operators are compressed using hierarchical matrices with an absolute tolerance tol (defaults to 1e-8).\n(method = :fmm, tol): the resulting operators are compressed using the fast multipole method with an absolute tolerance tol (defaults to 1e-8).\n\nCorrection\n\nThe correction argument is a named tuple with a method field followed by method-specific fields. It specifies how the singular and nearly-singular integrals should be computed. The available options are:\n\n(method = :none, ): no correction is performed. This is not recommended, as the resulting approximation will be inaccurate if the kernel is singular and source and target are not sufficiently far from each other.\n(method = :adaptive, maxdist, tol): correct interactions corresponding to entries of target and elements of source that are within maxdist of each other. The singular (including finite part) interactions are computed in polar coordinates, while the near-singular interactions are computed using an adaptive quadrature rule. The tol argument specifies the tolerance of the adaptive integration. See adaptive_correction for more details.\n(method = :dim, maxdist, target_location): use the density interpolation method to compute the correction. maxdist specifies the distance between source and target points above which no correction is performed (defaults to Inf). target_location should be either :inside, :outside, or :on, and specifies where the target points lie relative to the to the source curve/surface (which is assumed to be closed). When target === source, target_location is not needed. See bdim_correction and vdim_correction for more details.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.single_double_layer_potential-Tuple{}","page":"Docstrings","title":"Inti.single_double_layer_potential","text":"single_double_layer_potential(; op, source)\n\nReturn the single- and double-layer potentials for op as IntegralPotentials.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.singularity_order-Tuple{Any}","page":"Docstrings","title":"Inti.singularity_order","text":"singularity_order(K)\n\nGiven a kernel K with signature K(target,source)::T, return the order of the singularity of K at target = source. Order n means that K(x,y) ‚àº (x - y)^n as x -> y.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.skeleton-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.skeleton","text":"skeleton(Œ©::Domain)\n\nReturn all the boundaries of the domain, i.e. the domain's skeleton.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.stack_weakdeps_env!-Tuple{}","page":"Docstrings","title":"Inti.stack_weakdeps_env!","text":"stack_weakdeps_env!(; verbose = false, update = false)\n\nPush to the load stack an environment providing the weak dependencies of Inti.jl. This allows benefiting from additional functionalities of Inti.jl which are powered by weak dependencies without having to manually install them in your environment.\n\nSet update=true if you want to update the weakdeps environment.\n\nwarning: Warning\nCalling this function can take quite some time, especially the first time around, if packages have to be installed or precompiled. Run in verbose mode to see what is happening.\n\nExamples:\n\nInti.stack_weakdeps_env!()\nusing HMatrices\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.standard_basis_vector-Union{Tuple{N}, Tuple{Any, Val{N}}} where N","page":"Docstrings","title":"Inti.standard_basis_vector","text":"standard_basis_vector(k, ::Val{N})\n\nCreate an SVector of length N with a 1 in the kth position and zeros elsewhere.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.svector-Union{Tuple{F}, Tuple{F, Any}} where F","page":"Docstrings","title":"Inti.svector","text":"svector(f,n)\n\nCreate an SVector of length n, computing each element as f(i), where i is the index of the element.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.tensor_lagrange_interp-Union{Tuple{SKIP}, Tuple{dim}, Tuple{Td}, Tuple{N}, Tuple{StaticArraysCore.SVector{N, Td}, AbstractArray{<:Any, N}, NTuple{N, T} where T, NTuple{N, T} where T, Val{dim}, Any, Any}, Tuple{StaticArraysCore.SVector{N, Td}, AbstractArray{<:Any, N}, NTuple{N, T} where T, NTuple{N, T} where T, Val{dim}, Any, Any, Val{SKIP}}} where {N, Td, dim, SKIP}","page":"Docstrings","title":"Inti.tensor_lagrange_interp","text":"tensor_lagrange_interp(\n    x::SVector{N,Td},\n    vals::AbstractArray{<:Any,N},\n    nodes::NTuple{N},\n    weights::NTuple{N},\n    ::Val{dim},\n    i1,\n    len,\n    ::Val{SKIP} = Val(false)\n) where {N,Td,dim,SKIP}\n\nLow-level function performing tensor-product Lagrange interpolation of an N-dimensional function at the point x.\n\nArguments\n\nx::SVector{N,Td}: The point at which to interpolate, given as a static vector of length N.\nvals::AbstractArray{<:Any,N}: The array of function values at the interpolation nodes, with N dimensions.\nnodes::NTuple{N}: A tuple containing the interpolation nodes for each dimension.\nweights::NTuple{N}: A tuple containing the barycentric weights for each dimension.\n::Val{dim}: A type-level value indicating the current dimension for recursion.\ni1: The starting index for the current slice of vals.\nlen: The stride length for the current dimension.\n\nReturns\n\nThe interpolated value at the point x, of the same type as the elements of vals.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.torus-Tuple{}","page":"Docstrings","title":"Inti.torus","text":"torus(; r, R, translation, rotation, scaling, labels)\n\nCreate a torus entity in 3D, and apply optional transformations. Returns the key. The parameters r and R are the minor and major radii of the torus.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.uniform_points_circle-Tuple{Any, Any, Any}","page":"Docstrings","title":"Inti.uniform_points_circle","text":"uniform_points_circle(N,r,c)\n\nReturn N points uniformly distributed on a circle of radius r centered at c.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.vdim_correction-Union{Tuple{SHIFT}, Tuple{Any, Any, Inti.Quadrature, Inti.Quadrature, Any, Any, Any}} where SHIFT","page":"Docstrings","title":"Inti.vdim_correction","text":"vdim_correction(op,X,Y,Y_boundary,S,D,V; green_multiplier, kwargs...)\n\nCompute a correction to the volume potential V : Y ‚Üí X such that V + Œ¥V is a more accurate approximation of the underlying volume potential operator. The correction is computed using the (volume) density interpolation method.\n\nThis function requires a op::AbstractDifferentialOperator, a target set X, a source quadrature Y, a boundary quadrature Y_boundary, approximations S : Y_boundary -> X and D : Y_boundary -> X to the single- and double-layer potentials (correctly handling nearly-singular integrals), and a naive approximation of the volume potential V. The green_multiplier is a vector of the same length as X storing the value of Œº(x) for x ‚àà X in the Green identity (see _green_multiplier).\n\nSee [15] for more details on the method.\n\nOptional kwargs:\n\ninterpolation_order: the order of the polynomial interpolation. By default, the maximum order of the quadrature rules is used.\nmaxdist: distance beyond which interactions are considered sufficiently far so that no correction is needed. This is used to determine a threshold for nearly-singular corrections.\ncenter: the center of the basis functions. By default, the basis functions are centered at the origin.\nshift: a boolean indicating whether the basis functions should be shifted and rescaled to each element.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.vdim_mesh_center-Tuple{Inti.AbstractMesh}","page":"Docstrings","title":"Inti.vdim_mesh_center","text":"vdim_mesh_center(msh)\n\nPoint x which minimizes ‚àë (x-x‚±º)¬≤/r¬≤‚±º, where x‚±º and r‚±º are the circumcenter and circumradius of the elements of msh, respectively.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.vertices-Tuple{Inti.LagrangeElement}","page":"Docstrings","title":"Inti.vertices","text":"vertices(el::LagrangeElement)\n\nCoordinates of the vertices of el.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.vertices_idxs-Union{Tuple{Type{<:Inti.LagrangeElement{Inti.ReferenceHyperCube{1}, N}}}, Tuple{N}} where N","page":"Docstrings","title":"Inti.vertices_idxs","text":"vertices_idxs(el::LagrangeElement)\n\nThe indices of the nodes in el that define the vertices of the element.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.volume_potential-Tuple{}","page":"Docstrings","title":"Inti.volume_potential","text":"volume_potential(; op, target, source::Quadrature, compression, correction)\n\nCompute the volume potential operator for a given PDE.\n\nArguments\n\nop: The PDE (Partial Differential Equation) to solve.\ntarget: The target domain where the potential is computed.\nsource: The source domain where the potential is generated.\ncompression: The compression method to use for the potential operator.\ncorrection: The correction method to use for the potential operator.\n\nReturns\n\nThe volume potential operator V that represents the interaction between the target and source domains.\n\nCompression\n\nThe compression argument is a named tuple with a method field followed by method-specific fields. It specifies how the dense linear operators should be compressed. The available options are:\n\n(method = :none, ): no compression is performed, the resulting matrices are dense.\n(method =:hmatrix, tol): the resulting operators are compressed using hierarchical matrices with an absolute tolerance tol (defaults to 1e-8).\n(method = :fmm, tol): the resulting operators are compressed using the fast multipole method with an absolute tolerance tol (defaults to 1e-8).\n\nCorrection\n\nThe correction argument is a named tuple with a method field followed by method-specific fields. It specifies how the singular and nearly-singular integrals should be computed. The available options are:\n\n(method = :none, ): no correction is performed. This is not recommented, as the resulting approximation will be inaccurate if the source and target are not sufficiently far apart.\n(method = :dim, maxdist, target_location): use the density interpolation method to compute the correction. maxdist specifies the distance between source and target points above which no correction is performed (defaults to Inf). target_location should be either :inside, :outside, or :on, and specifies where the targetpoints lie relative to the to thesource's boundary. Whentarget === source,target_location` is not needed.\n\nDetails\n\nThe volume potential operator is computed by assembling the integral operator V using the single-layer kernel G. The operator V is then compressed using the specified compression method. If no compression is specified, the operator is returned as is. If a correction method is specified, the correction is computed and added to the compressed operator.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/compression_methods/#Compression-methods","page":"Compression methods","title":"Compression methods","text":"note: Important points covered in this tutorial\nOverview of the compression methods available in Inti.jl\nDetails and limitations of the various compression methods\nGuideline on how to choose a compression method\n\nInti.jl wraps several external libraries providing acceleration routines for integral operators. In general, acceleration routines have the signature assemble_*(iop, args...; kwargs...), and take an IntegralOperator as a first argument. They return a new object that represents a compressed version of the operator. The following methods are available:\n\nassemble_matrix: create a dense Matrix representation of the integral operator. Not really a compression method, but useful for debugging and small problems.\nassemble_hmatrix: assemble a hierarchical matrix representation of the operator using the HMatrices library.\nassemble_fmm: return a LinearMap object that represents the operator using the fast multipole method. This method is powered by the FMM2D, FMMLIB2D and FMM3D libraries, and is only available for certain kernels.\n\nwarning: Singular kernels\nAcceleration methods do not correct for singular or nearly-singular interactions. When the underlying kernel is singular, a correction is usually necessary in order to obtain accurate results (see the section on correction methods for more details).\n\nTo demonstrate the use of compression methods, we will compress the single-layer operator for the Helmholtz equation on an ellipsoid. While compression methods may not be necessary for small problems like this, they become essential ‚Äì and often indispensable ‚Äì for tackling larger-scale problems efficiently.\n\nusing Inti\nusing LinearAlgebra\n# define the quadrature\ngeo = Inti.GeometricEntity(\"ellipsoid\")\nŒ© = Inti.Domain(geo)\nŒì = Inti.boundary(Œ©)\nQ = Inti.Quadrature(Œì; meshsize = 0.4, qorder = 5)\n# create the operator\nop = Inti.Helmholtz(; dim = 3, k = 2œÄ)\nK = Inti.SingleLayerKernel(op)\nSop = Inti.IntegralOperator(K, Q, Q)\nx = rand(ComplexF64, length(Q))\nrtol = 1e-8\nnothing # hide\n\nIn what follows we compress Sop using the different methods available.","category":"section"},{"location":"tutorials/compression_methods/#Dense-matrix","page":"Compression methods","title":"Dense matrix","text":"Typically used for small problems, the dense matrix representation converts the IntegralOperator into a Matrix object. The underlying type of the Matrix is determined by the eltype of the IntegralOperator, and depends on the inferred type of the kernel. Here is how assemble_matrix can be used:\n\nSmat = Inti.assemble_matrix(Sop; threads=true)\n@assert Sop * x ‚âà Smat * x # hide\ner = norm(Sop * x - Smat * x, Inf) / norm(Sop * x, Inf)\nprintln(\"Forward map error: $er\")\n\nSince the returned object is plain Julia Matrix, it can be used with any of the linear algebra routines available in Julia (e.g. \\, lu, qr, *, etc.)","category":"section"},{"location":"tutorials/compression_methods/#Hierarchical-matrix","page":"Compression methods","title":"Hierarchical matrix","text":"The hierarchical matrix representation is a compressed representation of the underlying operator; as such, it takes a tolerance parameter that determines the relative error of the compression. Here is an example of how to use the assemble_hmatrix method to compress the previous problem:\n\nusing HMatrices\nShmat = Inti.assemble_hmatrix(Sop; rtol = 1e-8)\ner = norm(Smat * x - Shmat * x, Inf) / norm(Smat * x, Inf)\n@assert er < 10*rtol # hide\nprintln(\"Forward map error: $er\")\n\nNote that HMatrices are said to be kernel-independent, meaning that they efficiently compress a wide range of integral operators provided they satisfy a certain asymptotic smoothness criterion (see e.g. [4, 5]).\n\nThe HMatrix object can be used to solve linear systems, both iteratively through e.g. GMRES, or directly using an LU factorization.","category":"section"},{"location":"tutorials/compression_methods/#Fast-multipole-method","page":"Compression methods","title":"Fast multipole method","text":"The fast multipole method (FMM) is an acceleration technique based on an analytic multipole expansion of the kernel in the integral operator [6, 7]. It provides a very memory-efficient and fast way to evaluate certain types of integral operators. Here is how assemble_fmm can be used:\n\nusing FMM3D\nSfmm = Inti.assemble_fmm(Sop; rtol = 1e-8)\ner = norm(Sop * x - Sfmm * x, Inf) / norm(Sop * x, Inf)\n@assert er < 10*rtol # hide\nprintln(\"Forward map error: $er\")","category":"section"},{"location":"tutorials/compression_methods/#Tips-on-choosing-a-compression-method","page":"Compression methods","title":"Tips on choosing a compression method","text":"The choice of compression method depends on the problem at hand, as well as on the available hardware. Here is a rough guide on how to choose a compression:\n\nFor small problems (say less than 5k degrees of freedom), use the dense matrix representation. It is the simplest and most straightforward method, and does not require any additional packages. It is also the most accurate since it does not introduce any additional approximation errors.\nIf the integral operator is supported by the assemble_fmm, and if an iterative solver is acceptable, use it. The FMM is a very efficient method for certain types of kernels, and can handle problems with up to a few million degrees of freedom on a laptop.\nIf the kernel is not supported by assemble_fmm, if iterative solvers are not an option, or if the system needs solution for many right-hand sides, use the assemble_hmatrix method. It is a very general method that can handle a wide range of kernels, and although assembling the HMatrix can be time and memory consuming (the complexity is still log-linear in the DOFs for many kernels of interest, but the constants can be large), the resulting HMatrix object is very efficient to use. For example, the forward map is usually significantly faster than the one obtained through assemble_fmm.","category":"section"},{"location":"tutorials/compression_methods/#Inti.assemble_matrix-tutorials-compression_methods","page":"Compression methods","title":"Inti.assemble_matrix","text":"assemble_matrix(iop::IntegralOperator; threads = true)\n\nAssemble a dense matrix representation of an IntegralOperator.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/compression_methods/#Inti.assemble_hmatrix-tutorials-compression_methods","page":"Compression methods","title":"Inti.assemble_hmatrix","text":"assemble_hmatrix(iop[; atol, rank, rtol, eta])\n\nAssemble an H-matrix representation of the discretized integral operator iop using the HMatrices.jl library.\n\nSee the documentation of HMatrices for more details on usage and other keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/compression_methods/#Inti.assemble_fmm-tutorials-compression_methods","page":"Compression methods","title":"Inti.assemble_fmm","text":"assemble_fmm(iop; rtol)\n\nSet up a 2D or 3D FMM for evaluating the discretized integral operator iop associated with the op. In 2D the FMM2D or FMMLIB2D library is used (whichever was most recently loaded) while in 3D FMM3D is used.\n\nwarning: FMMLIB2D\nFMMLIB2D does no checking for if the targets and sources coincide, and will return Inf values if iop.target !== iop.source, but there is a point x ‚àà iop.target such that x ‚àà iop.source.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/correction_methods/#Correction-methods","page":"Correction methods","title":"Correction methods","text":"note: Important Points Covered in This Tutorial\nOverview of the correction methods available in Inti.jl.\nDetails and limitations of the various correction methods.\nGuidelines on how to choose a correction method.\n\nWhen the underlying kernel is singular, a correction is usually necessary to obtain accurate results in the approximation of the underlying integral operator by a quadrature. Currently, Inti.jl provides the following functions to correct for singularities:\n\nadaptive_correction\nbdim_correction\nvdim_correction\n\nEach method has its own strengths and weaknesses, which will be discussed in the following sections.\n\nnote: High-Level API\nThe single_double_layer, adj_double_layer_hypersingular, and volume_potential functions provide a high-level API with a correction keyword argument. This allows users to specify the correction method to use when constructing the integral operators. See the documentation of these functions for more details.","category":"section"},{"location":"tutorials/correction_methods/#Adaptive-Correction","page":"Correction methods","title":"Adaptive Correction","text":"The adaptive_correction method combines adaptive quadrature for nearly singular integrals with a direct evaluation method for singular integrals, based on [8]. It is a robust method suitable for a wide range of kernels, as long as the singularities are no worse than a Hadamard finite-part (e.g., 1r^3 in 3D and 1r^2 in 2D). This makes it a good default choice for most problems.","category":"section"},{"location":"tutorials/correction_methods/#Strengths","page":"Correction methods","title":"Strengths","text":"Robust method that works for a wide range of kernels.\nConceptually straightforward and easy to use.\nHandles open surfaces.","category":"section"},{"location":"tutorials/correction_methods/#Weaknesses","page":"Correction methods","title":"Weaknesses","text":"Can be slow for large problems and high accuracy requirements.\nSometimes difficult to tune parameters for optimal performance.\nRound-off errors in certain cases can make achieving high accuracy challenging.","category":"section"},{"location":"tutorials/correction_methods/#Docstrings","page":"Correction methods","title":"Docstrings","text":"","category":"section"},{"location":"tutorials/correction_methods/#Boundary-Density-Interpolation-Method","page":"Correction methods","title":"Boundary Density Interpolation Method","text":"The bdim_correction method implements the general-purpose version of the density interpolation method proposed in [9]. Is a global correction method that uses solutions of the underlying PDE, together with Green's identities, to interpolate the density on the boundary. It works best for low to moderate-order quadratures and is particularly useful for smooth boundaries when the PDE.","category":"section"},{"location":"tutorials/correction_methods/#Strengths-2","page":"Correction methods","title":"Strengths","text":"Can be faster and more accurate for standard problems, such as scattering by closed surfaces.\nEasier parameter tuning, as it only requires knowing whether the target surface is inside, outside, or on the boundary of the source.","category":"section"},{"location":"tutorials/correction_methods/#Weaknesses-2","page":"Correction methods","title":"Weaknesses","text":"Only suitable for closed surfaces.\nThe underlying kernel must be related to the fundamental solution of a PDE.","category":"section"},{"location":"tutorials/correction_methods/#Docstrings-2","page":"Correction methods","title":"Docstrings","text":"","category":"section"},{"location":"tutorials/correction_methods/#Volume-density-interpolation-method","page":"Correction methods","title":"Volume density interpolation method","text":"TODO","category":"section"},{"location":"tutorials/correction_methods/#Inti.adaptive_correction-tutorials-correction_methods","page":"Correction methods","title":"Inti.adaptive_correction","text":"adaptive_correction(iop::IntegralOperator; [maxdist, atol, rtol, threads = true, kwargs...])\nadaptive_correction(iop::IntegralOperator, maxdist, quads_dict::Dict, threads = true)\n\nThis function computes a sparse correction for the integral operator iop, addressing its singular or nearly singular entries.\n\nThe parameter maxdist specifies the maximum distance between target points and source elements to be considered for correction (only interactions within this distance are corrected).\n\nThe parameters atol and rtol define the absolute and relative tolerances for the adaptive quadrature used to compute the corrections for singular or nearly singular entries.\n\nAdditional kwargs arguments are passed to adaptive_quadrature; see its documentation for more information.\n\nSelecting maxdist and (atol,rtol) involves balancing accuracy and computational cost. A smaller maxdist reduces the number of corrections but may impact accuracy. Conversely, a smaller tolerance improves correction accuracy but increases computational expense. The ideal values depend on the kernel and the mesh/quadrature rule applied.\n\nBy default, maxdist and (atol,rtol) are estimated using the local_correction_dist_and_tol, but it is often possible to improve performance by manually tuning these parameters.\n\nAdvanced usage\n\nFor finer control, you can provide a dictionary quads_dict that contains quadrature rules for each reference element type present in the mesh of source(iop). This allows you to fine-tune the quadrature rules for specific element types (e.g. use a fixed quadrature rule instead of an adaptive one).\n\nThe dictionary quads_dict must adhere to the following structure:\n\nquads_dict[E].nearfield_quad: A function that integrates over the nearfield of the reference element type E. Used in the nearly-singular correction.\nquads_dict[E].radial_quad: A function that integrates over the radial direction of the reference element type E. Used in the singular correction.\nquads_dict[E].angular_quad: A function that integrates over the angular direction of the reference element type E. Used in the singular correction.\n\nHere is an example of how to implement a custom quads_dict given an iop:\n\nquads_dict = OrderedDict()\nmsh = Inti.mesh(source(iop))\nfor E in Inti.element_types(msh)\n    ref_domain = Inti.reference_domain(E)\n    quads = (\n        nearfield_quad = Inti.adaptive_quadrature(ref_domain; atol),\n        radial_quad    = Inti.GaussLegendre(;order=5),\n        angular_quad   = Inti.GaussLegendre(;order=20),\n    )\n    quads_dict[E] = quads\nend\n\nThis will use an adaptive quadrature rule for the nearfield and fixed Gauss-Legendre quadrature rules for the radial and angular directions when computing the singular correction in polar coordinates on the reference domain. You can then call adaptive_correction(iop, maxdist, quads_dict) to use the custom quadrature.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/correction_methods/#Inti.bdim_correction-tutorials-correction_methods","page":"Correction methods","title":"Inti.bdim_correction","text":"bdim_correction(op,X,Y,S,D; green_multiplier, kwargs...)\n\nGiven a op and a (possibly inaccurate) discretizations of its single and double-layer operators S and D (taking a vector of values on Y and returning a vector on of values on X), compute corrections Œ¥S and Œ¥D such that S + Œ¥S and D + Œ¥D are more accurate approximations of the underlying single- and double-layer integral operators.\n\nSee [9] for more details on the method.\n\nArguments\n\nRequired:\n\nop must be an AbstractDifferentialOperator\nY must be a Quadrature object of a closed surface\nX is either inside, outside, or on Y\nS and D are approximations to the single- and double-layer operators for op taking densities in Y and returning densities in X.\ngreen_multiplier (keyword argument) is a vector with the same length as X storing the value of Œº(x) for x ‚àà X in the Green identity S\\[Œ≥‚ÇÅu\\](x) - D\\[Œ≥‚ÇÄu\\](x) + Œº*u(x) = 0. See _green_multiplier.\n\nOptional kwargs:\n\nparameters::DimParameters: parameters associated with the density interpolation method\nderivative: if true, compute the correction to the adjoint double-layer and hypersingular operators instead. In this case, S and D should be replaced by a (possibly innacurate) discretization of adjoint double-layer and hypersingular operators, respectively.\nmaxdist: distance beyond which interactions are considered sufficiently far so that no correction is needed. This is used to determine a threshold for nearly-singular corrections when X and Y are different surfaces. When X === Y, this is not needed.\n\n\n\n\n\n","category":"function"},{"location":"examples/pep/#Plasmonic-Eigenvalue-Problem","page":"Plasmonic eigenvalues","title":"Plasmonic Eigenvalue Problem","text":"note: Important points covered in this example\nReformulate a transmission eigenvalue problem using integral equations\nImplement and solve the Neumann-Poincar√© eigenvalue problem\nUse a periodic Green's function to solve problems with periodic structures\nVisualize plasmonic eigenfunctions for different geometries","category":"section"},{"location":"examples/pep/#Problem-Definition","page":"Plasmonic eigenvalues","title":"Problem Definition","text":"Plasmonic resonances play a crucial role in nanophotonics, metamaterials, and sensing applications. At these resonances, the electromagnetic field becomes highly concentrated near material interfaces, leading to enhanced optical effects like extraordinary transmission, surface-enhanced Raman scattering, and localized heating. This tutorial demonstrates how to compute these resonances (in a much simplified context!) by solving the plasmonic eigenvalue problem using boundary integral methods. To keep things simple, we provide a brief and non-rigorous overview of the plasmonic eigenvalue problem; see e.g. [12] for a more detailed mathematical discussion and e.g. [13] for a detailed discussion on plasmonic resonances and their physical relevance.\n\nIn what follows we let Omega subset RR^2 be a bounded domain with smooth (e.g. C^2) boundary Gamma = partialOmega. We are interested in finding a non-zero function u  RR^2 to RR and a scalar kappa in (-infty 0) solving the following eigenvalue problem:\n\nbeginaligned\n    nabla cdot left(a(bx) nabla u right) = 0 quad a(bx) = begincases\n        1  textif  bx in Omega \n        kappa  textif  bx in Omega^c\n    endcases quad u(bx) undersetbxto infty= mathcalO(bx^-1)\n    \nendaligned\n\nSince the coefficient a(boldsymbolx) is piecewise constant, we can reformulate the problem in terms of the jump conditions across the boundary Gamma. More precisely, denoting by Omega^pm the exterior and interior of Omega, respectively, and u^pm the restriction of u to Omega^pm, we can rewrite the problem as:\n\nbeginaligned\nDelta u^pm = 0 quad textin  Omega^pm \nu^+ = u^- quad texton  Gamma\nkappa partial_nu u^+ = partial_nu u^- quad texton  Gamma \nendaligned\n\nwhere partial_nu denotes the normal derivative with respect to the outward normal on the boundary Gamma.\n\nTo solve this problem efficiently, we reformulate it as an integral equation using a single-layer potential ansatz:\n\nbeginaligned\n u(boldsymbolx) = int_Gamma G(boldsymbolxboldsymboly) sigma(boldsymboly)  textupd s(boldsymboly)\nendaligned\n\nwhere:\n\nG(boldsymbolxboldsymboly) is the Green's function for the Laplace equation\nsigma(boldsymboly) is an unknown density function defined on Gamma\n\nNote that this ansatz automatically satisfies Laplace's equation (Delta u = 0) in both Omega^+ and Omega^- by construction, so we only need to enforce the jump conditions on the boundary Gamma and possibly at infty. Using some properties of the single-layer potential (in particular, its continuity across the boundary and the jump in the normal derivative), we can derive the following boundary integral equation:\n\nbeginaligned\n    left( K^star sigma right)(boldsymbolx) = lambda sigma(boldsymbolx) quad textfor  boldsymbolx in Gamma\nendaligned\n\nwhere K^star is the adjoint single-layer operator defined as:\n\nbeginaligned\n    K^star sigma(boldsymbolx) = int_Gamma partial_nu(bx) G(boldsymbolxboldsymboly)  sigma(boldsymboly)  textupd s(boldsymboly)\nendaligned\n\nFor the condition at infinity, it can be shown that the single-layer representation satisfies the decay condition at infinity if the density sigma has zero mean over the boundary Gamma, which is the case if lambda neq -12 [14, Lemma 29]. We thus have an equivalence between the original plasmonic eigenvalue problem and the Neumann-Poincar√© eigenvalue problem (PEP), where lambda is related to the original parameter kappa by the transformation:\n\nkappa = frac2 lambda + 12 lambda - 1\n\nNext, we focus on the numerical discretization of the Neumann-Poincar√© operator K^star using Inti's boundary integral methods.\n\nnote: Rigorous formulation\nTo keep the discussion simple, we have chosen to avoid the details of the appropriate function spaces and precise regularity conditions. A rigorous treatment is beyond the scope of this tutorial, but details can be found in the literature. Note that the two-dimensional case is somewhat special [12, S 24].","category":"section"},{"location":"examples/pep/#Numerical-Implementation","page":"Plasmonic eigenvalues","title":"Numerical Implementation","text":"Now, let's implement a numerical solution to this problem. We'll create a function that:\n\nTakes a curve Gamma and discretization parameters\nAssembles a matrix representation of the K^star operator\nComputes its eigenvalues and eigenfunctions\nReturns the results as eigenvalue-eigenfunction pairs\n\nBecause later we will also consider periodic structures, we will allow the user to specify a period for the Green's function. If no period is specified, we will use the free-space Green's function.\n\nusing Inti\nusing StaticArrays\nusing LinearAlgebra\nusing GLMakie\n\nfunction npep(Œì; meshsize, qorder, period = Inf)\n    # Step 1: Discretize the curve Œì with a composite quadrature rule\n    Q = Inti.Quadrature(Œì; meshsize, qorder)\n    \n    # Step 2: Choose the appropriate Green's function (periodic or standard)\n    op = if isfinite(period)\n        Inti.LaplacePeriodic1D(; dim=2, period) # Periodic Green's function\n    else\n        Inti.Laplace(; dim=2)                   # Standard Green's function\n    end\n    \n    # Step 3: Create the Neumann-Poincar√© integral operator\n    kernel = Inti.AdjointDoubleLayerKernel(op)\n    Kop    = Inti.IntegralOperator(kernel, Q, Q)\n    \n    # Step 4: Assemble the matrix and correct for singular/nearly-singular entries\n    K‚ÇÄ = Inti.assemble_matrix(Kop)         # Basic assembly\n    Œ¥K = Inti.adaptive_correction(Kop)     # Correction for singular integrals\n    K  = K‚ÇÄ + Œ¥K                           # Final operator matrix\n    \n    # Step 5: Compute eigendecomposition\n    F  = eigen(K)\n    Œª·µ¢ = F.values # Eigenvalues\n    \n    # Step 6: Construct eigenfunction evaluators from eigenvectors\n    u·µ¢ = map(eachcol(F.vectors)) do v\n        # Create a function that evaluates the single-layer potential with density v\n        return Inti.SingleLayerPotential(op, Q)[real(v) / norm(v, Inf)]\n    end\n    \n    return Œª·µ¢, u·µ¢\nend\n\nLet's break down what's happening here:\n\nWe first create a quadrature rule on our curve Gamma with specified mesh size and quadrature order\nWe select the appropriate Green's function (standard or periodic)\nWe create the adjoint double-layer kernel and the corresponding integral operator\nWe assemble a matrix representation of the operator and apply necessary corrections for singular integrals\nWe compute the eigendecomposition of this matrix\nFor each eigenvector, we create a function that evaluates the corresponding eigenfunction at any point\n\nNext, we can test our implementation on a simple case of an ellipse, where we know the analytical eigenvalues and eigenfunctions. This will allow us to validate our numerical results.","category":"section"},{"location":"examples/pep/#Validation:-Elliptical-Domain","page":"Plasmonic eigenvalues","title":"Validation: Elliptical Domain","text":"For an elliptical domain, we can compare our numerical results with the analytical solution. The eigenvalues of the Neumann-Poincar√© operator for an ellipse are known explicitly.\n\n# Define an ellipse with semi-axes 2.5 and 1\nœá = (s) -> SVector(2.5 * cos(s), sin(s))\nŒì = Inti.parametric_curve(œá, 0, 2œÄ) |> Inti.Domain\n\n# Compute exact eigenvalues\nr = 1 / 2.5  # Ratio of semi-minor to semi-major axis\nnmax = 10\nŒª = [sign(n) / 2 * exp(-2 * abs(n) * atanh(r)) for n in -nmax:nmax]\n\n# Compute numerical eigenvalues and eigenfunctions\nŒª·µ¢, u·µ¢ = npep(Œì; meshsize = 0.1, qorder = 4)\n\n# Visualize the eigenvalues\nfig = Figure(size = (600, 250))\nax = Axis(\n    fig[1, 1];\n    title = \"Eigenvalues of the Neumann-Poincar√© Operator for an Ellipse\",\n    xlabel = \"Re(Œª)\",\n    ylabel = \"Im(Œª)\",\n    limits = (-0.5, 0.5, -0.1, 0.1),\n)\nscatter!(\n    ax,\n    real(Œª),\n    imag(Œª);\n    label = \"Analytical\",\n    color = :gray,\n    markersize = 20,\n    marker = :rect,\n    alpha = 0.6,\n)\nscatter!(\n    ax,\n    real(Œª·µ¢),\n    imag(Œª·µ¢);\n    label = \"Numerical\",\n    color = :blue,\n    markersize = 14,\n    marker = :cross,\n)\naxislegend(ax)\nfig # hide\n\nThe excellent agreement between the analytical and numerical eigenvalues confirms the accuracy of our implementation. The eigenvalue at lambda = -12 corresponds to constant functions, which are not plasmonic modes since they do not satisfy the decay condition at infinity, but are still part of the spectrum of the Neumann-Poincar√© operator.\n\nLet's visualize an eigenfunction to better understand the physical nature of these resonances. Each eigenfunction corresponds to a specific plasmonic mode.\n\nfig = Figure(size = (500, 400))\nn = 8 # Choose which eigenvalue/eigenfunction to visualize\nax = Axis(\n    fig[1, 1];\n    title = \"Eigenfunction with Œª ‚âà $(trunc(real(Œª·µ¢[n]), sigdigits = 2))\",\n    xlabel = \"x\",\n    ylabel = \"y\",\n    aspect = DataAspect(),\n)\n\n# Define a function to evaluate the eigenfunction on a grid\nfun = (x, y) -> real(u·µ¢[n](SVector(x, y)))\n\n# Create a grid for visualization\nl = 4\nxx = yy = range(-l, l, 100)\n\n# Plot the eigenfunction as a heatmap\nhm = heatmap!(ax, xx, yy, fun; colormap = :viridis, interpolate = true)\n\n# Draw the boundary curve\ns = range(0, 2œÄ, 100)\nlines!(ax, getindex.(œá.(s), 1), getindex.(œá.(s), 2); color = :black, linewidth = 2, label = \"Œì\")\n\n# Add a colorbar\nColorbar(fig[1, 2], hm)\n\nfig # hide\n\nAs can be seen in the plot, the eigenfunctions are localized near the boundary, which is a typical feature of plasmonic modes. Changing the eigenvalue index n will show different modes.","category":"section"},{"location":"examples/pep/#Exploring-Different-Geometries","page":"Plasmonic eigenvalues","title":"Exploring Different Geometries","text":"Having validated our implementation on a simple elliptical domain, we can now explore more complex geometries. The boundary integral approach is particularly powerful because it allows us to complex domains without needing to mesh the interior/exterior. In the next example we consider a kite-shaped domain.\n\n# Define a kite-shaped curve\nœá = (s) -> SVector(cos(s[1]) + 0.65 * cos(2 * s[1]) - 0.65, 1.5 * sin(s[1]))\nŒì = Inti.parametric_curve(œá, 0, 2œÄ) |> Inti.Domain\n\n# Compute eigenvalues and eigenfunctions\nŒª·µ¢, u·µ¢ = npep(Œì; meshsize = 0.1, qorder = 4)\n\n# Visualize an eigenfunction\nfig = Figure(size = (500, 400))\nn = 8 # Choose which eigenfunction to visualize\nax = Axis(\n    fig[1, 1];\n    title = \"Eigenfunction with Œª ‚âà $(trunc(real(Œª·µ¢[n]), sigdigits = 2))\",\n    xlabel = \"x\",\n    ylabel = \"y\",\n    aspect = DataAspect(),\n)\n\n# Define a function to evaluate the eigenfunction on a grid\nfun = (x, y) -> real(u·µ¢[n](SVector(x, y)))\n\n# Create a grid for visualization\nl = 4\nxx = yy = range(-l, l, 100)\n\n# Plot the eigenfunction as a heatmap\nhm = heatmap!(ax, xx, yy, fun; colormap = :viridis, interpolate = true)\n\n# Draw the boundary curve\ns = range(0, 2œÄ, 100)\nlines!(ax, getindex.(œá.(s), 1), getindex.(œá.(s), 2); color = :black, linewidth = 2, label = \"Œì\")\n\n# Add a colorbar\nColorbar(fig[1, 2], hm)\n\nfig\n\nNotice how the eigenfunction adapts to the geometry of the domain, and as before we observe a strong localization of the field near the interface Gamma.","category":"section"},{"location":"examples/pep/#Periodic-Structures","page":"Plasmonic eigenvalues","title":"Periodic Structures","text":"Many applications in nanophotonics involve periodic structures, such as diffraction gratings or metamaterials. We can extend our approach to handle periodic problems by using a periodic Green's function. In the periodic case, the problem is posed on -ell2 ell2 times mathbbR instead of mathbbR^2, where ell is the period, and u must satisfy periodic boundary conditions in the first coordinate.\n\nAlmost everything we have done so far can be adapted to this case, provided a periodic Green's function is used. The periodic Green's function for the Laplace equation in 2D is given by (see these lecture notes):\n\nG_p(bx by) = frac-14pi logleft(sin^2left( fracpi(x_1 - y_1)ellright) + sinh^2left( fracpi(x_2 - y_2)ellright)right)\n\nwhere ell is the period in the x-direction.\n\nOur implementation already supports this case‚Äîwe just need to specify a finite period:\n\n# Specify the period\nperiod = 4\n\n# Compute eigenvalues and eigenfunctions for the periodic problem\nŒª·µ¢, u·µ¢ = npep(Œì; meshsize = 0.1, qorder = 4, period)\n\n# Visualize an eigenfunction\nfig = Figure(size = (500, 400))\nn = 7 # Choose an eigenvalue to visualize\nax = Axis(\n    fig[1, 1];\n    title = \"Periodic Eigenfunction with Œª ‚âà $(trunc(real(Œª·µ¢[n]), sigdigits = 2))\",\n    xlabel = \"x\",\n    ylabel = \"y\",\n    aspect = DataAspect(),\n)\n\n# Define a function to evaluate the eigenfunction on a grid\nfun = (x, y) -> real(u·µ¢[n](SVector(x, y)))\n\n# Create a larger grid to show periodicity\nl = 1.5*period\nxx = yy = range(-l, l, 100)\n\n# Plot the eigenfunction as a heatmap\nhm = heatmap!(ax, xx, yy, fun; colormap = :viridis, interpolate = true)\n\n# Draw the boundary curves for the central and neighboring cells\ns = range(0, 2œÄ, 100)\nlines!(ax, getindex.(œá.(s), 1), getindex.(œá.(s), 2); color = :black, linewidth = 2)\nlines!(ax, getindex.(œá.(s), 1) .+ period, getindex.(œá.(s), 2); color = :black, linewidth = 2)\nlines!(ax, getindex.(œá.(s), 1) .- period, getindex.(œá.(s), 2); color = :black, linewidth = 2)\n\n# Draw the cell boundaries\nvlines!(ax, [-period/2, period/2], color = :black, linewidth = 2, linestyle = :dash)\n\n# Add a colorbar\nColorbar(fig[1, 2], hm)\n\nfig\n\nThis plot shows the eigenfunction for a periodic array of kite-shaped inclusions (only three cells are shown). Notice how the solution repeats with period ell in the x-direction. The dashed lines indicate the boundaries of the unit cell.","category":"section"},{"location":"examples/pep/#Three-dimensional-Problems","page":"Plasmonic eigenvalues","title":"Three-dimensional Problems","text":"Plasmonic eigenvalue problems are not limited to two dimensions. In three dimensions, many of the physical and mathematical principles are similar, but the computational complexity increase. The boundary integral approach remains highly effective, as it avoids volumetric meshing and naturally incorporates the radiation condition at infinity.\n\nThe following example demonstrates how to compute and visualize plasmonic eigenmodes for a toroidal inclusion. Unlike the two-dimensional case, we avoid assembling the full (dense) matrix, and use instead a fast multipole method (FMM) to compute the action of the operator on a vector. We then use a Krylov based eigensolver to compute a few of the eigenvalues, instead of the full eigendecomposition. This is particularly important as the size of the problem grows.\n\nusing FMM3D, KrylovKit\nŒ© = Inti.torus() |> Inti.Domain\nŒì = Inti.boundary(Œ©)\nQ = Inti.Quadrature(Œì; meshsize = 0.1, qorder = 4)\nop = Inti.Laplace(; dim = 3)\nkernel = Inti.AdjointDoubleLayerKernel(op)\nKop = Inti.IntegralOperator(kernel, Q, Q)\nK‚ÇÄ = Inti.assemble_fmm(Kop; rtol = 1e-4)\nŒ¥K = Inti.adaptive_correction(Kop) # Correction for singular integrals\nK = K‚ÇÄ + Œ¥K # Final operator matrix\nŒª·µ¢, v·µ¢, info = eigsolve(K, rand(size(K, 1)), 10)\n@assert norm(imag(Œª·µ¢), Inf) < 1e-6 # hide\n@assert all(real(Œª·µ¢) .> -0.6) # hide\ninfo\n\nNotice that only the matrix-vector product is required by eigsolve, and the info object above displays the convergence information. Here is what the few computed eigenvalues look like:\n\nscatter(\n    real(Œª·µ¢),\n    imag(Œª·µ¢);\n    markersize = 10,\n    marker = :cross,\n    color = :blue,\n    label = \"Eigenvalues\",\n)\n\nFinally, we can visualize one of the eigenfunctions by evaluating our single-layer ansatz on a points inside the volume. Since there are many target points, we will again use the fast multipole method to compute the action of the operator on the eigenfunction. The visualization will be done on a 3D volume slices using Makie.\n\nusing Meshes # to visualize the mesh using `viz!`\nv‚Çô = v·µ¢[8]\npts_per_dim = 100\nxx = yy = zz = range(-2,2,pts_per_dim)\ntargets = [SVector(x, y, z) for x in xx, y in yy, z in zz] |> vec\nKpot = Inti.IntegralOperator(Inti.SingleLayerKernel(op), targets, Q)\nKpot_fmm = Inti.assemble_fmm(Kpot; rtol = 1e-4)\nu‚Çô = Kpot_fmm * real(v‚Çô)\nfig = Figure()\nax = Axis3(fig[1, 1]; aspect = :data, elevation = œÄ/6, azimuth = œÄ/3,\n           title = \"Eigenfunction with Œª ‚âà $(trunc(real(Œª·µ¢[n]), sigdigits = 2))\")\nhidedecorations!(ax)\nplt = volumeslices!(ax, xx, yy, zz, reshape(u‚Çô,pts_per_dim,pts_per_dim,pts_per_dim); interpolate = true)\nplt[:update_yz][](pts_per_dim √∑ 2)\nplt[:update_xz][](pts_per_dim √∑ 2)\nplt[:update_xy][](length(zz) √∑ 2)\nviz!(Inti.mesh(Q); showsegments = true, color = :lightgray, alpha = 0.5)\ncurrent_figure() # hide\n\nAs before, the eigenfunction is localized near the boundary of the toroidal inclusion, which is a characteristic feature of plasmonic modes.","category":"section"},{"location":"examples/pep/#Further-generalizations","page":"Plasmonic eigenvalues","title":"Further generalizations","text":"Some interesting generalizations are described next. If you are interested in any of these, feel free to open a draft PR to discuss the implementation details!","category":"section"},{"location":"examples/pep/#Multiple-inclusions","page":"Plasmonic eigenvalues","title":"Multiple inclusions","text":"The approach can be extended to handle multiple inclusions (disconnected domains). In this case, the boundary Gamma would consist of multiple closed curves, and the quadrature would need to be defined on each component. This presents no fundamental challenges, and is simply a matter of defining a more complex domain. As long as the inclusions are smooth, everything should work as expected.","category":"section"},{"location":"examples/pep/#Helmholtz-equation","page":"Plasmonic eigenvalues","title":"Helmholtz equation","text":"The eigenvalue problem can be stated for the Helmholtz equation as well, where a different wavenumber is used in the exterior and interior domains (and their dependency on the spectral parameter must be specified through a model). Reformulating the problem in terms of boundary integral equations is still possible, but becomes more involved. \n\nFurthermore, when the domain is composed of periodic structures, the solution u is usually quasi-periodic, and the computation of quasi-periodic Green's functions requires more involved techniques.","category":"section"},{"location":"examples/pep/#Domains-with-Corners","page":"Plasmonic eigenvalues","title":"Domains with Corners","text":"For domains with corners, the solutions can exhibit singular behavior near the corners, and the Neumann-Poincar√© operator loses its compactness, introducing a continuous spectrum. Although there are ways to handle this situation, they all require a somewhat intricate analysis of the corners. See this repository for one possible method, based on complex scaling, implemented using Inti.","category":"section"},{"location":"examples/pep/#Conclusion","page":"Plasmonic eigenvalues","title":"Conclusion","text":"In this tutorial, we've demonstrated how to:\n\nFormulate the plasmonic eigenvalue problem in terms of boundary integral equations\nImplement a numerical solver using the Neumann-Poincar√© operator\nCompute and visualize eigenfunctions for different geometries\nExtend the approach to periodic structures\n\nThe boundary integral approach offers good accuracy and efficiency, especially for problems with smooth boundaries. It naturally handles the unbounded domain and radiation conditions, making it ideal for scattering and resonance problems.","category":"section"},{"location":"tutorials/geo_and_meshes/#Geometry-and-meshes","page":"Geometry and meshes","title":"Geometry and meshes","text":"note: Important points covered in this tutorial\nCombine simple shapes to create domains\nImport a mesh from a file\nIterative over mesh elements\n\nIn the getting started tutorial, we saw how to solve a simple Helmholtz scattering problem in 2D. We will now dig deeper into how to create and manipulate more complex geometrical shapes, as well the associated meshes.","category":"section"},{"location":"tutorials/geo_and_meshes/#Overview","page":"Geometry and meshes","title":"Overview","text":"Inti.jl provides a flexible way to define geometrical entities and their associated meshes. Simply put, the GeometricEntity type is the atomic building block of geometries: they can represent points, curves, surfaces, or volumes. Geometrical entities of the same dimension can be combined to form Domain, and domains can be manipulated using basic set operations such union and intersection. Meshes on the other hand are collections of (simple) elements that approximate the geometrical entities. A mesh element is a just a function that maps points from a ReferenceShape to the physical space.\n\nIn most applications involving complex three-dimensional surfaces, an external meshing software is used to generate a mesh, and the mesh is imported using the import_mesh function (which relies on Gmsh). The entities can then be extracted from the mesh based on e.g. their dimension or label. Here is an example of how to import a mesh from a file:\n\nusing Inti\nusing Gmsh \nusing LinearAlgebra\nfilename = joinpath(Inti.PROJECT_ROOT,\"docs\", \"assets\", \"piece.msh\")\nmsh = Inti.import_mesh(filename)\n\nThe imported mesh contains elements of several types, used to represent the segments, triangles, and tetras used to approximate the geometry:\n\nInti.element_types(msh)\n\nNote that the msh object contains all entities used to construct the mesh, usually defined in a .geo file, which can be extracted using the entities:\n\nents = Inti.entities(msh)\nnothing # hide\n\nFiltering of entities satisfying a certain condition, e.g., entities of a given dimension or containing a certain label, can also be performed in order to construct a domain:\n\nfilter = e -> Inti.geometric_dimension(e) == 3\nŒ© = Inti.Domain(filter, ents)\n\nDomains can be used to index the mesh, creating either a new object containing only the necessary elements:\n\nŒì = Inti.boundary(Œ©)\nmsh[Œì]\n\nor a SubMesh containing a view of the mesh:\n\nŒì_msh = view(msh, Œì)\n\nFinally, we can visualize the mesh using:\n\nusing Meshes, GLMakie\nfig = Figure(; size = (800,400))\nax = Axis3(fig[1, 1]; aspect = :data)\nviz!(Œì_msh; showsegments = true, alpha = 0.5)\nfig\n\nwarning: Mesh visualization\nNote that although the mesh may be of high order and/or conforming, the visualization of a mesh is always performed on the underlying first order mesh, and therefore elements may look flat even if the problem is solved on a curved mesh.","category":"section"},{"location":"tutorials/geo_and_meshes/#Parametric-entities-and-meshgen","page":"Geometry and meshes","title":"Parametric entities and meshgen","text":"In the previous section we saw an example of how to import a mesh from a file, and how to extract the entities from the mesh. For simple geometries for which an explicit parametrization is available, Inti.jl provides a way to create and manipulate geometrical entities and their associated meshes.","category":"section"},{"location":"tutorials/geo_and_meshes/#Parametric-curves","page":"Geometry and meshes","title":"Parametric curves","text":"The simplest parametric shapes are parametric_curves, which are defined by a function that maps a scalar parameter t to a point in 2D or 3D space. Parametric curves are expected to return an SVector, and can be created as follows:\n\nusing StaticArrays\nl1 = Inti.parametric_curve(x->SVector(x, 0.1 * sin(2œÄ * x)), 0.0, 1.0, labels = [\"l‚ÇÅ\"])\n\nThe object l1 represents a GeometricEntity with a known push-forward map:\n\nInti.pushforward(l1)\n\nFor the sake of this example, let's create three more curves, and group them together to form a Domain:\n\nl2 = Inti.parametric_curve(x->SVector(1 + 0.1 * sin(2œÄ * x), x), 0.0, 1.0, labels = [\"l‚ÇÇ\"])\nl3 = Inti.parametric_curve(x->SVector(1 - x, 1 - 0.1 * sin(2œÄ * x)), 0.0, 1.0, labels = [\"l‚ÇÉ\"])\nl4 = Inti.parametric_curve(x->SVector(0.1 * sin(2œÄ * x), 1 - x), 0.0, 1.0, labels = [\"l‚ÇÑ\"])\nŒì  = l1 ‚à™ l2 ‚à™ l3 ‚à™ l4\n\nDomains for which a parametric representation is available can be passed to the meshgen function:\n\nmsh = Inti.meshgen(Œì; meshsize = 0.05)\nnothing # hide\n\nWe can use the Meshes.viz function to visualize the mesh, and use domains to index the mesh:\n\nŒì‚ÇÅ = l1 ‚à™ l3\nŒì‚ÇÇ = l2 ‚à™ l4\nfig, ax, pl = viz(view(msh, Œì‚ÇÅ); segmentsize = 4,  label = \"Œì‚ÇÅ\")\nviz!(view(msh, Œì‚ÇÇ); segmentsize = 4, color = :red, label = \"Œì‚ÇÇ\")\nfig # hide\n\nNote that the orientation of the curve determines the direction of the normal vector. The normal points to the right of the curve when moving in the direction of increasing parameter t:\n\npts, tangents, normals = Makie.Point2f[], Makie.Vec2f[], Makie.Vec2f[]\nfor l in [l1, l2, l3, l4]\n      push!(pts, l(0.5)) # mid-point of the curve \n      push!(tangents, vec(Inti.jacobian(l, 0.5)))\n      push!(normals,Inti.normal(l, 0.5))\nend\narrows2d!(pts, tangents, color = :blue, shaftwidth = 2, lengthscale = 1/4, label = \"tangent\")\narrows2d!(pts, normals, color = :black, shaftwidth = 2, lengthscale = 1/4, label = \"normal\")\naxislegend()\nfig # hide","category":"section"},{"location":"tutorials/geo_and_meshes/#Parametric-surfaces","page":"Geometry and meshes","title":"Parametric surfaces","text":"Like parametric curves, parametric surfaces are defined by a function that maps a reference domain D subset mathbbR^2 to a surface in 3D space. They can be constructed using the parametric_surface function:\n\n# a patch of the unit sphere\nlc = SVector(-1.0, -1.0)\nhc = SVector(1.0, 1.0)\nf = (u,v) -> begin\n      x = SVector(1.0, u, v)   # a face of the cube\n      x ./ sqrt(u^2 + v^2 + 1) # project to the sphere\nend\npatch = Inti.parametric_surface(f, lc, hc, labels = [\"patch1\"])\nŒì  = Inti.Domain(patch)\nmsh = Inti.meshgen(Œì; meshsize = 0.1)\nviz(msh[Œì]; showsegments = true, figure = (; size = (400,400),))\n\nSince creating parametric surfaces that form a closed volume can be a bit more involved, Inti.jl provide a few helper functions to create simple shapes:\n\nfig = Figure(; size = (600,400))\nnshapes = Inti.length(Inti.PREDEFINED_SHAPES)\nncols = 3; nrows = ceil(Int, nshapes/ncols)\nfor (n,shape) in enumerate(Inti.PREDEFINED_SHAPES)\n      Œ© = Inti.GeometricEntity(shape) |> Inti.Domain\n      Œì = Inti.boundary(Œ©)\n      msh = Inti.meshgen(Œì; meshsize = 0.1)\n      i,j = (n-1) √∑ ncols + 1, (n-1) % ncols + 1\n      ax = Axis3(fig[i,j]; aspect = :data, title = shape)\n      hidedecorations!(ax)\n      viz!(msh; showsegments = true)\nend\nfig # hide\n\nSee GeometricEntity(shape::String) for a list of predefined geometries.\n\nwarning: Mesh quality\nThe quality of the generated mesh created through meshgen depends   heavily on the quality of the underlying parametrization. For surfaces   containing a degenerate parametrization, or for complex shapes, one is   better off using a suitable CAD (Computer-Aided Design) software in   conjunction with a mesh generator.","category":"section"},{"location":"tutorials/geo_and_meshes/#Transfinite-domains","page":"Geometry and meshes","title":"Transfinite domains","text":"It is possible to combine parametric curves/surfaces to form a transfinite domain where the parametrization is inherited from the curves/surfaces that form its boundary. At present, Inti.jl only supports transfinite squares, which are defined by four parametric curves:\n\nl1 = Inti.parametric_curve(x->SVector(x, 0.1 * sin(2œÄ * x)), 0.0, 1.0, labels = [\"l‚ÇÅ\"])\nl2 = Inti.parametric_curve(x->SVector(1 + 0.1 * sin(2œÄ * x), x), 0.0, 1.0, labels = [\"l‚ÇÇ\"])\nl3 = Inti.parametric_curve(x->SVector(1 - x, 1 - 0.1 * sin(2œÄ * x)), 0.0, 1.0, labels = [\"l‚ÇÉ\"])\nl4 = Inti.parametric_curve(x->SVector(0.1 * sin(2œÄ * x), 1 - x), 0.0, 1.0, labels = [\"l‚ÇÑ\"])\nsurf = Inti.transfinite_square(l1, l2, l3, l4; labels = [\"Œ©\"])\nŒ© = Inti.Domain(surf)\nmsh = Inti.meshgen(Œ©; meshsize = 0.05)\nviz(msh; showsegments = true)\n\nNote that the msh object contains all entities used to construct Œ©, including the boundary segments:\n\nInti.entities(msh)\n\nThis allows us to probe the msh object to extract e.g. the boundary mesh:\n\nviz(msh[Inti.boundary(Œ©)]; color = :red)\n\nwarning: Limitations\nAt present only the transfinite interpolation for the logically   quadrilateral domains is supported. In the future we hope to add support   for three-dimensional transfinite interpolation, as well as transfinite   formulas for simplices.","category":"section"},{"location":"tutorials/geo_and_meshes/#Curving-a-given-mesh","page":"Geometry and meshes","title":"Curving a given mesh","text":"Inti.jl possesses some capability to create curved meshes from a given mesh, which can be useful when the mesh is not conforming to the geometry and the geometry's boundary is available in parametric form. Specifically the methods implement the work of C. Bernardi [1] which provides so-called 'exact' (sometimes called isogeometric) parametrizations of simplicial elements in arbitrary dimension.\n\nThe following example first creates a flat triangulation of a disk using splines through Gmsh:\n\nInti.clear_entities!() # hide\ngmsh.initialize()\nmeshsize = 2œÄ / 32\ngmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\ngmsh.option.setNumber(\"Mesh.MeshSizeMin\", meshsize)\n# Two kites\nf = (s) -> SVector(-1, 0.0) + SVector(cos(2œÄ*s), sin(2œÄ*s))\nbnd1 = Inti.gmsh_curve(f, 0, 1; meshsize)\ncl = gmsh.model.occ.addCurveLoop([bnd1])\ndisk = gmsh.model.occ.addPlaneSurface([cl])\ngmsh.model.occ.synchronize()\ngmsh.model.mesh.generate(2)\nmsh = Inti.import_mesh(; dim = 2)\ngmsh.finalize()\nŒ© = Inti.Domain(Inti.entities(msh)) do ent\n      return Inti.geometric_dimension(ent) == 2\nend\nviz(msh[Œ©], showsegments=true)\nŒ©_quad = Inti.Quadrature(msh[Œ©]; qorder = 10)\narea = Inti.integrate(x->1.0, Œ©_quad)\n@assert abs(area - œÄ) > 0.01 # hide\nprintln(\"Error in area computation using P1 mesh: \", abs(area - œÄ))\n\nAs can be seen, despite the large quadrature order employed, the approximation error is still significant. To improve the accuracy, we can use the curve_mesh function to create a curved mesh based on the boundary of the domain:\n\nŒ∏ = 5 # smoothness order of curved elements\ncrvmsh = Inti.curve_mesh(msh, f, Œ∏)\nŒ©_crv_quad = Inti.Quadrature(crvmsh[Œ©]; qorder = 10)\narea = Inti.integrate(x->1.0, Œ©_crv_quad)\n@assert abs(area - œÄ) < 1e-10 # hide\nprintln(\"Error in area computation using curved mesh: \", abs(area - œÄ))","category":"section"},{"location":"tutorials/geo_and_meshes/#Multiple-curved-domains,-subdomains,-and-curved-surfaces","page":"Geometry and meshes","title":"Multiple curved domains, subdomains, and curved surfaces","text":"It may be desired to have multiple curved volumes / boundaries. Inti.jl supports this, associating a parametrization with each volumetric entity in a mesh. Note the delicate correspondence between the correct EntityKey and the parametrization in setting entity_parametrization, and note also the limitations listed below.\n\ngmsh.initialize()\nmeshsize = 0.075\ngmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\ngmsh.option.setNumber(\"Mesh.MeshSizeMin\", meshsize)\n\n# Three circles\nc1 = gmsh.model.occ.addDisk(0, 0, 0, 1, 1)\nc2 = gmsh.model.occ.addDisk(0, 3.0, 0, 1, 1)\nc3 = gmsh.model.occ.addDisk(0, 8.0, 0, 2, 2)\ngmsh.model.occ.synchronize()\n\n# Add tags for stable identification of the entities\ngmsh.model.addPhysicalGroup(2, [c1], -1, \"c1\")\ngmsh.model.addPhysicalGroup(2, [c2], -1, \"c2\")\ngmsh.model.addPhysicalGroup(2, [c3], -1, \"c3\")\n\ngmsh.model.mesh.generate(2)\nmsh = Inti.import_mesh(; dim = 2)\n\nŒ© = Inti.Domain(Inti.entities(msh)) do ent\n    return Inti.geometric_dimension(ent) == 2\nend\ngmsh.finalize()\n\nŒì = Inti.external_boundary(Œ©)\nŒ©‚Çï = view(msh, Œ©)\nŒì‚Çï = view(msh, Œì)\n\n# Three circles\nœà‚ÇÅ = (t) -> [cos(2 * œÄ * t), sin(2 * œÄ * t)]\nœà‚ÇÇ = (t) -> [cos(2 * œÄ * t), 3.0 + sin(2 * œÄ * t)]\nœà‚ÇÉ = (t) -> [2 * cos(2 * œÄ * t), 8.0 + 2 * sin(2 * œÄ * t)]\nentity_parametrizations = Dict{Inti.EntityKey,Function}()\nfor e in Inti.entities(Œ©)\n    l = Inti.labels(e)\n    if \"c1\" in l\n        entity_parametrizations[e] = œà‚ÇÅ\n    elseif \"c2\" in l\n        entity_parametrizations[e] = œà‚ÇÇ\n    elseif \"c3\" in l\n        entity_parametrizations[e] = œà‚ÇÉ\n    end\nend\n\nŒ∏ = 6 # smoothness order of curved elements\ncrvmsh = Inti.curve_mesh(msh, entity_parametrizations, Œ∏)\n\nŒì‚Çï = crvmsh[Œì]\nŒ©‚Çï = crvmsh[Œ©]\n\nqorder = 5\nŒ©‚Çï_quad = Inti.Quadrature(Œ©‚Çï; qorder = qorder)\nŒì‚Çï_quad = Inti.Quadrature(Œì‚Çï; qorder = qorder)\nnothing # hide\n\nWe can verify once again that the correct area of the region is obtained.\n\narea = Inti.integrate(x -> 1, Œ©‚Çï_quad)\n@assert abs(area - 6œÄ) < 1e-10 # hide\nprintln(\"Error in computing area of three circles: \", abs(area - 6œÄ))\n\nOne can extract a subcomponent of the curved (volumetric) domain as usual:\n\nŒ©_sub = Inti.Domain(e -> \"c3\" in Inti.labels(e), Inti.entities(Œ©))\nŒ©‚Çï_sub = crvmsh[Œ©_sub]\nŒ©‚Çï_sub_quad = Inti.Quadrature(Œ©‚Çï_sub; qorder = qorder)\narea = Inti.integrate(x -> 1, Œ©‚Çï_sub_quad)\n@assert abs(area - 4œÄ) < 1e-13 # hide\nprintln(\"Error in computing area of one (large) circle: \", abs(area - 4œÄ))\n\nThe curved mesh also contains surface elements which are, like their volume counterparts, 'exact' (or isogeometric). To demonstrate this we compute the area using Green's theorem:\n\nF = (x) -> [1/2*x[1], 1/2*x[2]]\nlineint = Inti.integrate(q -> dot(F(q.coords), q.normal), Œì‚Çï_quad)\n@assert abs(lineint - 6œÄ) < 1e-13 # hide\nprintln(\"Error in computing area using line integral: \", abs(lineint - 6œÄ))\n\nNote the following restrictions that (currently) hold for 2D curved meshes:\n\nOnly a single boundary entity can be associated with a given curved volume entity\nA curved boundary entity cannot be associated with multiple volume entities.\n\nCurved 3D meshes with the same interface are also available with the following two (admittedly significant) restrictions:\n\nThe boundary parametrization must be global. Thus, a torus domain is possible but not a sphere.\nOnly a single curved domain is possible.\n\n(The second item could be easily addressed in Inti.jl if there is user interest; the first is more difficult to address.)","category":"section"},{"location":"tutorials/geo_and_meshes/#Elements-of-a-mesh","page":"Geometry and meshes","title":"Elements of a mesh","text":"To iterate over the elements of a mesh, use the elements function:\n\nfilename = joinpath(Inti.PROJECT_ROOT,\"docs\", \"assets\", \"piece.msh\")\nmsh = Inti.import_mesh(filename)\nents = Inti.entities(msh)\nŒ© = Inti.Domain(e -> Inti.geometric_dimension(e) == 3, ents) \nels = Inti.elements(view(msh, Œ©))\ncenters = map(el -> Inti.center(el), els)\nfig = Figure(; size = (800,400))\nax = Axis3(fig[1, 1]; aspect = :data)\nscatter!([c[1] for c in centers], [c[2] for c in centers], [c[3] for c in centers], markersize = 5)\nfig # hide\n\nThis example shows how to extract the centers of the tetrahedral elements in the mesh; and of course we can perform any desired computation on the elements.\n\ntip: Type-stable iteration over elements\nSince a mesh in Inti.jl can contain elements of various types, the   elements function above is not type-stable. For a type-stable iterator   approach, one should first iterate over the element types using   element_types, and then use elements(msh, E) to iterate over a   specific element type E.\n\nUnder the hood, each element is simply a functor which maps points xÃÇ from a ReferenceShape into the physical space:\n\nel = first(els)\nxÃÇ = SVector(1/3,1/3, 1/3)\nel(xÃÇ)\n\nLikewise, we can compute the jacobian of the element, or its normal at a given parametric coordinate.","category":"section"},{"location":"examples/stokes_drag/#Stokes-Drag","page":"Stokes drag","title":"Stokes Drag","text":"note: Important points covered in this example\nSolving a vector-valued problem\nUsage of curved triangular mesh\nPost-processing integral quantities","category":"section"},{"location":"examples/stokes_drag/#Problem-description","page":"Stokes drag","title":"Problem description","text":"In this example, we solve the classical Stokes drag problem, which models the drag force experienced by a sphere moving through a viscous fluid. The governing equations are the Stokes equations:\n\nbeginalign*\n-nabla p + mu Delta mathbfu = 0 quad  textin  Omega^c \nnabla cdot mathbfu = 0 quad  textin  Omega^c\nendalign*\n\nwhere:\n\nmathbfu is the velocity field,\np is the pressure,\nmu is the dynamic viscosity,\nOmega is the sphere, and Omega^c = mathbbR^3 setminus overlineOmega is the fluid domain.\n\nThe boundary conditions are:\n\nmathbfu = mathbfU on the sphere's surface, where mathbfU is the velocity of the sphere. This is a no-slip condition.\nmathbfu to mathbf0 at infinity, which means that the fluid is at rest far away from the sphere.\n\nThe drag force experienced by the sphere is described by Stokes' law:\n\nmathbfF_d = -6pimu R mathbfU\n\nwhere R is the sphere's radius. This drag force, mathbfF_d, is the primary quantity of interest in this example. We will compute it using Hebeker's formulation [10], which expresses the velocity field mathbfu as a combination of single- and double-layer potentials:\n\nmathbfu(mathbfx) = mathcalDboldsymbolsigma(mathbfx) + eta mathcalSboldsymbolsigma(mathbfx)\n\nHere, boldsymbolsigma is the unknown density, mathcalS and mathcalD denote the single- and double-layer potentials, respectively, and eta  0 is a coupling parameter, which we set to eta = mu throughout this example.","category":"section"},{"location":"examples/stokes_drag/#Discretization","page":"Stokes drag","title":"Discretization","text":"To discretize the boundary Gamma = partial Omega, we employ a second-order triangular mesh created using Gmsh:\n\nusing Inti, Gmsh\nmeshsize = 0.4\nR = 2.0\ngmsh.initialize()\ngmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\ngmsh.model.occ.addSphere(0, 0, 0, R)\ngmsh.model.occ.synchronize()\ngmsh.model.mesh.generate(2)\ngmsh.model.mesh.setOrder(2)\nmsh = Inti.import_mesh()\ngmsh.finalize()\nnothing # hide\n\ntip: Second-order mesh\nUsing gmsh.model.mesh.setOrder(2) creates a second-order mesh, which is crucial for accurately capturing the curved surface of the sphere and significantly enhances the numerical solution's precision. For simple geometries like spheres, an exact (isogeometric) representation can also be achieved using Inti's parametric entities. See the Geometry and meshes section for more details.\n\nNext we extract the Domain Gamma from the mesh, and create a Quadrature on it:\n\nŒ© = Inti.Domain(e -> Inti.geometric_dimension(e) == 3, Inti.entities(msh)) # the 3D volume\nŒì = Inti.boundary(Œ©) # its boundary\nŒì_msh = view(msh, Œì)\nŒì_quad = Inti.Quadrature(Œì_msh; qorder = 2) # quadrature on the boundary\nnothing # hide\n\nWith the quadrature prepared, we can now define the Stokes operator along with its associated integral operators. We use the FMM3D library to accelerate the evaluation of the integral operators:\n\nusing FMM3D\n# pick a correction and compression method\ncorrection = (method = :adaptive, )\ncompression = (method = :fmm, )\n\n# define the Stokes operator\nŒº = Œ∑ = 2.0\nop = Inti.Stokes(; dim = 3, Œº)\n\n# assemble integral operators\nS, D = Inti.single_double_layer(;\n    op,\n    target = Œì_quad,\n    source = Œì_quad,\n    compression,\n    correction,\n)","category":"section"},{"location":"examples/stokes_drag/#Solution-and-drag-force-computation","page":"Stokes drag","title":"Solution and drag force computation","text":"We are now ready to set up and solve the problem. First, we define the boundary conditions (a constant velocity on the sphere):\n\nusing StaticArrays\nv = 2.0\nU = SVector(v,0,0)\nf = fill(U, length(Œì_quad))\nnothing # hide\n\nTo solve the linear system, we will use the gmres function from IterativeSolvers. Since the function requires scalar types, we need to convert the vector-valued quantities into scalars and vice versa. We can achieve this by using reinterpret to convert between the vector of SVectors and a vector of Float64s types.\n\nusing IterativeSolvers, LinearAlgebra, LinearMaps\nT = SVector{3, Float64} # vector type\nL = I/2 + D + Œ∑ * S\nL_ = LinearMap{Float64}(3 * size(L, 1)) do y, x\n    œÉ = reinterpret(T, x)\n    Œº = reinterpret(T, y)\n    mul!(Œº, L, œÉ)\n    return y\nend\nœÉ  = zeros(T, length(Œì_quad))\nœÉ_ = reinterpret(Float64, œÉ)\nf_ = reinterpret(Float64, f)\n_, hist = gmres!(œÉ_, L_, f_; reltol = 1e-8, maxiter = 200, restart = 200, log = true)\n@assert hist.iters < 10 # hide\nhist\n\nNote that gmres converges in very few iterations, highlighting the favorable spectral properties of the Hebeker formulation for this problem.","category":"section"},{"location":"examples/stokes_drag/#Drag-force-computation","page":"Stokes drag","title":"Drag force computation","text":"Now that we have the density œÉ, we can compute the drag force. As pointed out in [10, Theorem 2.4], the drag force of the body Omega is given by:\n\n    mathbfF_d = eta int_Gamma boldsymbolsigma  dGamma\n\nwhich can be approximated using our knowledge of œÉ and the quadrature Œì_quad:\n\ndrag = Œº * sum(eachindex(Œì_quad)) do i\n    return œÉ[i] * Œì_quad[i].weight\nend\n\nA quick comparison with the analytical solution indicates a good agreement.\n\nexact = 6œÄ * Œº * R * U\nrelative_error = norm(drag - exact) / norm(exact)\n@assert relative_error < 1e-4 # hide\nprintln(\"Relative error: \", relative_error)\n\nThe relative error in this example is less than 1e-4, indicating that the numerical solution is very close to the analytical solution.","category":"section"},{"location":"examples/stokes_drag/#Visualization","page":"Stokes drag","title":"Visualization","text":"Finally, to visualize the flow field, we need to evaluate our integral representation at points off the boundary. The easiest way to achieve this is to use IntegralPotentials, or the convenient SingleLayerPotential and DoubleLayerPotential wrappers:\n\nùíÆ = Inti.SingleLayerPotential(op, Œì_quad)\nùíü = Inti.DoubleLayerPotential(op, Œì_quad)\nu(x) = ùíü[œÉ](x) + Œ∑*ùíÆ[œÉ](x) - U # fluid velocity relative to the sphere\n\nIn the code above, we have created a function u that evaluates the velocity at any point x:\n\nu(SVector(1,2,3))\n\nWith u defined, we can visualize the flow field around the sphere. For this example we will simply sample points on a grid in the xz plane, and plot the velocity vectors at those points:\n\nusing Meshes\nusing GLMakie\nL = 5\ntargets     = [SVector(x, 0, z) for x in -L:meshsize:L, z in -L:meshsize:L] |> vec\nfilter!(x -> norm(x) > 1.1 * R, targets) # remove points inside or close to the sphere\ndirections  = u.(targets)\nstrength    = norm.(directions)\nfig = Figure(size = (1000, 800))\nax  = Axis3(fig[1, 1]; title = \"Velocity field\", aspect = :data, limits = ([-L, L], [-R, R], [-L, L]))\nviz!(msh[Œì], showsegments=true)\narrows!(ax, Point3.(targets), Point3.(directions), arrowsize = 0.15, lengthscale = 0.4, arrowcolor = strength, linecolor = strength)\ncurrent_figure()\nfig","category":"section"},{"location":"examples/stokes_drag/#Summary","page":"Stokes drag","title":"Summary","text":"This tutorial demonstrates how to solve the Stokes drag problem using the Inti library. The approach combines boundary integral equations with numerical quadrature and iterative solvers to compute the drag force on a sphere in a viscous fluid.\n\ntip: Extensions\nExperiment with different geometries or boundary conditions.\nUse higher-order quadrature for improved accuracy.\nExplore the effect of mesh refinement on the solution.","category":"section"},{"location":"examples/crack_elasticity/#Elastic-crack-in-2D","page":"Elastic crack","title":"Elastic crack in 2D","text":"note: Important points covered in this example\nSolving a problem with an open surface (crack)\nUsing the hypersingular operator\nDefining a custom kernel with a weight function\nDealing with vector-valued problems","category":"section"},{"location":"examples/crack_elasticity/#Problem-definition","page":"Elastic crack","title":"Problem definition","text":"In this example, we solve a disk crack problem in the context of linear elasticity using boundary integral equations. The problem involves determining the displacement jump field boldsymbolphi in an infinite elastic domain containing a disk-shaped crack. It is possible to show that the problem can be reduced to a boundary integral equation of the form (e.g. [11, Chapter 13]):\n\nTboldsymbolphi = -boldsymbolf\n\nwhere T represents the integral operator associated with the hypersingular kernel, defined on the crack surface Gamma; boldsymbolf is the applied traction on the boundary, which is symmetric on the two crack lips; and boldsymbolphi is the so-called crack opening displacement (COD), defined as the \"displacement\" jump that occurs through the crack : boldsymbolphi=boldsymbol u^+-boldsymbol u^-.\n\ndetails: Details\nBeing considered an open surface, the crack Gamma is arbitrarily extended onto a closed surface tildeGamma. Then, we consider boldsymbolu^+ and boldsymbolu^- as the interior and exterior displacements, depending on the convention used. The crack opening displacement is then defined as the difference between the two displacements at the two crack lips, mathematically superposed. It has to be understood as a mathematical limit of the displacement field as a point approaches one lip or the other. This method is called the Displacement Discontinuity Method.\n\nThis example demonstrates the formulation, solution, and visualization of the problem, highlighting the use of integral operators.","category":"section"},{"location":"examples/crack_elasticity/#Geometry-and-mesh","page":"Elastic crack","title":"Geometry and mesh","text":"The domain is a disk of radius 1 on the plane z=0. We use the GMSH library to create the mesh, and Inti's import_mesh function to import it.\n\nusing Inti\nusing StaticArrays\nusing Gmsh\n\nmeshsize = 0.2\nqorder  = 2 # avoid 3 since it contains a negative weight\nrx = ry = 1\ngmsh.initialize(String[], false)\ngmsh.option.setNumber(\"Mesh.MeshSizeMin\", meshsize)\ngmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\ngmsh.model.occ.addDisk(0.0, 0.0, 0.0, rx, ry)\ngmsh.model.occ.synchronize()\ngmsh.model.mesh.generate(2)\ngmsh.model.mesh.setOrder(1)\nmsh = Inti.import_mesh(; dim = 3)\nŒì = Inti.Domain(e -> Inti.geometric_dimension(e) == 2, msh)\nŒì_msh = msh[Œì]\nQ = Inti.Quadrature(Œì_msh; qorder = 2)\ngmsh.finalize()\n\nNote that we have used second-order elements for the mesh, which is useful for better representing the edges of the circular crack.","category":"section"},{"location":"examples/crack_elasticity/#Integral-operators","page":"Elastic crack","title":"Integral operators","text":"We will now build an approximation to T using:\n\nA hierarchical matrix representation for the integral operator\nAn adaptive correction to account for the singular and nearly singular interactions\n\nusing HMatrices\nusing LinearMaps\nusing LinearAlgebra\n#Elastic properties\nŒº = 1; ŒΩ = 0.15;\nE = 2*Œº*(1+ŒΩ)\nŒª = ŒΩ*E / ((1+ŒΩ)*(1-2*ŒΩ))\nop = Inti.Elastostatic(; Œª, Œº, dim = 3)\nK = Inti.HyperSingularKernel(op)\nTop = Inti.IntegralOperator(K, Q)\nT‚ÇÄ = Inti.assemble_hmatrix(Top)\nŒ¥T = Inti.adaptive_correction(Top)\nnothing # hide","category":"section"},{"location":"examples/crack_elasticity/#Boundary-conditions","page":"Elastic crack","title":"Boundary conditions","text":"For the boundary conditions, we consider a constant normal loading on the crack surface, simply given by:\n\nf = 1.0\nt = -[SVector(0,0,f) for _ in Q]\nnothing # hide\n\nNote that we used an SVector to represent the traction at a point on the crack surface. For vector-valued problems, SVectors and SMatrixs are often used to represent vectors and tensors, respectively, since their size is known at compile time (and small). This avoids the overhead of dynamic arrays.\n\nWe are now ready to compute the approximate solution.","category":"section"},{"location":"examples/crack_elasticity/#Solution","page":"Elastic crack","title":"Solution","text":"The exact solution for this problem can be obtained by separation of variables in cylindrical coordinates, and can be shown to be:\n\nœÉ = 1\nœÜ‚ÇÉ(r) = 4*(1-ŒΩ)*œÉ / (œÄ*Œº) * sqrt(1-r^2)\nuexact(x) = SVector(0, 0, œÜ‚ÇÉ(norm(x)))\n\nTo compute the approximate solution, we will need to solve the linear system:\n\nTboldsymbolphi = boldsymbolf\n\nwhere boldsymbolphi is the unknown vector of displacements. One difficulty that arises is related to the fact that in our implementation, both \\phi and f are represented as Vectors of SVectors. While convenient for some operations, this can lead to difficulties when trying to solve the linear system since most linear algebra libraries expect matrices over a scalar field (usually either mathbbR or mathbbC). To address this, we will write a short function solve that will convert between the vector of vectors and the vector of scalars.\n\nusing IterativeSolvers\nfunction solve!(u, T‚ÇÄ, Œ¥T, t)\n    @assert eltype(T‚ÇÄ) == eltype(Œ¥T) == SMatrix{3,3,Float64,9}\n    @assert eltype(t) == eltype(u) == SVector{3,Float64}\n    # write a LinearMap over scalars by reinterpreting them as vectors of SVectors, \n    # applying our operators T‚ÇÄ and Œ¥T, and converting back before returning\n    L_ = LinearMap{Float64}(3 * size(T‚ÇÄ, 1)) do y, x\n        œÉ = reinterpret(SVector{3,Float64}, x)\n        Œº = reinterpret(SVector{3,Float64}, y)\n        mul!(Œº, T‚ÇÄ, œÉ)\n        mul!(Œº, Œ¥T, œÉ, 1, 1)\n        return y\n    end\n    # flatten our input vectors and call gmres on the Float64 version\n    u_ = reinterpret(Float64, u)\n    t_ = reinterpret(Float64, t)\n    u_, gmres_hist = gmres!(u_, L_, t_, restart = 1000, maxiter = 1000, log=true)\n    @show gmres_hist\n    # since u_ is just a reinterpretation of u, we can simply return u when done\n    return u\nend\nsolve(T‚ÇÄ, Œ¥T, t) = solve!(zero(t), T‚ÇÄ, Œ¥T, t)\n\nWe can now easily call solve to obtain our approximate solution:\n\nœÜ = solve(T‚ÇÄ, Œ¥T, t)\nnothing # hide","category":"section"},{"location":"examples/crack_elasticity/#Visualization","page":"Elastic crack","title":"Visualization","text":"Next we show a crude visualization by plotting the displacement value at each point of the quadrature (as a function of the radius), and comparing it to the exact solution. The displacement is a vector, but we will only plot the z component, which is the only one that is non-zero in this case.\n\nusing LinearAlgebra\nusing GLMakie\nr    = map(q -> norm(Inti.coords(q)), Q)\nvals = getindex.(œÜ, 3)\nscatter(r, vals, label = \"Numerical solution\")\nlines!(0:0.01:1, œÜ‚ÇÉ, label = \"Exact solution\", color = :red, linewidth = 4)\naxislegend()\ncurrent_figure()\n\nAlthough the solution is not perfect, it captures the general behavior of the displacement field. One way to make the error smaller is to use a finer mesh and/or higher order quadrature. An alternative way, however, is to use a weight function to incorporate the singular behavior of the displacement field near the edge of the crack, as shown next.","category":"section"},{"location":"examples/crack_elasticity/#Improving-the-accuracy","page":"Elastic crack","title":"Improving the accuracy","text":"It is beneficial to add a weight function to help the solution being more accurate near the crack, where the displacement is singular, asymptotically equal to d^12 (d is the distance from a point to the crack front) according to the Williams' asymptotic expansion. For this simple example we take the weight function as:\n\nw(boldsymbol x)=sqrt1-boldsymbol xundersetdrightarrow\n0simsqrtd(boldsymbol x)\n\nweight(x) = sqrt(1 - norm(x))\n\nand define a modified kernel K_w as:\n\nKw = let w = weight, K = K\n    (p,q) ->  K(p,q) * w(q.coords)\nend\nInti.singularity_order(::typeof(Kw)) = -3\n\nWith this new kernel, we can build our new integral operator T_w and solve the displacement jump equation for a modified density boldsymbolphi_w = boldsymbolphi  w:\n\nTw_op = Inti.IntegralOperator(Kw, Q)\nTw‚ÇÄ = Inti.assemble_hmatrix(Tw_op)\nŒ¥Tw = Inti.adaptive_correction(Tw_op; maxdist = 2*meshsize, atol = 1e-2)\nœÜw = solve(Tw‚ÇÄ, Œ¥Tw, t)\n\nWe now plot the displacement field again, but this with the weighted kernel approach, and compare it to the previous approach. Note that we must multiply the solution œÜw by the weight function to obtain the actual displacement jump œÜ.\n\nweights = [weight(q.coords) for q in Q]\nscatter(r, getindex.(œÜw,3) .* weights, label = \"Numerical solution (weighted)\")\nlines!(0:0.01:1, œÜ‚ÇÉ, label = \"Exact solution\", color = :red, linewidth = 4)\naxislegend()\ncurrent_figure()\n\nThe solution is now much more accurate, especially near the crack front, even though the same mesh and quadrature were used. This is a common technique in boundary integral equation: factoring out the asymptotic (non-smooth) behavior of the solution using a weight function.\n\nFinally, we can visualize the displacement field on the mesh by interpolating the computed values on the quadrature points to the mesh nodes. We use Meshes to visualize the solution:\n\nusing Meshes\nœÜ3w_nodes = Inti.quadrature_to_node_vals(Q, getindex.(œÜw, 3))\nmsh_nodes = Inti.nodes(Q.mesh)\nw_nodes = [weight(x) for x in msh_nodes]\nœÜ3_nodes = œÜ3w_nodes .* w_nodes\ncolorrange = extrema(œÜ3_nodes)\nfig = Figure(; size = (800, 600))\nax = Axis3(fig[1, 1])\nn = length(Q.mesh.nodes)\nviz!(Q.mesh; color = œÜ3_nodes, interpolate = false, showsegments=true)\ncb = Colorbar(fig[1, 2]; label = \"œÜ‚ÇÉ\", colorrange)\nfig","category":"section"},{"location":"examples/heat_equation/#Heat-equation","page":"Heat equation","title":"Heat equation","text":"note: Important points covered in this example\nUsing Rothe's method to solve a time-dependent PDE\nCombining volume and boundary integral equations for efficient solution\nHandling complex domains with holes\nAnimating the solution evolution using Makie","category":"section"},{"location":"examples/heat_equation/#Problem-description","page":"Heat equation","title":"Problem description","text":"In this example, we'll solve the heat equation in a domain Omega with Dirichlet boundary conditions on Gamma = partial Omega.\n\nbeginalign*\n    partial_t u(xt) - Delta u(xt)  = f(xtu) quad  x in Omega quad t in 0T\n    u(xt) = g(xt) quad  x in Gamma quad t in 0T\n    u(x t = 0) = u_0(x) quad  x in Omega tagHeat equation\nendalign*\n\nwhere:\n\nu(xt) represents temperature at position x and time t\nf(xtu) is a source/sink term (can depend on the solution itself for nonlinear problems)\ng(xt) specifies the Dirichlet boundary condition (prescribed temperature at the boundary)\nu_0(x) is the initial temperature distribution\n\nThe heat equation is a parabolic PDE, and we will solve it using Rothe's method (also known as the method of lines transpose). This approach first discretizes in time, reducing the problem to a sequence of elliptic PDEs which we then solve using integral equations. This contrasts with the method of lines, which discretizes in space first and solves the resulting ODEs.","category":"section"},{"location":"examples/heat_equation/#Solution-approach","page":"Heat equation","title":"Solution approach","text":"","category":"section"},{"location":"examples/heat_equation/#Overview","page":"Heat equation","title":"Overview","text":"Our solution strategy follows these key steps:\n\nTime discretization: Apply backward Euler to convert the time-dependent PDE into a sequence of Yukawa equations\nSolution splitting: Decompose the solution into particular and homogeneous parts\nIntegral formulation: Use volume potentials for the particular solution and boundary integrals for the homogeneous solution\nDiscretization: Apply numerical quadrature to the integral operators\nTime stepping: Solve the sequence of spatial problems to march forward in time","category":"section"},{"location":"examples/heat_equation/#Time-discretization-(Rothe's-method)","page":"Heat equation","title":"Time discretization (Rothe's method)","text":"Following these lecture notes by Costabel, we first discretize time using an implicit scheme (backward Euler for simplicity):\n\nbeginalign*\nu^n - tauDelta u^n  = tau f^n-1 + u^n-1 quad  textin  Omega\nu^n = g^n quad  texton  partialOmega\nendalign*\n\nwhere tau is the time step and an n superscript denotes the function value at time t = ntau (e.g. u^n(x) = u(x t = ntau)). ","category":"section"},{"location":"examples/heat_equation/#Converting-to-a-Yukawa-equation","page":"Heat equation","title":"Converting to a Yukawa equation","text":"Dividing both sides by tau we get a Yukawa (or modified Helmholtz) equation for the function u^n:\n\nbeginalign*\n-Delta u^n + frac1tauu^n  = f^n-1 + fracu^n-1tau quad  textin  Omega\nu^n = g^n quad  texton  partialOmega tagYukawa equation\nendalign*","category":"section"},{"location":"examples/heat_equation/#Solution-decomposition","page":"Heat equation","title":"Solution decomposition","text":"This is now amenable to an integral equation formulation. To do so we split the solution into a particular solution u^n_p and a homogeneous solution u^n_h:\n\nu^n = u^n_p + u^n_h","category":"section"},{"location":"examples/heat_equation/#The-particular-solution","page":"Heat equation","title":"The particular solution","text":"The function u^n_p is given as a volume potential:\n\nu^n_p(x) = int_Omega G(x y) left( f(yt^n-1 u^n-1) + fracu^n-1(y)tau right)  mathrmdOmega(y) tagParticular solution\n\nwhere G(xy) is the fundamental solution of the Yukawa operator.","category":"section"},{"location":"examples/heat_equation/#The-homogeneous-solution","page":"Heat equation","title":"The homogeneous solution","text":"As for the homogeneous solution u^n_h, it satisfies:\n\nbeginalign*\n-Delta u^n_h + frac1tau u^n_h = 0  quad textin  quad Omega \nu^n_h = g^n - u^n_p  quad texton   partialOmega tagHomogenous problem\nendalign*","category":"section"},{"location":"examples/heat_equation/#Boundary-integral-formulation","page":"Heat equation","title":"Boundary integral formulation","text":"We'll use an indirect double-layer formulation, where we seek u^n_h in the form:\n\nu^n_h(r) = mathcalDsigma(r) quad r in Omega\n\nwith mathcalD the double-layer potential associated with the Yukawa equation, and sigma the unknown density. Taking the interior Dirichlet trace (for a smooth boundary) yields:\n\nfrac-sigma(x)2 + Dsigma(x) = g^n(x) - u^n_p(x) quad x in partialOmega tagBIE\n\nThis boundary integral equation (BIE) allows us to solve for the density sigma on the boundary.","category":"section"},{"location":"examples/heat_equation/#Summary-of-the-solution-strategy","page":"Heat equation","title":"Summary of the solution strategy","text":"The steps outlined above reduce the time-dependent heat equation to a sequence of forced Yukawa equations which can be solved using the same techniques as in the Poisson problem tutorial. For each time step:\n\nUse the volume potential to compute the particular solution u^n_p\nSolve the BIE to find the density sigma\nApply the double-layer potential to compute the homogeneous solution u^n_h\nCombine the solutions: u^n = u^n_p + u^n_h","category":"section"},{"location":"examples/heat_equation/#Spatial-discretization","page":"Heat equation","title":"Spatial discretization","text":"We now proceed to discretize the inhomogeneous Yukawa equation. We will use Gmsh to create a disk with a few holes in it, representing a domain with inclusions where heat can flow around but not through.","category":"section"},{"location":"examples/heat_equation/#Creating-the-mesh","page":"Heat equation","title":"Creating the mesh","text":"using Inti\nusing Gmsh\nfunction create_mesh(meshsize, meshorder=2)\n\tgmsh.initialize()\n\tgmsh.option.setNumber(\"General.Verbosity\", 2)\n\tgmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\n\tdisk = gmsh.model.occ.addDisk(0, 0, 0, 1, 1)\n\tell1 = gmsh.model.occ.addDisk(.5, 0, 0, 0.2, 0.1)\n\tell2 = gmsh.model.occ.addDisk(-.5, 0.3, 0, 0.3, 0.2)\n\tgmsh.model.occ.rotate([(2,ell2)], 0, 0, 0, 0, 0, 1, -œÄ/3)\n\tell3 = gmsh.model.occ.addDisk(-.5, -0.5, 0, 0.2, 0.15)\n\tgmsh.model.occ.rotate([(2,ell3)], 0, 0, 0, 0, 0, 1, œÄ/3)\n\tgmsh.model.occ.cut([(2,disk)], [(2,ell1), (2,ell2), (2,ell3)])\n\tgmsh.model.occ.synchronize()\n\tgmsh.model.mesh.generate(2)\n\tgmsh.model.mesh.setOrder(meshorder)\n\tmsh = Inti.import_mesh(; dim = 2)\n\tgmsh.finalize()\n\treturn msh\nend\nmeshsize = 0.1\nmeshorder = 2\ntau       = 2œÄ / 40\nmsh = create_mesh(meshsize, meshorder)\n\nnote: Mesh structure\nNote that msh contains all the elements of the generated mesh, including the boundary segments and any point entities that Gmsh may have created. To properly index into our mesh elements, we must use Domains, which are simply a collection of geometric entities.","category":"section"},{"location":"examples/heat_equation/#Extracting-domain-and-boundary","page":"Heat equation","title":"Extracting domain and boundary","text":"Since we will need to work with Omega and Gamma separately, we will extract those domains and their corresponding (sub)meshes:\n\nŒ© = Inti.Domain(e -> Inti.geometric_dimension(e) == 2, msh)\nŒì = Inti.boundary(Œ©)\nŒ©_msh = @views msh[Œ©]\nŒì_msh = @views msh[Œì]\nnothing # hide","category":"section"},{"location":"examples/heat_equation/#Visualizing-the-geometry","page":"Heat equation","title":"Visualizing the geometry","text":"Let's visualize the mesh to confirm our domain setup. The red outline shows the boundary Gamma, which consists of both the outer boundary and the boundaries of the interior holes:\n\nusing Meshes\nusing GLMakie\nfig = viz(\n    Œ©_msh;\n    segmentsize = 1,\n    showsegments = true,\n    axis = (aspect = DataAspect(),),\n    figure = (; size = (500, 400)),\n)\nviz!(Œì_msh; color = :red, segmentsize = 4)\nfig # hide","category":"section"},{"location":"examples/heat_equation/#Setting-up-numerical-quadrature","page":"Heat equation","title":"Setting up numerical quadrature","text":"Now we create quadrature rules for both Omega and Gamma, which will be used to  accurately integrate our kernel functions over the domain and boundary:\n\nŒ©_quad = Inti.Quadrature(Œ©_msh; qorder = 2)\nŒì_quad = Inti.Quadrature(Œì_msh; qorder = 2)\nnothing # hide","category":"section"},{"location":"examples/heat_equation/#Constructing-integral-operators","page":"Heat equation","title":"Constructing integral operators","text":"","category":"section"},{"location":"examples/heat_equation/#The-Yukawa-operator","page":"Heat equation","title":"The Yukawa operator","text":"First, we define the Yukawa operator with parameter Œª = 1sqrttau, which arises from our time discretization:\n\nŒª = 1/sqrt(tau)\nop = Inti.Yukawa(; dim = 2, Œª)","category":"section"},{"location":"examples/heat_equation/#Creating-the-integral-operators","page":"Heat equation","title":"Creating the integral operators","text":"Next, we construct four key integral operators needed to solve our problem:\n\nOperator Type Purpose\nmathcalV_Omega to Omega Volume potential Computes the particular solution in the domain\nmathcalV_Omega to Gamma Volume potential Computes the trace of the particular solution on the boundary\nmathcalD_Gamma to Gamma Double-layer operator Solves for the density on the boundary\nmathcalD_Gamma to Omega Double-layer potential Computes the homogeneous solution in the domain","category":"section"},{"location":"examples/heat_equation/#Setting-operator-parameters","page":"Heat equation","title":"Setting operator parameters","text":"For each operator, we specify compression and correction parameters:\n\n# using HMatrices\n# compression = (method = :hmatrix, atol = 1e-8)\ncorrection = (\n    method = :adaptive,\n    threads = true,\n    maxdist = 3 * meshsize,\n    atol = 1e-6,\n    maxsubdiv = 10_000,\n)\ncompression = (method = :none,)\nnothing # hide\n\ntip: Performance optimization\nInstead of using a dense matrix representation of the integral operators, you would typically enable HMatrix compression for larger problems. The commented code shows how to configure it with appropriate tolerance parameters.","category":"section"},{"location":"examples/heat_equation/#Building-the-operators","page":"Heat equation","title":"Building the operators","text":"Let's create our operators:\n\nV_d2b = Inti.volume_potential(;\n\top,\n\ttarget = Œì_quad,\n\tsource = Œ©_quad,\n\tcompression,\n\tcorrection,\n)\n_, D_b2b = Inti.single_double_layer(;\n\top,\n\ttarget = Œì_quad,\n\tsource = Œì_quad,\n\tcompression,\n\tcorrection\n)\nV_d2d = Inti.volume_potential(;\n\top,\n\ttarget = Œ©_quad,\n\tsource = Œ©_quad,\n\tcompression,\n\tcorrection,\n)\n_, D_b2d = Inti.single_double_layer(;\n\top,\n\ttarget = Œ©_quad,\n\tsource = Œì_quad,\n\tcompression,\n\tcorrection\n)\nnothing # hide","category":"section"},{"location":"examples/heat_equation/#Time-evolution","page":"Heat equation","title":"Time evolution","text":"","category":"section"},{"location":"examples/heat_equation/#Factoring-the-boundary-integral-operator","page":"Heat equation","title":"Factoring the boundary integral operator","text":"Since our domain remains fixed throughout the simulation, we can factor the boundary integral operator to improve computational efficiency:\n\nusing LinearAlgebra\nL = -I/2 + D_b2b\nF = lu(L)\nnothing # hide","category":"section"},{"location":"examples/heat_equation/#Verification-with-a-manufactured-solution","page":"Heat equation","title":"Verification with a manufactured solution","text":"To verify our implementation, we'll first use the method of manufactured solutions. We choose a  known analytical solution u_e(xt) and derive the corresponding source term and boundary conditions:\n\nu‚Çë = (x, t) -> sin(x[1]) * sin(x[2]) * cos(t)\nf  = (x, t) -> 2 * u‚Çë(x, t) - sin(t) * sin(x[1]) * sin(x[2])\ng = (x, t) -> u‚Çë(x, t) # boundary values\nnothing # hide","category":"section"},{"location":"examples/heat_equation/#Time-stepping-algorithm","page":"Heat equation","title":"Time-stepping algorithm","text":"Now we perform the time-stepping loop for one full period (T = 2pi):\n\nnsteps = round(Int, 2œÄ/tau)\nu‚Åø‚Åª¬π = map(q -> u‚Çë(q.coords, 0), Œ©_quad) # initial condition\nu‚Åø   = zero(u‚Åø‚Åª¬π)\nt    = Ref(0.0)\nfor n in 1:nsteps\n\t# 1. Evaluate source term at current time\n\tf‚Åø  = map(q -> f(q.coords, t[] + tau), Œ©_quad)\n\t\n\t# 2. Compute the particular solution\n\tu‚Çö‚Åø = V_d2d*(f‚Åø + u‚Åø‚Åª¬π/tau)\n\t\n\t# 3. Evaluate boundary conditions\n\tg‚Åø  = map(q -> g(q.coords, t[] + tau), Œì_quad)\n\t\n\t# 4. Solve BIE and compute homogeneous solution\n\tu‚Çï‚Åø = D_b2d * (F \\ (g‚Åø - V_d2b * (f‚Åø + u‚Åø‚Åª¬π / tau)))\n\t\n\t# 5. Combine solutions and update for next time step\n\tu‚Åø .= u‚Çö‚Åø + u‚Çï‚Åø\n\tu‚Åø‚Åª¬π .= u‚Åø\n\tt[] += tau\nend\n\nLet's check the accuracy of our solution by comparing with the exact solution:\n\nuref = map(q -> u‚Çë(q.coords, t[]), Œ©_quad) # reference solution\ner = norm(u‚Åø - uref, Inf) / norm(uref, Inf)\n@assert er < 1e-2 # hide\ner\n\nA relative error of this magnitude confirms that our implementation is working correctly.\n\nnote: Convergence\nTesting that the error is \"small\" is just a basic verification. For rigorous validation, we should analyze the convergence order as we refine both spatial and temporal discretizations. For this example, the error is primarily determined by the first-order backward Euler scheme. Try halving the time step and observe how the error reduces approximately by a factor of 2!\n\nNow let's explore a more interesting scenario: heat flow in a domain with inclusions. We'll set the  temperature to zero at the outer boundary and apply a time-varying temperature of sin^2(t) at  the boundaries of the inclusions:\n\nf  = (x, t) -> 0.0\ng  = (x, t) -> norm(x) > 0.9 ? 0.0 : (sin(t))^2\nu‚Å∞ = zeros(length(Œ©_quad))\nnothing # hide\n\nThis physical setup models a scenario where the outer surface is kept at a constant cold temperature, while the inclusions have a periodically varying temperature - similar to heat sources that turn on and off.","category":"section"},{"location":"examples/heat_equation/#Visualizing-the-temperature-evolution","page":"Heat equation","title":"Visualizing the temperature evolution","text":"Here's the animation of the temperature distribution evolving over time:\n\nfig = Figure()\nax = Axis(fig[1, 1]; aspect = DataAspect())\ncolorrange = (0.0, 1.0)\nrecord(fig, joinpath(@__DIR__,\"heat.gif\")) do io\n\tnsteps = round(Int, 2œÄ/tau)\n\tu‚Åø‚Åª¬π = u‚Å∞\n\tu‚Åø   = zero(u‚Åø‚Åª¬π)\n\tt    = 0.0\n\tfor n in 1:nsteps\n\t\t# Convert quadrature values to node values for visualization\n\t\tu_nodes = Inti.quadrature_to_node_vals(Œ©_quad, u‚Åø‚Åª¬π)\n\t\t\n\t\t# Setup visualization for current frame\n\t\tax.title = \"Temperature at t = $(round(t, digits = 2))\"\n\t\tviz!(Œ©_quad.mesh; showsegments = true, color = u_nodes, colorrange)\n\t\tviz!(Œì_msh; color = :black, segmentsize = 4)\n\t\tColorbar(fig[1, 2]; colorrange = colorrange, label = \"Temperature\")\n\t\t\n\t\t# Record current frame\n\t\trecordframe!(io)\n\t\t\n\t\t# Solve for next time step\n\t\tf‚Åø  = map(q -> f(q.coords, t + tau), Œ©_quad)\n\t\tu‚Çö‚Åø = V_d2d*(f‚Åø + u‚Åø‚Åª¬π/tau)\n\t\tg‚Åø  = map(q -> g(q.coords, t + tau), Œì_quad)\n\t\tu‚Çï‚Åø = D_b2d * (F \\ (g‚Åø - V_d2b * (f‚Åø + u‚Åø‚Åª¬π / tau)))\n\t\tu‚Åø = u‚Çö‚Åø + u‚Çï‚Åø\n\t\tu‚Åø‚Åª¬π = u‚Åø\n\t\tt += tau\n\tend\nend\nnothing # hide\n\n(Image: Heat equation)","category":"section"},{"location":"examples/heat_equation/#Summary-and-extensions","page":"Heat equation","title":"Summary and extensions","text":"We've demonstrated how to solve the heat equation using Rothe's method combined with boundary integral equations. This approach effectively handles complex geometries and provides accurate solutions with reasonable computational cost.\n\ntip: Going further\nTo extend this example, consider:Implementing a second-order time scheme (e.g., Crank-Nicolson) for improved accuracy\nUtilizing hierarchical matrix compression (HMatrix) for larger domains\nExploring more complex geometries or physical scenarios\nAdding nonlinear terms to model more complex physical phenomena","category":"section"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"(Image: Pluto notebook)","category":"section"},{"location":"pluto-examples/poisson/#Poisson-Problem","page":"Poisson problem","title":"Poisson Problem","text":"note: Important points covered in this example\nReformulating Poisson-like problems using integral equations\nUsing volume potentials\nCreating interior meshes using Gmsh","category":"section"},{"location":"pluto-examples/poisson/#Problem-definition","page":"Poisson problem","title":"Problem definition","text":"In this example we will solve the Poisson equation in a domain Omega with Dirichlet boundary conditions on Gamma = partial Omega:\n\n  beginalign*\n      -Delta u = f  quad textin  quad Omega\n      u = g  quad texton  quad Gamma\n  endalign*\n\nwhere f  Omega to mathbbR and g  Gamma to mathbbR are given functions. To solve this problem using integral equations, we split the solution u into a particular solution u_p and a homogeneous solution u_h:\n\n  u = u_p + u_h\n\nThe function u_p is given by\n\nu_p(boldsymbolr) = int_Omega G(boldsymbolr boldsymbolr) f(boldsymbolr) dboldsymbolr\n\nwith G the fundamental solution of -Delta.\n\nThe function u_h satisfies the homogeneous problem\n\n  beginalign*\n      Delta u_h = 0  quad textin  quad Omega \n      u_h = g - u_p  quad texton   quad Gamma\n  endalign*\n\nwhich can be solved using the integral equation method. In particular, for this example, we employ a double-layer formulation:\n\nu_h(boldsymbolr) = int_Gamma G(boldsymbolr boldsymbolr) sigma(boldsymbolr) dboldsymbolr\n\nwhere the density function sigma solves the integral equation\n\n  -fracsigma(boldsymbolx)2 + int_Gamma partial_nu_boldsymbolyG(boldsymbolx boldsymboly) sigma(boldsymboly)  mathrmd s_boldsymboly = g(boldsymbolx) - u_p(boldsymbolx)\n\nIn what follows we illustrate how to solve the problem in this manner.","category":"section"},{"location":"pluto-examples/poisson/#Geometry-and-mesh","page":"Poisson problem","title":"Geometry and mesh","text":"We use the Gmsh API to create a jellyfish-shaped domain and to generate a second order mesh of its interior and boundary:\n\nusing Inti, Gmsh\nmeshsize = 0.1\ngmsh.initialize()\njellyfish = Inti.gmsh_curve(0, 2œÄ; meshsize) do s\n    r = 1 + 0.3 * cos(4 * s + 2 * sin(s))\n    return r * Inti.Point2D(cos(s), sin(s))\nend\ncl = gmsh.model.occ.addCurveLoop([jellyfish])\nsurf = gmsh.model.occ.addPlaneSurface([cl])\ngmsh.model.occ.synchronize()\ngmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\ngmsh.model.mesh.generate(2)\ngmsh.model.mesh.setOrder(2)\nmsh = Inti.import_mesh(; dim = 2)\ngmsh.finalize()\n\nWe can now extract components of the mesh corresponding to the Omega and Gamma domains:\n\nŒ© = Inti.Domain(e -> Inti.geometric_dimension(e) == 2, msh)\nŒì = Inti.boundary(Œ©)\nŒ©_msh = view(msh, Œ©)\nŒì_msh = view(msh, Œì)\nnothing #hide\n\nand visualize them:\n\nusing Meshes, GLMakie\nviz(Œ©_msh; showsegments = true)\nviz!(Œì_msh; color = :red)\nMakie.current_figure() #hide\n\nTo conclude the geometric setup, we need a quadrature for the volume and boundary:\n\nŒ©_quad = Inti.Quadrature(Œ©_msh; qorder = 4)\nŒì_quad = Inti.Quadrature(Œì_msh; qorder = 6)\nnothing #hide","category":"section"},{"location":"pluto-examples/poisson/#Integral-operators","page":"Poisson problem","title":"Integral operators","text":"We can now assemble the required volume potential. To obtain the value of the particular solution u_p on the boundary for the modified integral equation above we will need the volume integral operator mapping to points on the boundary, i.e. operator:\n\nusing FMM2D #to accelerate the maps\nop = Inti.Laplace(; dim = 2)\n# Newtonian potential mapping domain to boundary\nV_d2b = Inti.volume_potential(;\n    op,\n    target = Œì_quad,\n    source = Œ©_quad,\n    compression = (method = :fmm, tol = 1.0e-12),\n    correction = (method = :dim, maxdist = 5 * meshsize, target_location = :on),\n)\n\nWe require also the boundary integral operators for the ensuing integral equation:\n\n# Single and double layer operators on Œì\nS_b2b, D_b2b = Inti.single_double_layer(;\n    op,\n    target = Œì_quad,\n    source = Œì_quad,\n    compression = (method = :fmm, tol = 1.0e-12),\n    correction = (method = :dim,),\n)\n\nnote: Note\nIn this example we used the Fast Multipole Method (:fmm) to accelerate the operators, and the Density Interpolation Method (:dim) to correct singular and nearly-singular integral.","category":"section"},{"location":"pluto-examples/poisson/#Solving-the-linear-system","page":"Poisson problem","title":"Solving the linear system","text":"We are now in a position to solve the original Poisson problem, but for that we need to specify the functions f and g. In order to verify that our numerical approximation is correct, however, we will play a different game and specify instead a manufactured solution u_e from which we will derive the functions f and g:\n\n# Create a manufactured solution\nu‚Çë = (x) -> cos(2 * x[1]) * sin(2 * x[2])\nf‚Çë = (x) -> 8 * cos(2 * x[1]) * sin(2 * x[2]) # -Œîu‚Çë\ng = map(q -> u‚Çë(q.coords), Œì_quad)\nf = map(q -> f‚Çë(q.coords), Œ©_quad)\nnothing #hide\n\nWith these, we can compute the right-hand-side of the integral equation for the homogeneous part of the solution:\n\nrhs = g - V_d2b * f\nnothing #hide\n\nand solve the integral equation for the integral density function œÉ:\n\nusing IterativeSolvers, LinearAlgebra\nœÉ = gmres(-I / 2 + D_b2b, rhs; abstol = 1.0e-8, verbose = true, restart = 1000)\nnothing #hide\n\nWith the density function at hand, we can now reconstruct our approximate solution:\n\nG = Inti.SingleLayerKernel(op)\ndG = Inti.DoubleLayerKernel(op)\nùí± = Inti.IntegralPotential(G, Œ©_quad)\nùíü = Inti.IntegralPotential(dG, Œì_quad)\nu = (x) -> ùí±[f](x) + ùíü[œÉ](x)\n\nand evaluate it at any point in the domain:\n\nx = Inti.Point2D(0.1, 0.4)\nprintln(\"error at $x: \", u(x) - u‚Çë(x))","category":"section"},{"location":"pluto-examples/poisson/#Solution-evaluation-and-visualization","page":"Poisson problem","title":"Solution evaluation and visualization","text":"Although we have \"solved\" the problem in the previous section, using the anonymous function u to evaluate the field is neither efficient nor accurate when there are either many points to evaluate, or when they lie close to the domain Omega. The fundamental reason for this is the usual: the integral operators in the function u are dense matrices, and their evaluation inside or near to Omega suffers from inaccurate singular and near-singular quadrature.\n\nTo address this issue, we need to assemble accelerated and corrected versions of the integral operators. Let us suppose we wish to evaluate the solution u at all the quadrature nodes of Omega:\n\nV_d2d = Inti.volume_potential(;\n    op,\n    target = Œ©_quad,\n    source = Œ©_quad,\n    compression = (method = :fmm, tol = 1.0e-8),\n    correction = (method = :dim,),\n)\n\nLikewise, we need operators mapping densities from our boundary quadrature to our mesh nodes:\n\nWe now evaluate the solution at all quadrature nodes and compare it to the manufactured:\n\nu_quad = V_d2d * f + D_b2d * œÉ\ner_quad = u_quad - map(q -> u‚Çë(q.coords), Œ©_quad)\nprintln(\"maximum error at all quadrature nodes: \", norm(er_quad, Inf))\nnothing #hide\n\nLastly, let us visualize the solution and the error on the mesh nodes using quadrature_to_node_vals:\n\nnodes = Inti.nodes(Œ©_msh)\nu_nodes = Inti.quadrature_to_node_vals(Œ©_quad, u_quad)\ner = u_nodes - map(u‚Çë, nodes)\ncolorrange = extrema(u_nodes)\nfig = Figure(; size = (800, 300))\nax = Axis(fig[1, 1]; aspect = DataAspect())\nviz!(Œ©_msh; colorrange, color = u_nodes, interpolate = true)\ncb = Colorbar(fig[1, 2]; label = \"u\", colorrange)\n# plot error\nlog_er = log10.(abs.(er))\ncolorrange = extrema(log_er)\ncolormap = :inferno\nax = Axis(fig[1, 3]; aspect = DataAspect())\nviz!(Œ©_msh; colorrange, colormap, color = log_er, interpolate = true)\ncb = Colorbar(fig[1, 4]; label = \"log‚ÇÅ‚ÇÄ|u - u‚Çë|\", colormap, colorrange)\nfig #hide","category":"section"},{"location":"tutorials/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"note: Important points covered in this tutorial\nCreate a domain and its accompanying mesh\nSolve a basic boundary integral equation\nVisualize the solution\n\nThis first tutorial will be a guided tour through the basic steps of setting up a boundary integral equation and solving it using Inti.jl.","category":"section"},{"location":"tutorials/getting_started/#Mathematical-formulation","page":"Getting started","title":"Mathematical formulation","text":"We will consider the classic Helmholtz scattering problem in 2D, and solve it using a direct boundary integral formulation. More precisely, letting Omega subset mathbbR^2 be a bounded domain, and denoting by Gamma = partial Omega its boundary, we will solve the following Helmholtz problem:\n\nbeginaligned\n    Delta u + k^2 u  = 0 quad textin quad mathbbR^2 setminus overlineOmega\n    partial_nu u = g quad texton quad Gamma\n    sqrtr left( fracpartial upartial r - i k u right) = o(1) quad textas quad r = boldsymbolx to infty\nendaligned\n\nwhere g is the given boundary datum, nu is the outward unit normal to Gamma, and k is the constant wavenumber. The last condition is the Sommerfeld radiation condition, and is required to ensure the uniqueness of the solution; physically, it means that the solution sought should radiate energy towards infinity.","category":"section"},{"location":"tutorials/getting_started/#PDE,-geometry,-and-mesh","page":"Getting started","title":"PDE, geometry, and mesh","text":"The first step is to define the PDE under consideration:\n\nusing Inti\nInti.stack_weakdeps_env!() # shortcut to add all dependencies \n# PDE\nk = 2œÄ\nop = Inti.Helmholtz(; dim = 2, k)\n\nNext, we generate the geometry of the problem. For this tutorial, we will manually create parametric curves representing the boundary of the domain using the parametric_curve function:\n\nusing StaticArrays # for SVector\n# Create the geometry as the union of a kite and a circle\nkite = Inti.parametric_curve(0.0, 1.0; labels = [\"kite\"]) do s\n    return SVector(2.5 + cos(2œÄ * s[1]) + 0.65 * cos(4œÄ * s[1]) - 0.65, 1.5 * sin(2œÄ * s[1]))\nend\ncircle = Inti.parametric_curve(0.0, 1.0; labels = [\"circle\"]) do s\n    return SVector(cos(2œÄ * s[1]), sin(2œÄ * s[1]))\nend\nŒì = kite ‚à™ circle\n\nInti.jl expects the parametrization of the curve to be a function mapping scalars to points in space represented by SVectors (defined in the StaticArrays package). The labels argument is optional, and can be used to identify the different parts of the boundary. The Domain object Œì represents the boundary of the geometry, and can be used to create a mesh:\n\n# Create a mesh for the geometry\nmsh = Inti.meshgen(Œì; meshsize = 2œÄ / k / 10)\n\nTo visualize the mesh, we can load Meshes.jl and one of Makie's backends:\n\nusing Meshes, GLMakie\nviz(msh; segmentsize = 3, axis = (aspect = DataAspect(), ), figure = (; size = (400,300)))","category":"section"},{"location":"tutorials/getting_started/#Quadrature","page":"Getting started","title":"Quadrature","text":"Once the mesh is created, we can define a quadrature to be used in the discretization of the integral operators:\n\n# Create a quadrature\nQ = Inti.Quadrature(msh; qorder = 5)\nnothing # hide\n\nA Quadrature is simply a collection of QuadratureNode objects:\n\nQ[1]\n\nIn the constructor above we specified a quadrature order of 5, and Inti.jl internally picked a ReferenceQuadrature suitable for the specified order; for finer control, a quadrature rule can be specified directly.","category":"section"},{"location":"tutorials/getting_started/#Integral-operators","page":"Getting started","title":"Integral operators","text":"To continue, we need to reformulate the Helmholtz problem as a boundary integral equation. Among the plethora of options, we will use in this tutorial a simple direct formulation, which uses Green's third identity to relate the values of u and partial_nu u on Gamma:\n\n    -fracu(boldsymbolx)2 + Du(boldsymbolx) = Spartial_nu u(boldsymbolx) quad boldsymbolx in Gamma\n\nHere S and D are the single- and double-layer operators, formally defined as:\n\n    Ssigma(boldsymbolx) = int_Gamma G(boldsymbolx boldsymboly) sigma(boldsymboly)  mathrmds(boldsymboly) quad\n    Dsigma(boldsymbolx) = int_Gamma fracpartial Gpartial nu_boldsymboly(boldsymbolx boldsymboly) sigma(boldsymboly)  mathrmds(boldsymboly)\n\nwhere\n\nG(boldsymbolx boldsymboly) = fraci4 H^(1)_0(kboldsymbolx -\nboldsymboly)\n\nis the fundamental solution of the Helmholtz equation, with H^(1)_0 being the Hankel function of the first kind. Note that G is singular when boldsymbolx = boldsymboly, and therefore the numerical discretization of S and D requires special care.\n\nTo approximate S and D, we can proceed as follows:\n\nS, D = Inti.single_double_layer(;\n    op,\n    target = Q,\n    source = Q,\n    compression = (method = :none,),\n    correction = (method = :dim,),\n)\nnothing # hide\n\nMuch of the complexity involved in the numerical computation is hidden in the function above; later in the tutorials we will discuss in more details the options available for the compression and correction methods, as well as how to define custom kernels and operators. For now, it suffices to know that S and D are matrix-like objects that can be used to solve the boundary integral equation. For that, we need to provide the boundary data g.\n\ntip: Fast algorithms\nPowered by external libraries, Inti.jl supports several acceleration methods for matrix-vector multiplication. See the compression methods section for more details. Note that in such cases only the matrix-vector product may not be available, and therefore iterative solvers such as GMRES are required for the solution of the resulting linear systems.","category":"section"},{"location":"tutorials/getting_started/#Source-term-and-solution","page":"Getting started","title":"Source term and solution","text":"We are interested in the scattered field u produced by an incident plane wave u_i = e^i k boldsymbold cdot boldsymbolx, where boldsymbold is a unit vector denoting the direction of the plane wave. Assuming that the total field u_t = u_i + u satisfies a homogenous Neumann condition on Gamma, and that the scattered field u satisfies the Sommerfeld radiation condition, we can write the boundary condition as:\n\n    partial_nu u = -partial_nu u_i quad boldsymbolx in Gamma\n\nWe can thus solve the boundary integral equation to find u on Gamma:\n\nusing LinearAlgebra\n# define the incident field and compute its normal derivative\nŒ∏ = 0\nd = SVector(cos(Œ∏), sin(Œ∏))\ng = map(Q) do q\n    # normal derivative of e^{ik*d‚Éó‚ãÖx}\n    x, ŒΩ = q.coords, q.normal\n    return -im * k * exp(im * k * dot(x, d)) * dot(d, ŒΩ)\nend ## Neumann trace on boundary\nu = (-I / 2 + D) \\ (S * g) # Dirichlet trace on boundary\nnothing # hide\n\nnote: Iterating over a quadrature\nIn computing g above, we used map to evaluate the incident field at   all quadrature nodes. When iterating over Q, the iterator returns a   QuadratureNode, and not simply the coordinate   of the quadrature node. This is so that we can access additional   information, such as the normal vector, at the quadrature node.","category":"section"},{"location":"tutorials/getting_started/#Integral-representation-and-visualization","page":"Getting started","title":"Integral representation and visualization","text":"Now that we know both the Dirichlet and Neumann data on the boundary, we can use Green's representation formula, i.e.,\n\n    mathcalDu(boldsymbolr) - mathcalSpartial_nu u(boldsymbolr) = begincases\n        u(boldsymbolr)  textif  boldsymbolr in mathbbR^2 setminus overlineOmega\n        0  textif  boldsymbolr in Omega\n    endcases\n\nwhere mathcalD and mathcalS are the double- and single-layer potentials defined as:\n\n    mathcalSsigma(boldsymbolr) = int_Gamma G(boldsymbolr boldsymboly) sigma(boldsymboly)  mathrmds(boldsymboly) quad\n    mathcalDsigma(boldsymbolr) = int_Gamma fracpartial Gpartial nu_boldsymboly(boldsymbolr boldsymboly) sigma(boldsymboly)  mathrmds(boldsymboly)\n\nto compute the solution u in the domain:\n\nùíÆ, ùíü = Inti.single_double_layer_potential(; op, source = Q)\nu‚Çõ = x -> ùíü[u](x) - ùíÆ[g](x)\n\nTo wrap things up, let's visualize the scattered field:\n\nxx = yy = range(-5; stop = 5, length = 100)\nU = map(u‚Çõ, Iterators.product(xx, yy))\nUi = map(x -> exp(im*k*dot(x, d)), Iterators.product(xx, yy))\nUt = Ui + U\nfig, ax, hm = heatmap(\n    xx,\n    yy,\n    real(Ut);\n    colormap = :inferno,\n    interpolate = true,\n    axis = (aspect = DataAspect(), xgridvisible = false, ygridvisible = false),\n)\nviz!(msh; segmentsize = 2)\nColorbar(fig[1, 2], hm; label = \"real(u)\")\nfig # hide","category":"section"},{"location":"tutorials/getting_started/#Accuracy-check","page":"Getting started","title":"Accuracy check","text":"The scattering example above does not provide an easy way to check the accuracy of the solution. To do so, we can manufacture an exact solution and compare it to the solution obtained numerically, as illustrated below:\n\n# build an exact solution\nG = Inti.SingleLayerKernel(op)\ndG = Inti.DoubleLayerKernel(op)\nxs = map(Œ∏ -> 0.5 * rand() * SVector(cos(Œ∏), sin(Œ∏)), 2œÄ * rand(10))\ncs = rand(ComplexF64, length(xs))\nu‚Çë  = q -> sum(c * G(x, q) for (x, c) in zip(xs, cs))\n‚àÇ‚Çôu = q -> sum(c * dG(x, q) for (x, c) in zip(xs, cs))\ng  = map(‚àÇ‚Çôu, Q) \nu = (-I / 2 + D) \\ (S * g)\nu‚Çõ = x -> ùíü[u](x) - ùíÆ[g](x)\npts = [5*SVector(cos(Œ∏), sin(Œ∏)) for Œ∏ in range(0, 2œÄ, length = 100)]\ner = norm(u‚Çõ.(pts) - u‚Çë.(pts), Inf)\nprintln(\"maximum error on circle of radius 5: $er\")","category":"section"},{"location":"#Inti","page":"Home","title":"Inti","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: codecov) (Image: Aqua)\n\nInti.jl is a Julia library for the numerical solution of boundary and volume integral equations. It offers routines for assembling and solving the linear systems that result from applying the Nystr√∂m discretization method. Designed for flexibility and efficiency, the package currently supports the following features:\n\nSpecialized integration routines for computing singular and nearly-singular integrals.\nIntegrated support for acceleration routines, including the Fast Multipole Method (FMM) and Hierarchical Matrices, by wrapping external libraries.\nPredefined kernels and integral operators for partial differential equations (PDEs) commonly found in mathematical physics (e.g. Laplace, Helmholtz, Stokes).\nSupport for complex geometries in 2D and 3D, either through native parametric representations or by importing mesh files from external sources.\nEfficient construction of complex integral operators from simpler ones through lazy composition.","category":"section"},{"location":"#Installing-Julia","page":"Home","title":"Installing Julia","text":"Download Julia from julialang.org, or use juliaup installer. We recommend using the latest stable version of Julia, although Inti.jl should work with >=v1.9.","category":"section"},{"location":"#Installing-Inti.jl","page":"Home","title":"Installing Inti.jl","text":"Inti.jl is registered in the Julia General registry and can be installed by launching a Julia REPL and typing the following command:\n\n]add Inti\n\nAlternatively, one can install the latest version of Inti.jl from the main branch using:\n\nusing Pkg; Pkg.add(;url = \"https://github.com/IntegralEquations/Inti.jl\", rev = \"main\")\n\nChange rev if a different branch or a specific commit hash is desired.","category":"section"},{"location":"#Installing-weak-dependencies","page":"Home","title":"Installing weak dependencies","text":"Inti.jl comes with a set of optional dependencies that can be installed on demand. These provide additional features which can be useful in certain scenarios (e.g. visualization, meshing, acceleration). For convenience, Inti.jl provides the stack_weakdeps_env! function to install all the weak dependencies at once:\n\nusing Inti\nInti.stack_weakdeps_env!(; verbose = false, update = true)\n\nNote that the first time you run this command, it may take a while to download and compile the dependencies. Subsequent runs will be faster. If preferred,  extensions can be manually controlled by Pkg.adding the desired packages from the list above.","category":"section"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"Inti.jl can be used to solve a variety of linear partial differential equations by recasting them as integral equations. The general workflow for solving a problem consists of the following steps:\n\n    underbracefboxGeometry rightarrow fboxMesh_textbfpre-processing rightarrow colorredfboxSolver rightarrow underbracefboxVisualization_textbfpost-processing\n\nGeometry: Define the domain of interest using simple shapes (e.g., circles, rectangles) or more complex CAD models.\nMesh: Create a mesh to approximate the geometry. The mesh is used to define a quadrature and discretize the boundary integral equation.\nSolver: With a mesh and an accompanying quadrature, Inti.jl's routines provide ways to assemble and solve the system of equations arising from the discretization of the integral operators. The core of the library lies in service of this step.\nVisualization: Visualize the solution using a plotting library such as Makie.jl, or export it to a file for further analysis.\n\nAs a simple example illustrating the steps above, consider an interior Laplace problem, in two dimensions, with Dirichlet boundary conditions:\n\nbeginaligned\nDelta u = 0 quad textin  Omega \nu = g quad texton  Gamma\nendaligned\n\nwhere Omega subset mathbbR^2 is a sufficiently smooth domain, and Gamma = partial Omega its boundary. A boundary integral reformulation can be achieved by e.g. searching for the solution u in the form of a single-layer potential:\n\nu(boldsymbolr) = int_Gamma G(boldsymbolrboldsymboly)sigma(boldsymboly)  mathrmdGamma(boldsymboly)\n\nwhere sigma  Gamma to mathbbR is an unknown density function, and G is the fundamental solution of the Laplace equation. This ansatz is, by construction, an exact solution to the PDE on Omega. Imposing the boundary condition on Gamma leads to the following integral equation:\n\n    int_Gamma G(boldsymbolxboldsymboly)sigma(boldsymboly)  mathrmdGamma(boldsymboly) = g(boldsymbolx) quad forall boldsymbolx in Gamma\n\nExpressing the problem above in Inti.jl looks like this:\n\nusing Inti, LinearAlgebra, StaticArrays\n# a parametric curve given by a function f : [0,1] ‚Üí Œì ‚äÇ R^2. \ngeo = Inti.parametric_curve(0, 1) do s\n    SVector(0.25, 0.0) + SVector(cos(2œÄ * s) + 0.65 * cos(4œÄ * s[1]) - 0.65, 1.5 * sin(2œÄ * s))\nend\nŒì = Inti.Domain(geo)\n# mesh and quadrature\nmsh = Inti.meshgen(Œì; meshsize = 0.1)\nQ = Inti.Quadrature(msh; qorder = 5)\n# integral operators\nop = Inti.Laplace(;dim=2)\nS, _ = Inti.single_double_layer(;\n    op, \n    target = Q,\n    source = Q,\n)\n# manufacture a harmonic function (exact solution) and take its trace on Œì\nu‚Çë = x -> x[1] + x[2] + x[1]*x[2] + x[1]^2 - x[2]^2  - 2 * log(norm(x .- SVector(-0.5, -1.5)))\ng = map(q -> u‚Çë(q.coords), Q) # value at quad nodes\n# solve for œÉ\nœÉ = S \\ g\n# use the single-layer potential to evaluate the solution\nùíÆ, ùíü = Inti.single_double_layer_potential(; op, source = Q)\nu‚Çï = x -> ùíÆ[œÉ](x)\npt = SVector(0.5, 0.1)\n\nThe function u‚Çï is now a numerical approximation of the solution to the Laplace equation, and can be evaluated at any point in the domain:\n\npt = SVector(0.5, 0.1)\nprintln(\"Exact value at $pt:   \", u‚Çë(pt))\nprintln(\"Approx. value at $pt: \", u‚Çï(pt))\n\nIf we care about the solution on the entire domain, we can visualize it using:\n\nusing Meshes, GLMakie # trigger the loading of some Inti extensions\nxx = yy = range(-2, 2, length = 100)\nfig = Figure(; size = (600,300))\ninside = x -> Inti.isinside(x, Q) \nopts = (xlabel = \"x\", ylabel = \"y\", aspect = DataAspect())\nax1 = Axis(fig[1, 1]; title = \"Exact solution\", opts...)\nh1 = heatmap!(ax1, xx,yy,(x, y) -> inside((x,y)) ? u‚Çë((x,y)) : NaN)\nviz!(msh; segmentsize = 3)\ncb = Colorbar(fig[1, 3], h1, size = 20, height = 200)\nax2 = Axis(fig[1, 2]; title = \"Approx. solution\", opts...)\nh2 = heatmap!(ax2, xx,yy, (x, y) -> inside((x,y)) ? u‚Çï((x,y)) : NaN, colorrange = cb.limits[])\nviz!(msh; segmentsize = 3)\nfig # hide\n\ninfo: Formulation of the problem as an integral equation\nGiven a PDE and boundary conditions, there are often many ways to recast the problem as an integral equation, and the choice of formulation plays an important role in the unique solvability, efficiency, and accuracy of the numerical solution. Inti.jl provides a flexible framework for experimenting with different formulations, but it is up to the user to choose the most appropriate one for their problem.\n\nWhile the example above is a simple one, Inti.jl can handle significantly more complex problems involving multiple domains, heterogeneous coefficients, vector-valued PDEs, and three-dimensional geometries. The best way to dive deeper into Inti.jl's capabilities is the tutorials section. More advanced usage can be found in the examples section.","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"There are several ways to contribute to Inti.jl:\n\nReporting bugs: If you encounter a bug, please open an issue on the GitHub. If possible, please include a minimal working example that reproduces the problem.\nExamples: If you have a cool example that showcases Inti.jl's capabilities, consider submitting a PR to add it to the examples section.\nContributing code: If you would like to contribute code to Inti.jl, please fork the repository and submit a pull request. Feel free to open a draft PR early in the development process to get feedback on your changes.\nFeature requests: If you have an idea for a new feature or improvement, we would love to hear about it.\nDocumentation: If you find any part of the documentation unclear or incomplete, please let us know. Or even better, submit a PR with the improved documentation.","category":"section"}]
}

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Compression methods · Inti.jl</title><meta name="title" content="Compression methods · Inti.jl"/><meta property="og:title" content="Compression methods · Inti.jl"/><meta property="twitter:title" content="Compression methods · Inti.jl"/><meta name="description" content="Documentation for Inti.jl."/><meta property="og:description" content="Documentation for Inti.jl."/><meta property="twitter:description" content="Documentation for Inti.jl."/><meta property="og:url" content="https://IntegralEquations.github.io/Inti.jl/tutorials/compression_methods/"/><meta property="twitter:url" content="https://IntegralEquations.github.io/Inti.jl/tutorials/compression_methods/"/><link rel="canonical" href="https://IntegralEquations.github.io/Inti.jl/tutorials/compression_methods/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Inti.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../geo_and_meshes/">Geometry and meshes</a></li><li><a class="tocitem" href="../integral_operators/">Integral operators</a></li><li><a class="tocitem" href="../layer_potentials/">Layer potentials</a></li><li class="is-active"><a class="tocitem" href>Compression methods</a><ul class="internal"><li><a class="tocitem" href="#Dense-matrix"><span>Dense matrix</span></a></li><li><a class="tocitem" href="#Hierarchical-matrix"><span>Hierarchical matrix</span></a></li><li><a class="tocitem" href="#Fast-multipole-method"><span>Fast multipole method</span></a></li><li><a class="tocitem" href="#Tips-on-choosing-a-compression-method"><span>Tips on choosing a compression method</span></a></li></ul></li><li><a class="tocitem" href="../correction_methods/">Correction methods</a></li><li><a class="tocitem" href="../solvers/">Linear solvers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../pluto-examples/toy_example/">Toy example</a></li><li><a class="tocitem" href="../../pluto-examples/helmholtz_scattering/">Helmholtz scattering</a></li><li><a class="tocitem" href="../../pluto-examples/poisson/">Poisson problem</a></li><li><a class="tocitem" href="../../examples/heat_equation/">Heat equation</a></li><li><a class="tocitem" href="../../examples/stokes_drag/">Stokes drag</a></li><li><a class="tocitem" href="../../examples/crack_elasticity/">Elastic crack</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../docstrings/">Docstrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Compression methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Compression methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl/blob/main/docs/src/tutorials/compression_methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Compression-methods"><a class="docs-heading-anchor" href="#Compression-methods">Compression methods</a><a id="Compression-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Compression-methods" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Important points covered in this tutorial</header><div class="admonition-body"><ul><li>Overview of the compression methods available in Inti.jl</li><li>Details and limitations of the various compression methods</li><li>Guideline on how to choose a compression method</li></ul></div></div><p>Inti.jl wraps several external libraries providing acceleration routines for integral operators. In general, acceleration routines have the signature <code>assemble_*(iop, args...; kwargs...)</code>, and take an <a href="../../docstrings/#Inti.IntegralOperator"><code>IntegralOperator</code></a> as a first argument. They return a new object that represents a compressed version of the operator. The following methods are available:</p><ul><li><a href="../../docstrings/#Inti.assemble_matrix-Tuple{Inti.IntegralOperator}"><code>assemble_matrix</code></a>: create a dense <code>Matrix</code> representation of the integral operator. Not really a compression method, but useful for debugging and small problems.</li><li><a href="../../docstrings/#Inti.assemble_hmatrix-Tuple"><code>assemble_hmatrix</code></a>: assemble a hierarchical matrix representation of the operator using the <a href="https://github.com/IntegralEquations/HMatrices.jl"><code>HMatrices</code></a> library.</li><li><a href="../../docstrings/#Inti.assemble_fmm-Tuple{Inti.IntegralOperator}"><code>assemble_fmm</code></a>: return a <code>LinearMap</code> object that represents the operator using the fast multipole method. This method is powered by the <a href="https://github.com/flatironinstitute/fmm2d/"><code>FMM2D</code></a>, <a href="https://github.com/zgimbutas/fmmlib2d"><code>FMMLIB2D</code></a> and <a href="https://fmm3d.readthedocs.io"><code>FMM3D</code></a> libraries, and is only available for certain kernels.</li></ul><div class="admonition is-warning"><header class="admonition-header">Singular kernels</header><div class="admonition-body"><p>Acceleration methods do not correct for singular or nearly-singular interactions. When the underlying kernel is singular, a <em>correction</em> is usually necessary in order to obtain accurate results (see the section on <a href="../correction_methods/#Correction-methods">correction methods</a> for more details).</p></div></div><p>To demonstrate the use of compression methods, we will compress the single-layer operator for the Helmholtz equation on an ellipsoid. While compression methods may not be necessary for small problems like this, they become essential – and often indispensable – for tackling larger-scale problems efficiently.</p><pre><code class="language-julia hljs">using Inti
using LinearAlgebra
# define the quadrature
geo = Inti.GeometricEntity(&quot;ellipsoid&quot;)
Ω = Inti.Domain(geo)
Γ = Inti.boundary(Ω)
Q = Inti.Quadrature(Γ; meshsize = 0.4, qorder = 5)
# create the operator
op = Inti.Helmholtz(; dim = 3, k = 2π)
K = Inti.SingleLayerKernel(op)
Sop = Inti.IntegralOperator(K, Q, Q)
x = rand(ComplexF64, length(Q))
rtol = 1e-8</code></pre><p>In what follows we compress <code>Sop</code> using the different methods available.</p><h2 id="Dense-matrix"><a class="docs-heading-anchor" href="#Dense-matrix">Dense matrix</a><a id="Dense-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Dense-matrix" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.assemble_matrix-tutorials-compression_methods" href="#Inti.assemble_matrix-tutorials-compression_methods"><code>Inti.assemble_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assemble_matrix(iop::IntegralOperator; threads = true)</code></pre><p>Assemble a dense matrix representation of an <code>IntegralOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/01bfe63e02dd4155ee0873c2eb94b4fe7615bbbb/src/nystrom.jl#L98-L102">source</a></section></article><p>Typically used for small problems, the dense matrix representation converts the <code>IntegralOperator</code> into a <code>Matrix</code> object. The underlying type of the <code>Matrix</code> is determined by the <code>eltype</code> of the <code>IntegralOperator</code>, and depends on the inferred type of the kernel. Here is how <code>assemble_matrix</code> can be used:</p><pre><code class="language-julia hljs">Smat = Inti.assemble_matrix(Sop; threads=true)
er = norm(Sop * x - Smat * x, Inf) / norm(Sop * x, Inf)
println(&quot;Forward map error: $er&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Forward map error: 3.673697599776313e-15</code></pre><p>Since the returned object is plain Julia <code>Matrix</code>, it can be used with any of the linear algebra routines available in Julia (e.g. <code>\</code>, <code>lu</code>, <code>qr</code>, <code>*</code>, etc.)</p><h2 id="Hierarchical-matrix"><a class="docs-heading-anchor" href="#Hierarchical-matrix">Hierarchical matrix</a><a id="Hierarchical-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Hierarchical-matrix" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.assemble_hmatrix-tutorials-compression_methods" href="#Inti.assemble_hmatrix-tutorials-compression_methods"><code>Inti.assemble_hmatrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assemble_hmatrix(iop[; atol, rank, rtol, eta])</code></pre><p>Assemble an H-matrix representation of the discretized integral operator <code>iop</code> using the <code>HMatrices.jl</code> library.</p><p>See the documentation of <a href="https://github.com/IntegralEquations/HMatrices.jl"><code>HMatrices</code></a> for more details on usage and other keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/01bfe63e02dd4155ee0873c2eb94b4fe7615bbbb/src/nystrom.jl#L157-L166">source</a></section></article><p>The hierarchical matrix representation is a compressed representation of the underlying operator; as such, it takes a tolerance parameter that determines the relative error of the compression. Here is an example of how to use the <code>assemble_hmatrix</code> method to compress the previous problem:</p><pre><code class="language-julia hljs">using HMatrices
Shmat = Inti.assemble_hmatrix(Sop; rtol = 1e-8)
er = norm(Smat * x - Shmat * x, Inf) / norm(Smat * x, Inf)
println(&quot;Forward map error: $er&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Forward map error: 1.131003609464934e-8</code></pre><p>Note that <code>HMatrices</code> are said to be <em>kernel-independent</em>, meaning that they efficiently compress a wide range of integral operators provided they satisfy a certain asymptotic smoothness criterion (see e.g. [<a href="../../references/#bebendorf2008hierarchical">3</a>, <a href="../../references/#hackbusch2015hierarchical">4</a>]).</p><p>The <code>HMatrix</code> object can be used to solve linear systems, both iteratively through e.g. GMRES, or directly using an <code>LU</code> factorization.</p><h2 id="Fast-multipole-method"><a class="docs-heading-anchor" href="#Fast-multipole-method">Fast multipole method</a><a id="Fast-multipole-method-1"></a><a class="docs-heading-anchor-permalink" href="#Fast-multipole-method" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Inti.assemble_fmm-tutorials-compression_methods" href="#Inti.assemble_fmm-tutorials-compression_methods"><code>Inti.assemble_fmm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assemble_fmm(iop; rtol)</code></pre><p>Set up a 2D or 3D FMM for evaluating the discretized integral operator <code>iop</code> associated with the <code>op</code>. In 2D the <code>FMM2D</code> or <code>FMMLIB2D</code> library is used (whichever was most recently loaded) while in 3D <code>FMM3D</code> is used.</p><div class="admonition is-warning"><header class="admonition-header">FMMLIB2D</header><div class="admonition-body"><p>FMMLIB2D does <em>no</em> checking for if the targets and sources coincide, and will return <code>Inf</code> values if <code>iop.target !== iop.source</code>, but there is a point <code>x ∈ iop.target</code> such that <code>x ∈ iop.source</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IntegralEquations/Inti.jl/blob/01bfe63e02dd4155ee0873c2eb94b4fe7615bbbb/src/nystrom.jl#L126-L137">source</a></section></article><p>The fast multipole method (FMM) is an acceleration technique based on an analytic multipole expansion of the kernel in the integral operator [<a href="../../references/#rokhlin1985rapid">5</a>, <a href="../../references/#greengard1987fast">6</a>]. It provides a very memory-efficient and fast way to evaluate certain types of integral operators. Here is how <code>assemble_fmm</code> can be used:</p><pre><code class="language-julia hljs">using FMM3D
Sfmm = Inti.assemble_fmm(Sop; rtol = 1e-8)
er = norm(Sop * x - Sfmm * x, Inf) / norm(Sop * x, Inf)
println(&quot;Forward map error: $er&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Forward map error: 4.2690530890435815e-15</code></pre><h2 id="Tips-on-choosing-a-compression-method"><a class="docs-heading-anchor" href="#Tips-on-choosing-a-compression-method">Tips on choosing a compression method</a><a id="Tips-on-choosing-a-compression-method-1"></a><a class="docs-heading-anchor-permalink" href="#Tips-on-choosing-a-compression-method" title="Permalink"></a></h2><p>The choice of compression method depends on the problem at hand, as well as on the available hardware. Here is a rough guide on how to choose a compression:</p><ol><li>For small problems (say less than 5k degrees of freedom), use the dense matrix representation. It is the simplest and most straightforward method, and does not require any additional packages. It is also the most accurate since it does not introduce any additional approximation errors.</li><li>If the integral operator is supported by the <code>assemble_fmm</code>, and if an iterative solver is acceptable, use it. The FMM is a very efficient method for certain types of kernels, and can handle problems with up to a few million degrees of freedom on a laptop.</li><li>If the kernel is not supported by <code>assemble_fmm</code>, if iterative solvers are not an option, or if the system needs solution for many right-hand sides, use the <code>assemble_hmatrix</code> method. It is a very general method that can handle a wide range of kernels, and although assembling the <code>HMatrix</code> can be time and memory consuming (the complexity is still log-linear in the DOFs for many kernels of interest, but the constants can be large), the resulting <code>HMatrix</code> object is very efficient to use. For example, the forward map is usually significantly faster than the one obtained through <code>assemble_fmm</code>.</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../layer_potentials/">« Layer potentials</a><a class="docs-footer-nextpage" href="../correction_methods/">Correction methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Saturday 3 May 2025 19:42">Saturday 3 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

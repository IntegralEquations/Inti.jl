<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Layer potentials ¬∑ Inti.jl</title><meta name="title" content="Layer potentials ¬∑ Inti.jl"/><meta property="og:title" content="Layer potentials ¬∑ Inti.jl"/><meta property="twitter:title" content="Layer potentials ¬∑ Inti.jl"/><meta name="description" content="Documentation for Inti.jl."/><meta property="og:description" content="Documentation for Inti.jl."/><meta property="twitter:description" content="Documentation for Inti.jl."/><meta property="og:url" content="https://IntegralEquations.github.io/Inti.jl/tutorials/layer_potentials/"/><meta property="twitter:url" content="https://IntegralEquations.github.io/Inti.jl/tutorials/layer_potentials/"/><link rel="canonical" href="https://IntegralEquations.github.io/Inti.jl/tutorials/layer_potentials/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Inti.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../geo_and_meshes/">Geometry and meshes</a></li><li><a class="tocitem" href="../integral_operators/">Integral operators</a></li><li class="is-active"><a class="tocitem" href>Layer potentials</a><ul class="internal"><li><a class="tocitem" href="#Integral-potentials"><span>Integral potentials</span></a></li><li><a class="tocitem" href="#Direct-evaluation-of-layer-potentials"><span>Direct evaluation of layer potentials</span></a></li><li><a class="tocitem" href="#Near-field-correction-of-layer-potentials"><span>Near-field correction of layer potentials</span></a></li></ul></li><li><a class="tocitem" href="../compression_methods/">Compression methods</a></li><li><a class="tocitem" href="../correction_methods/">Correction methods</a></li><li><a class="tocitem" href="../solvers/">Linear solvers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../pluto-examples/toy_example/">Toy example</a></li><li><a class="tocitem" href="../../pluto-examples/helmholtz_scattering/">Helmholtz scattering</a></li><li><a class="tocitem" href="../../pluto-examples/poisson/">Poisson problem</a></li><li><a class="tocitem" href="../../examples/heat_equation/">Heat equation</a></li><li><a class="tocitem" href="../../examples/stokes_drag/">Stokes drag</a></li><li><a class="tocitem" href="../../examples/crack_elasticity/">Elastic crack</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../docstrings/">Docstrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Layer potentials</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Layer potentials</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/IntegralEquations/Inti.jl/blob/main/docs/src/tutorials/layer_potentials.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Layer-potentials"><a class="docs-heading-anchor" href="#Layer-potentials">Layer potentials</a><a id="Layer-potentials-1"></a><a class="docs-heading-anchor-permalink" href="#Layer-potentials" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Important points covered in this tutorial</header><div class="admonition-body"><ul><li>Nearly singular evaluation of layer potentials</li><li>Creating a smooth domain with splines using <a href="https://gmsh.info/">Gmsh</a>&#39;s API</li><li>Plotting values on a mesh</li></ul></div></div><p>In this tutorial we focus on <strong>evaluating</strong> the layer potentials given a source density. This is a common post-processing task in boundary integral equation methods, and while most of it is straightforward, some subtleties arise when the target points are close to the boundary (nearly-singular integrals).</p><h2 id="Integral-potentials"><a class="docs-heading-anchor" href="#Integral-potentials">Integral potentials</a><a id="Integral-potentials-1"></a><a class="docs-heading-anchor-permalink" href="#Integral-potentials" title="Permalink"></a></h2><p><a href="../../docstrings/#Inti.IntegralPotential"><code>IntegralPotential</code></a> represent the following mathematical objects:</p><p class="math-container">\[\mathcal{P}[\sigma](\boldsymbol{r}) = \int_{\Gamma} K(\boldsymbol{r}, \boldsymbol{r&#39;}) \sigma(\boldsymbol{r&#39;}) \, d\boldsymbol{r&#39;}\]</p><p>where <span>$K$</span> is the kernel of the operator, <span>$\Gamma$</span> is the source&#39;s boundary, <span>$\boldsymbol{r} \not \in \Gamma$</span> is a target point, and <span>$\sigma$</span> is the source density.</p><p>Here is a simple example of how to create a kernel representing a Laplace double-layer potential:</p><pre><code class="language-julia hljs">using Inti, StaticArrays, LinearAlgebra
# define a kernel function
function K(target,source)
    r = Inti.coords(target) - Inti.coords(source)
    ny = Inti.normal(source)
    return 1 / (2œÄ * norm(r)^2) * dot(r, ny)
end
# define a domain
Œì = Inti.parametric_curve(s -&gt; SVector(cos(2œÄ * s), sin(2œÄ * s)), 0, 1) |&gt; Inti.Domain
# and a quadrature of Œì
Q = Inti.Quadrature(Œì; meshsize = 0.1, qorder = 5)
ùíÆ = Inti.IntegralPotential(K, Q)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Inti.IntegralPotential{typeof(Main.K), Inti.Quadrature{2, Float64}}(Main.K,  Quadrature with 189 quadrature nodes)</code></pre><p>If we have a source density <span>$\sigma$</span>, defined on the quadrature nodes of <span>$\Gamma$</span>, we can create a function that evaluates the layer potential at an arbitrary point:</p><pre><code class="language-julia hljs">œÉ = map(q -&gt; 1.0, Q)
u = ùíÆ[œÉ]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">#256 (generic function with 1 method)</code></pre><p><code>u</code> is now an anonymous function that evaluates the layer potential at any point:</p><pre><code class="language-julia hljs">r = SVector(0.1, 0.2)
u(r)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-0.9999999999999991</code></pre><p>Although we created the single-layer potential for the Laplace kernel manually, it is often more convenient to use the <code>single_layer_potential</code> when working with a supported PDE, e.g.:</p><pre><code class="language-julia hljs">op = Inti.Laplace(; dim = 2)
ùíÆ, ùíü = Inti.single_double_layer_potential(; op, source = Q)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Inti.IntegralPotential{Inti.SingleLayerKernel{Float64, Inti.Laplace{2}}, Inti.Quadrature{2, Float64}}(Inti.SingleLayerKernel{Float64, Inti.Laplace{2}}(Laplace operator in 2 dimensions: -Œîu),  Quadrature with 189 quadrature nodes), Inti.IntegralPotential{Inti.DoubleLayerKernel{Float64, Inti.Laplace{2}}, Inti.Quadrature{2, Float64}}(Inti.DoubleLayerKernel{Float64, Inti.Laplace{2}}(Laplace operator in 2 dimensions: -Œîu),  Quadrature with 189 quadrature nodes))</code></pre><p>creates the single and double layer potentials for the Laplace equation in 2D.</p><h2 id="Direct-evaluation-of-layer-potentials"><a class="docs-heading-anchor" href="#Direct-evaluation-of-layer-potentials">Direct evaluation of layer potentials</a><a id="Direct-evaluation-of-layer-potentials-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-evaluation-of-layer-potentials" title="Permalink"></a></h2><p>We now show how to evaluate the layer potentials of an exact solution on a mesh created through the Gmsh API. Do to so, let us first define the PDE:g</p><pre><code class="language-julia hljs">using Inti, StaticArrays, LinearAlgebra, Meshes, GLMakie, Gmsh
# define the PDE
k = 4œÄ
op = Inti.Helmholtz(; dim = 2, k)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Helmholtz operator in 2 dimensions: -Œîu - k¬≤u</code></pre><p>We will now use the <a href="../../docstrings/#Inti.gmsh_curve-Tuple"><code>gmsh_curve</code></a> function to create a smooth domain of a kite using splines:</p><pre><code class="language-julia hljs">gmsh.initialize()
meshsize = 2œÄ / k / 4
kite = Inti.gmsh_curve(0, 1; meshsize) do s
    SVector(0.25, 0.0) + SVector(cos(2œÄ * s) + 0.65 * cos(4œÄ * s[1]) - 0.65, 1.5 * sin(2œÄ * s))
end
cl = gmsh.model.occ.addCurveLoop([kite])
surf = gmsh.model.occ.addPlaneSurface([cl])
gmsh.model.occ.synchronize()
gmsh.model.mesh.generate(2)
msh = Inti.import_mesh(; dim = 2)
gmsh.finalize()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Info    : Meshing 1D...
Info    : Meshing curve 1 (BSpline)
Info    : Done meshing 1D (Wall 0.0111834s, CPU 0.011182s)
Info    : Meshing 2D...
Info    : Meshing surface 1 (Plane, Frontal-Delaunay)
Info    : Done meshing 2D (Wall 0.0619105s, CPU 0.061899s)
Info    : 505 nodes 911 elements</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The GMSH API is a powerful tool to create complex geometries and meshes directly from Julia (the <code>gmsh_curve</code> function above is just a simple wrapper around some spline functionality). For more information, see the <a href="https://gmsh.info/doc/texinfo/gmsh.html#Gmsh-application-programming-interface">official documentation</a>.</p></div></div><p>We can visualize the triangular mesh using:</p><pre><code class="language-julia hljs">using Meshes, GLMakie
# extract the domain Œ© from the mesh entities
ents = Inti.entities(msh)
Œ© = Inti.Domain(e-&gt;Inti.geometric_dimension(e) == 2, ents)
viz(msh[Œ©]; showsegments = true, axis = (aspect = DataAspect(), ))</code></pre><img src="cdad3605.png" alt="Example block output"/><p>For the purpose of testing the accuracy of the layer potential evaluation, we will construct an exact solution of the Helmholtz equation on the interior domain and plot it:</p><pre><code class="language-julia hljs"># construct an exact interior solution as a sum of random plane waves
dirs  = [SVector(cos(Œ∏), sin(Œ∏)) for Œ∏ in 2œÄ*rand(10)]
coefs = rand(ComplexF64, 10)
u  =  (x)   -&gt; sum(c*exp(im*k*dot(x, d)) for (c,d) in zip(coefs, dirs))
du =  (x,ŒΩ) -&gt; sum(c*im*k*dot(d, ŒΩ)*exp(im*k*dot(x, d)) for (c,d) in zip(coefs, dirs))
# plot the exact solution
Œ©_msh = view(msh, Œ©)
target = Inti.nodes(Œ©_msh)
viz(Œ©_msh; showsegments = false, axis = (aspect = DataAspect(), ), color = real(u.(target)))</code></pre><img src="7be34fbe.png" alt="Example block output"/><p>Since <code>u</code> satisfies the Helmholtz equation, we know that the following representation holds:</p><p class="math-container">\[u(\boldsymbol{r}) = \mathcal{S}[\gamma_1 u](\boldsymbol{r}) - \mathcal{D}[\gamma_0 u](\boldsymbol{r}), \quad \boldsymbol{r} \in \Omega\]</p><p>where <span>$\gamma_0 u$</span> and <span>$\gamma_1 u$</span> are the respective Dirichlet and Neumann traces of <span>$u$</span>, and <span>$\mathcal{S}$</span> and <span>$\mathcal{D}$</span> are the respective single and double layer potentials over <span>$\Gamma := \partial \Omega$</span>.</p><p>Let&#39;s compare next the exact solution with the layer potential evaluation, based on a quadrature of <span>$\Gamma$</span>:</p><pre><code class="language-julia hljs">Œì = Inti.boundary(Œ©)
Q = Inti.Quadrature(view(msh,Œì); qorder = 5)
# evaluate the layer potentials
ùíÆ, ùíü = Inti.single_double_layer_potential(; op, source = Q)
Œ≥‚ÇÄu = map(q -&gt; u(q.coords), Q)
Œ≥‚ÇÅu = map(q -&gt; du(q.coords, q.normal), Q)
u‚Çï = x -&gt; ùíÆ[Œ≥‚ÇÅu](x) - ùíü[Œ≥‚ÇÄu](x)
# plot the error on the target nodes
er_log10 = log10.(abs.(u.(target) - u‚Çï.(target)))
colorrange = extrema(er_log10)
fig, ax, pl = viz(Œ©_msh;
    color = er_log10,
    colormap = :viridis,
    colorrange,
    axis = (aspect = DataAspect(),),
    interpolate=true
)
Colorbar(fig[1, 2]; label = &quot;log‚ÇÅ‚ÇÄ(error)&quot;, colorrange)
fig</code></pre><img src="a2ace768.png" alt="Example block output"/><p>We see a common pattern of potential evaluation: the error is small away from the boundary, but grows near it. This is due to the nearly-singular nature of the layer potential integrals, which can be mitigated by using a correction method that accounts for the singularity of the kernel as <span>$\boldsymbol{r} \to \Gamma$</span>.</p><h2 id="Near-field-correction-of-layer-potentials"><a class="docs-heading-anchor" href="#Near-field-correction-of-layer-potentials">Near-field correction of layer potentials</a><a id="Near-field-correction-of-layer-potentials-1"></a><a class="docs-heading-anchor-permalink" href="#Near-field-correction-of-layer-potentials" title="Permalink"></a></h2><p>There are two cases where the direct evaluation of layer potentials is not recommended:</p><ol><li>When the target point is close to the boundary (nearly-singular integrals).</li><li>When evaluation at many target points is desired (computationally burdensome)and take advantage of an acceleration routine.</li></ol><p>In such contexts, it is recommended to use the <code>single_double_layer</code> function (alternately, one can directly assemble an <code>IntegralOperator</code>) with a correction, for the first case, and/or a compression (acceleration) method, for the latter case, as appropriate. Here is an example of how to use the FMM acceleration with a near-field correction to evaluate the layer potentials::</p><pre><code class="language-julia hljs">using FMM2D
S, D = Inti.single_double_layer(; op, target, source = Q,
    compression = (method = :fmm, tol = 1e-12),
    correction = (method = :dim, target_location = :inside, maxdist = 0.2)
)
er_log10_cor = log10.(abs.(S*Œ≥‚ÇÅu - D*Œ≥‚ÇÄu - u.(target)))
colorrange = extrema(er_log10) # use scale without correction
fig = Figure(resolution = (800, 400))
ax1 = Axis(fig[1, 1], aspect = DataAspect(), title = &quot;Naive evaluation&quot;)
viz!(Œ©_msh; color = er_log10, colormap = :viridis, colorrange,interpolate=true)
ax2 = Axis(fig[1, 2], aspect = DataAspect(), title = &quot;Nearfield correction&quot;)
viz!(Œ©_msh; color = er_log10_cor, colormap = :viridis, colorrange, interpolate=true)
Colorbar(fig[1, 3]; label = &quot;log‚ÇÅ‚ÇÄ(error)&quot;, colorrange)
fig</code></pre><img src="a6041c2b.png" alt="Example block output"/><p>As can be seen, the near-field correction significantly reduces the error near the boundary, making if feasible to evaluate the layer potential near <span>$\Gamma$</span> if necessary.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../integral_operators/">¬´ Integral operators</a><a class="docs-footer-nextpage" href="../compression_methods/">Compression methods ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Saturday 3 May 2025 19:42">Saturday 3 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

var documenterSearchIndex = {"docs":
[{"location":"tutorials/solvers/#Linear-solvers","page":"Linear solvers","title":"Linear solvers","text":"","category":"section"},{"location":"tutorials/solvers/","page":"Linear solvers","title":"Linear solvers","text":"warning: Work in progress\nThis tutorial is still a work in progress. We will update it with more details and examples in the future.","category":"page"},{"location":"tutorials/solvers/","page":"Linear solvers","title":"Linear solvers","text":"Inti.jl does not provide its own linear solvers, but relies on external libraries such as IterativeSolvers.jl or the LinearAlgebra standard library for the solving the linear systems that arise in the discretization of integral equations.","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"J.-C. Nédélec. Acoustic and electromagnetic equations: integral representations for harmonic problems. Vol. 144 (Springer, 2001).\n\n\n\nD. Colton and R. Kress. Integral equation methods in scattering theory (SIAM, 2013).\n\n\n\nM. Bebendorf. Hierarchical matrices (Springer, 2008).\n\n\n\nW. Hackbusch and others. Hierarchical matrices: algorithms and analysis. Vol. 49 (Springer, 2015).\n\n\n\nV. Rokhlin. Rapid solution of integral equations of classical potential theory. Journal of computational physics 60, 187–207 (1985).\n\n\n\nL. Greengard and V. Rokhlin. A fast algorithm for particle simulations. Journal of computational physics 73, 325–348 (1987).\n\n\n\nM. Guiggiani, G. Krishnasamy, T. J. Rudolphi and F. J. Rizzo. A general algorithm for the numerical solution of hypersingular boundary              integral equations. Journal of Applied Mechanics 59, 604–614 (1992).\n\n\n\nL. M. Faria, C. Pérez-Arancibia and M. Bonnet. General-purpose kernel regularization of boundary integral equations via density interpolation. Computer Methods in Applied Mechanics and Engineering 378, 113703 (2021).\n\n\n\nF.-K. Hebeker. Efficient boundary element methods for three-dimensional exterior viscous flows. Numerical Methods for Partial Differential Equations 2, 273–297 (1986).\n\n\n\nM. Bonnet. Boundary Integral Equations Methods for Solids and Fluids (Wiley, 1995).\n\n\n\nT. G. Anderson, M. Bonnet, L. M. Faria and C. Pérez-Arancibia. Fast, high-order numerical evaluation of volume potentials via polynomial density interpolation. Journal of Computational Physics, 113091 (2024).\n\n\n\n","category":"page"},{"location":"tutorials/layer_potentials/#Layer-potentials","page":"Layer potentials","title":"Layer potentials","text":"","category":"section"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"note: Important points covered in this tutorial\nNearly singular evaluation of layer potentials\nCreating a smooth domain with splines using Gmsh's API\nPlotting values on a mesh","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"In this tutorial we focus on evaluating the layer potentials given a source density. This is a common post-processing task in boundary integral equation methods, and while most of it is straightforward, some subtleties arise when the target points are close to the boundary (nearly-singular integrals).","category":"page"},{"location":"tutorials/layer_potentials/#Integral-potentials","page":"Layer potentials","title":"Integral potentials","text":"","category":"section"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"IntegralPotential represent the following mathematical objects:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"mathcalPsigma(boldsymbolr) = int_Gamma K(boldsymbolr boldsymbolr) sigma(boldsymbolr)  dboldsymbolr","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"where K is the kernel of the operator, Gamma is the source's boundary, boldsymbolr not in Gamma is a target point, and sigma is the source density.","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"Here is a simple example of how to create a kernel representing a Laplace double-layer potential:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"using Inti, StaticArrays, LinearAlgebra\n# define a kernel function\nfunction K(target,source)\n    r = Inti.coords(target) - Inti.coords(source)\n    ny = Inti.normal(source)\n    return 1 / (2π * norm(r)^2) * dot(r, ny)\nend\n# define a domain\nΓ = Inti.parametric_curve(s -> SVector(cos(2π * s), sin(2π * s)), 0, 1) |> Inti.Domain\n# and a quadrature of Γ\nQ = Inti.Quadrature(Γ; meshsize = 0.1, qorder = 5)\n𝒮 = Inti.IntegralPotential(K, Q)","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"If we have a source density sigma, defined on the quadrature nodes of Gamma, we can create a function that evaluates the layer potential at an arbitrary point:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"σ = map(q -> 1.0, Q)\nu = 𝒮[σ]","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"u is now an anonymous function that evaluates the layer potential at any point:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"r = SVector(0.1, 0.2)\n@assert u(r) ≈ -1 # hide\nu(r)","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"Although we created the single-layer potential for the Laplace kernel manually, it is often more convenient to use the single_layer_potential when working with a supported PDE, e.g.:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"op = Inti.Laplace(; dim = 2)\n𝒮, 𝒟 = Inti.single_double_layer_potential(; op, source = Q)","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"creates the single and double layer potentials for the Laplace equation in 2D.","category":"page"},{"location":"tutorials/layer_potentials/#Direct-evaluation-of-layer-potentials","page":"Layer potentials","title":"Direct evaluation of layer potentials","text":"","category":"section"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"We now show how to evaluate the layer potentials of an exact solution on a mesh created through the Gmsh API. Do to so, let us first define the PDE:g","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"using Inti, StaticArrays, LinearAlgebra, Meshes, GLMakie, Gmsh\n# define the PDE\nk = 4π\nop = Inti.Helmholtz(; dim = 2, k)","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"We will now use the gmsh_curve function to create a smooth domain of a kite using splines:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"gmsh.initialize()\nmeshsize = 2π / k / 4\nkite = Inti.gmsh_curve(0, 1; meshsize) do s\n    SVector(0.25, 0.0) + SVector(cos(2π * s) + 0.65 * cos(4π * s[1]) - 0.65, 1.5 * sin(2π * s))\nend\ncl = gmsh.model.occ.addCurveLoop([kite])\nsurf = gmsh.model.occ.addPlaneSurface([cl])\ngmsh.model.occ.synchronize()\ngmsh.model.mesh.generate(2)\nmsh = Inti.import_mesh(; dim = 2)\ngmsh.finalize()","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"tip: Tip\nThe GMSH API is a powerful tool to create complex geometries and meshes directly from Julia (the gmsh_curve function above is just a simple wrapper around some spline functionality). For more information, see the official documentation.","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"We can visualize the triangular mesh using:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"using Meshes, GLMakie\n# extract the domain Ω from the mesh entities\nents = Inti.entities(msh)\nΩ = Inti.Domain(e->Inti.geometric_dimension(e) == 2, ents)\nviz(msh[Ω]; showsegments = true, axis = (aspect = DataAspect(), ))","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"For the purpose of testing the accuracy of the layer potential evaluation, we will construct an exact solution of the Helmholtz equation on the interior domain and plot it:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"# construct an exact interior solution as a sum of random plane waves\ndirs  = [SVector(cos(θ), sin(θ)) for θ in 2π*rand(10)]\ncoefs = rand(ComplexF64, 10)\nu  =  (x)   -> sum(c*exp(im*k*dot(x, d)) for (c,d) in zip(coefs, dirs))\ndu =  (x,ν) -> sum(c*im*k*dot(d, ν)*exp(im*k*dot(x, d)) for (c,d) in zip(coefs, dirs))\n# plot the exact solution\nΩ_msh = view(msh, Ω)\ntarget = Inti.nodes(Ω_msh)\nviz(Ω_msh; showsegments = false, axis = (aspect = DataAspect(), ), color = real(u.(target)))","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"Since u satisfies the Helmholtz equation, we know that the following representation holds:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"u(boldsymbolr) = mathcalSgamma_1 u(boldsymbolr) - mathcalDgamma_0 u(boldsymbolr) quad boldsymbolr in Omega","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"where gamma_0 u and gamma_1 u are the respective Dirichlet and Neumann traces of u, and mathcalS and mathcalD are the respective single and double layer potentials over Gamma = partial Omega.","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"Let's compare next the exact solution with the layer potential evaluation, based on a quadrature of Gamma:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"Γ = Inti.boundary(Ω)\nQ = Inti.Quadrature(view(msh,Γ); qorder = 5)\n# evaluate the layer potentials\n𝒮, 𝒟 = Inti.single_double_layer_potential(; op, source = Q)\nγ₀u = map(q -> u(q.coords), Q)\nγ₁u = map(q -> du(q.coords, q.normal), Q)\nuₕ = x -> 𝒮[γ₁u](x) - 𝒟[γ₀u](x)\n# plot the error on the target nodes\ner_log10 = log10.(abs.(u.(target) - uₕ.(target)))\ncolorrange = extrema(er_log10)\nfig, ax, pl = viz(Ω_msh;\n    color = er_log10,\n    colormap = :viridis,\n    colorrange,\n    axis = (aspect = DataAspect(),),\n    interpolate=true\n)\nColorbar(fig[1, 2]; label = \"log₁₀(error)\", colorrange)\nfig","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"We see a common pattern of potential evaluation: the error is small away from the boundary, but grows near it. This is due to the nearly-singular nature of the layer potential integrals, which can be mitigated by using a correction method that accounts for the singularity of the kernel as boldsymbolr to Gamma.","category":"page"},{"location":"tutorials/layer_potentials/#Near-field-correction-of-layer-potentials","page":"Layer potentials","title":"Near-field correction of layer potentials","text":"","category":"section"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"There are two cases where the direct evaluation of layer potentials is not recommended:","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"When the target point is close to the boundary (nearly-singular integrals).\nWhen evaluation at many target points is desired (computationally burdensome)and take advantage of an acceleration routine.","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"In such contexts, it is recommended to use the single_double_layer function (alternately, one can directly assemble an IntegralOperator) with a correction, for the first case, and/or a compression (acceleration) method, for the latter case, as appropriate. Here is an example of how to use the FMM acceleration with a near-field correction to evaluate the layer potentials::","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"using FMM2D\nS, D = Inti.single_double_layer(; op, target, source = Q,\n    compression = (method = :fmm, tol = 1e-12),\n    correction = (method = :dim, target_location = :inside, maxdist = 0.2)\n)\ner_log10_cor = log10.(abs.(S*γ₁u - D*γ₀u - u.(target)))\ncolorrange = extrema(er_log10) # use scale without correction\nfig = Figure(resolution = (800, 400))\nax1 = Axis(fig[1, 1], aspect = DataAspect(), title = \"Naive evaluation\")\nviz!(Ω_msh; color = er_log10, colormap = :viridis, colorrange,interpolate=true)\nax2 = Axis(fig[1, 2], aspect = DataAspect(), title = \"Nearfield correction\")\nviz!(Ω_msh; color = er_log10_cor, colormap = :viridis, colorrange, interpolate=true)\nColorbar(fig[1, 3]; label = \"log₁₀(error)\", colorrange)\nfig","category":"page"},{"location":"tutorials/layer_potentials/","page":"Layer potentials","title":"Layer potentials","text":"As can be seen, the near-field correction significantly reduces the error near the boundary, making if feasible to evaluate the layer potential near Gamma if necessary.","category":"page"},{"location":"tutorials/integral_operators/#Integral-operators","page":"Integral operators","title":"Integral operators","text":"","category":"section"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"note: Important points covered in this tutorial\nDefine layer potentials and the four integral operators of Calderón calculus\nConstruct block operators\nSet up a custom kernel","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"A central piece of integral equation methods is the efficient and accurate computation of integral operators. In the first part of this tutorial we will cover how to assemble and manipulate the four integral operators of Calderón calculus, namely the single-layer, double-layer, hypersingular, and adjoint operators [1, 2], for some predefined kernels in Inti.jl. In the second part we will show how to extend the package to handle custom kernels.","category":"page"},{"location":"tutorials/integral_operators/#Predefined-kernels-and-integral-operators","page":"Integral operators","title":"Predefined kernels and integral operators","text":"","category":"section"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"To simplify the construction of integral operators for some commonly used PDEs, Inti.jl defines a few AbstractDifferentialOperators types. For each of these PDEs, the package provides a SingleLayerKernel, DoubleLayerKernel, HyperSingularKernel, and AdjointDoubleLayerKernel that can be used to construct the corresponding kernel functions, e.g.:","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"using Inti, StaticArrays, LinearAlgebra\nop = Inti.Helmholtz(; dim = 2, k = 2π)\nG   = Inti.SingleLayerKernel(op)","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"Typically, we are not interested in the kernels themselves, but in the integral operators they define. Two functions, single_double_layer and adj_double_layer_hypersingular, are provided as a high-level syntax to construct the four integral operators of Calderón calculus:","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"Γ = Inti.parametric_curve(s -> SVector(cos(s), sin(s)), 0, 2π) |> Inti.Domain\nQ = Inti.Quadrature(Γ; meshsize = 0.1, qorder = 7)\nS, D = Inti.single_double_layer(; \n    op, \n    target = Q, \n    source = Q, \n    compression = (method = :none,), \n    correction = (method = :dim,)\n)\nK, N = Inti.adj_double_layer_hypersingular(; \n    op, \n    target = Q, \n    source = Q, \n    compression = (method = :none,), \n    correction = (method = :dim,)\n)\nnothing # hide","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"Much goes on under the hood in the function above, and the sections on correction and compression methods will provide more details on the options available. The important thing to keep in mind is that S, D, K, and N are discrete approximations of the following (linear) operators:","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"beginaligned\n    Ssigma(boldsymbolx) = int_Gamma G(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly quad \n    Dsigma(boldsymbolx) = mathrmpv int_Gamma fracpartial Gpartial nu_boldsymboly(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly \n    Ksigma(boldsymbolx) =  mathrmpv int_Gamma fracpartial Gpartial nu_boldsymbolx(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly quad\n    Nsigma(boldsymbolx) = mathrmfp int_Gamma fracpartial^2 Gpartial nu_boldsymbolx partial nu_boldsymboly(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly\nendaligned","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"The actual type of S, D, K, and N depends on the compression and correction methods. In the simple case above, these are simply matrices:","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"@assert all(T -> T == Matrix{ComplexF64}, map(typeof, (S, D, K, N))) # hide\nmap(typeof, (S, D, K, N))","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"If we turn on a compression method, such as :fmm, the types may change into something different:","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"using FMM2D # will load the extension\nSfmm, Dfmm = Inti.single_double_layer(; \n    op, \n    target = Q, \n    source = Q, \n    compression = (method = :fmm, tol = 1e-10), \n    correction = (method = :dim,)\n)\nKfmm, Nfmm = Inti.adj_double_layer_hypersingular(; \n    op, \n    target = Q, \n    source = Q, \n    compression = (method = :fmm, tol = 1e-10), \n    correction = (method = :dim, )\n)\ntypeof(Sfmm)","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"This is because the FMM method is used to approximate the matrix-vector in a matrix-free way: the only thing guaranteed is that S and D can be applied to a vector:","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"x = map(q -> cos(q.coords[1] + q.coords[2]), Q)\n@assert norm(Sfmm*x - S*x, Inf) / norm(S*x, Inf) < 1e-8 # hide\nnorm(Sfmm*x - S*x, Inf)","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"The Sfmm object above in fact combines two linear maps:","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"Sfmm","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"The FunctionMap computes a matrix-vector by performing a function call to the FMM2D library. The WrappedMap accounts for a sparse matrix used to correct for singular and nearly singular interactions. These two objects are added lazily using LinearMaps.","category":"page"},{"location":"tutorials/integral_operators/#Operator-composition","page":"Integral operators","title":"Operator composition","text":"","category":"section"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"Effortlessly and efficiently composing operators is a powerful abstraction for integral equations, as it allows for the construction of complex systems from simple building blocks. To show this, let us show how to construct the Calderón projectors:","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"beginaligned\nH = beginbmatrix\n    -D  S \n    -N  K\nendbmatrix \nendaligned","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"As is well-known [1, Theorem 3.1.3], the operators C_pm = I2 pm H are the projectors (i.e. C_pm^2 = C_pm):","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"using LinearMaps\n# create the block operator\nH = [-Dfmm Sfmm; -Nfmm Kfmm]\nC₊ = I / 2 + H\nC₋ = I / 2 - H\n# define two density functions on Γ\nu = map(q -> cos(q.coords[1] + q.coords[2]), Q)\nv = map(q-> q.coords[1], Q)\nx = [u; v]\n# compute the error in the projector identity\ne₊ = norm(C₊*(C₊*x) - C₊*x, Inf)\ne₋ = norm(C₋*(C₋*x) - C₋*x, Inf)\n@assert e₊ < 1e-4 && e₋ < 1e-4 # hide\nprintln(\"projection error for C₊: $e₊\")\nprintln(\"projection error for C₋: $e₋\")","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"We see that the error in the projector identity is small, as expected. Note that such compositions are not limited to the Calderón projectors, and can be used e.g. to construct the combined field integral equation (CFIE), or to compose a formulation with an operator preconditioner.","category":"page"},{"location":"tutorials/integral_operators/#Custom-kernels","page":"Integral operators","title":"Custom kernels","text":"","category":"section"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"So far we have focused on problems for which Inti.jl provides predefined kernels, and used the high-level syntax of e.g. single_double_layer to construct the integral operators. We will now dig into the details of how to set up a custom kernel function, and how to build an integral operator from it.","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"note: Integral operators coming from PDEs\nIf the integral operator of interest arises from a PDE, it is recommended to define a new AbstractDifferentialOperator type, and implement the required methods for SingleLayerKernel, DoubleLayerKernel, AdjointDoubleLayerKernel, and HyperSingularKernel. This will enable the use of the high-level syntax for constructing boundary integral operators, as well as the use of the compression and correction methods specific to integral operators arising from PDEs.","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"For the sake of simplicity, let us consider the following kernel representing the half-space Dirichlet Green function for Helmholtz's equation in 2D:","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"    G_D(boldsymbolx boldsymboly) = fraci4 H^(1)_0(k boldsymbolx - boldsymboly) - fraci4 H^(1)_0(k boldsymbolx - boldsymboly^*)","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"where boldsymboly^* = (y_1 -y_2). We can define this kernel as a","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"using SpecialFunctions # for hankelh1\nfunction helmholtz_kernel(target, source, k)\n    x, y  = Inti.coords(target), Inti.coords(source)\n    yc = SVector(y[1], -y[2])\n    d, dc  = norm(x-y), norm(x-yc)\n    # the singularity at x = y needs to be handled separately, so just put a zero to avoid division by zero\n    d == 0 ? zero(ComplexF64) : im / 4 * ( hankelh1(0, k * d) - hankelh1(0, k * dc))\nend","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"Let us now consider the integral operator S defined by:","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"    Ssigma(boldsymbolx) = int_Gamma G_D(boldsymbolx boldsymboly) sigma(boldsymboly) mathrmd s_boldsymboly quad boldsymbolx in Gamma","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"We can represent S by an IntegralOperator type:","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"k = 50π\nλ = 2π/k\nmeshsize = λ / 10\ngeo = Inti.parametric_curve(s -> SVector(cos(s), 2 + sin(s)), 0, 2π)\nΓ = Inti.Domain(geo)\nmsh = Inti.meshgen(Γ; meshsize)\nQ = Inti.Quadrature(msh; qorder = 5)\n# create a local scope to capture `k`\nK = let k = k\n    (t,q) -> helmholtz_kernel(t,q,k)\nend\nSop = Inti.IntegralOperator(K, Q, Q)","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"note: Signature of custom kernels\nKernel functions passed to IntegralOperator should always take two arguments, target and source, which are both of QuadratureNode. This allows for extracting not only the coords of the nodes, but also the normal vector if needed (e.g. for double-layer or hypersingular kernels).","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"The approximation of Sop now involves two steps:","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"build a dense operator S₀ that efficiently computes the matrix-vector product Sop * x for any vector x\ncorrect for the inaccuracies of S₀ due to singular/nearly-singular interactions by adding to it a correction matrix δS","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"For the first step, we will use a hierarchical matrix:","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"using HMatrices\nS₀ = Inti.assemble_hmatrix(Sop; rtol = 1e-4)","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"The correction matrix δS will be constructed using adaptive_correction:","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"δS = Inti.adaptive_correction(Sop; rtol = 1e-4, maxdist = 3*meshsize)","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"How exactly one adds S₀ and δS to get the final operator depends on the intended usage. For instance, one can use the LinearMap type to simply add them lazily:","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"using LinearMaps\nS = LinearMap(S₀) + LinearMap(δS)","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"Or, one can add δS to S₀ to create a new object:","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"S = S₀ + δS","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"or if performance/memory is a concern, one may want to directly add δS to S₀ in-place:","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"axpy!(1.0, δS, S₀)","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"All of these should give an identical matrix-vector product, but the latter two allow e.g. for the use of direct solvers though an LU factorization.","category":"page"},{"location":"tutorials/integral_operators/","page":"Integral operators","title":"Integral operators","text":"warning: Limitations\nIntegral operators defined from custom kernel functions do not support all the features of the predefined ones. In particular, some singular integration methods (e.g. the Density Interpolation Method) and acceleration routines (e.g. Fast Multipole Method) used to correct for singular and nearly singular integral operators, and to accelerate the matrix vector products, are only available for specific kernels. Check the corrections and compression for more details concerning which methods are compatible with custom kernels.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"(Image: Pluto notebook)","category":"page"},{"location":"pluto-examples/helmholtz_scattering/#Helmholtz-scattering","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"","category":"section"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"note: Important points covered in this example\nCreating a geometry using the Gmsh API\nAssembling integral operators and integral potentials\nSetting up a sound-soft problem in both 2 and 3 spatial dimensions\nUsing GMRES to solve the linear system\nExporting the solution to Gmsh for visualization","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"In this tutorial we will show how to solve an acoustic scattering problem in the context of Helmholtz equation. We will focus on a smooth sound-soft obstacle for simplicity, and introduce along the way the necessary techniques used to handle some difficulties encountered. We will use various packages throughout this example (including of course Inti.jl); if they are not on your environment, you can install them using ] add <package> in the REPL.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"In the following section, we will provide a brief mathematical description of the problem (valid in both 2 and 3 dimensions). We will tackle the two-dimensional problem first, for which we do not need to worry much about performance issues (e.g. compressing the integral operators). Finally, we present a three-dimensional example, where we will use HMatrices.jl to compress the underlying integral operators.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/#Sound-soft-problem","page":"Helmholtz scattering","title":"Sound-soft problem","text":"","category":"section"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"This example concerns the sound-soft acoustic scattering problem. Mathematically, this means solving an exterior problem governed by Helmholtz equation (time-harmonic acoustics) with a Dirichlet boundary condition. More precisely, letting Omega subset mathbbR^d be a bounded domain, and denoting by Gamma = partial Omega its boundary, we wish to solve","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Delta u + k^2 u = 0 quad texton quad mathbbR^d setminus barOmega","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"subject to Dirichlet boundary conditions on Gamma","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"\tu(boldsymbolx) = g(boldsymbolx) quad textfor quad boldsymbolx in Gamma","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"and the Sommerfeld radiation condition at infinity","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"\tlim_boldsymbolx to infty boldsymbolx^(d-1)2 left( fracpartial upartial boldsymbolx - i k u right) = 0","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Here g is a (given) boundary datum, and k is the constant wavenumber.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"For simplicity, we will take Gamma circle/sphere, and focus on the plane-wave scattering problem. This means we will seek a solution u of the form u = u_s + u_i, where u_i is a known incident field, and u_s is the scattered field we wish to compute.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"note: Complex geometries\nThe main reason for focusing on such a simple example is twofold. First, it alleviates the complexities associated with the mesh generation. Second, since exact solutions are known for this problem (in the form of a series), it is easy to assess the accuracy of the solution obtained. In practice, you can use the same techniques to solve the problem on more complex geometries by providing a .msh file containing the mesh.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Using the theory of boundary integral equations, we can express u_s as","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"\tu_s(boldsymbolr) = mathcalDsigma(boldsymbolr) - i k mathcalSsigma(boldsymbolr)","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"where mathcalS is the so-called single layer potential, mathcalD is the double-layer potential, and sigma  Gamma to mathbbC is a surface density. This is an indirect formulation (because sigma is an auxiliary density, not necessarily physical) commonly referred to as a combined field formulation. Taking the limit mathbbR^d setminus bar Omega ni x to Gamma, it can be shown that the following equation holds on Gamma:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"\tleft( fracmathrmI2 + mathrmD - i k mathrmS right)sigma = g","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"where mathrmI is the identity operator, and mathrmS and mathrmD are the single- and double-layer operators. This is the combined field integral equation that we will solve. The boundary data g is obtained by applying the sound-soft condition u=0 on Gamma, from which it readily follows that u_s = -u_i on Gamma.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We are now have the necessary background to solve this problem in both 2 and 3 spatial dimensions. Let's load Inti.jl as well as the required dependencies","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"using Inti\nusing LinearAlgebra\nusing StaticArrays\nusing Gmsh\nusing Meshes\nusing GLMakie\nusing SpecialFunctions\nusing GSL\nusing IterativeSolvers\nusing LinearMaps","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"and setup some of the (global) problem parameters:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"k = 4π\nλ = 2π / k\nqorder = 4 # quadrature order\ngorder = 2 # order of geometrical approximation\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/#Two-dimensional-scattering","page":"Helmholtz scattering","title":"Two-dimensional scattering","text":"","category":"section"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We will use Gmsh API for creating .msh file containing the desired geometry and mesh. Here is a function to mesh the circle:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"function gmsh_circle(; name, meshsize, order = 1, radius = 1, center = (0, 0))\n    try\n        gmsh.initialize()\n        gmsh.model.add(\"circle-mesh\")\n        gmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\n        gmsh.option.setNumber(\"Mesh.MeshSizeMin\", meshsize)\n        gmsh.model.occ.addDisk(center[1], center[2], 0, radius, radius)\n        gmsh.model.occ.synchronize()\n        gmsh.model.mesh.generate(1)\n        gmsh.model.mesh.setOrder(order)\n        gmsh.write(name)\n    finally\n        gmsh.finalize()\n    end\nend\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Let us now use gmsh_circle to create a circle.msh file. As customary in wave-scattering problems, we will choose a mesh size that is proportional to wavelength:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"name = joinpath(@__DIR__, \"circle.msh\")\nmeshsize = λ / 5\ngmsh_circle(; meshsize, order = gorder, name)","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We can now import the file and parse the mesh and domain information into Inti.jl using the import_mesh function:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Inti.clear_entities!() # empty the entity cache\nmsh = Inti.import_mesh(name; dim = 2)","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The code above will import the mesh with all of its geometrical entities. The dim=2 projects all points to two dimensions by ignoring the third component. To extract the domain Omega we need to filter the entities in the mesh; here we will simply filter them based on the geometric_dimension:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Ω = Inti.Domain(e -> Inti.geometric_dimension(e) == 2, Inti.entities(msh))","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"To solve our boundary integral equation usign a Nyström method, we actually need a quadrature of our curve/surface (and possibly the normal vectors at the quadrature nodes). Once a mesh is available, creating a quadrature object can be done via the Quadrature constructor, which requires passing a mesh of the domain that one wishes to generate a quadrature for:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Γ = Inti.boundary(Ω)\nΓ_msh = view(msh, Γ)\nQ = Inti.Quadrature(Γ_msh; qorder)\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"tip: Views of a mesh\nIn Inti.jl, you can use domain to create a view of a mesh containing only the elements in the domain. For example view(msh,Γ) will return an SubMesh type that you can use to iterate over the elements in the boundary of the disk without actually creating a new mesh. You can use msh[Γ], or collect(view(msh,Γ)) to create a new mesh containing only the elements and nodes in Γ.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The object Q now contains a quadrature (of order 4) that can be used to solve a boundary integral equation on Γ. As a sanity check, let's make sure integrating the function x->1 over Q gives an approximation to the perimeter:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"abs(Inti.integrate(x -> 1, Q) - 2π)","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"With the Quadrature constructed, we now can define discrete approximation to the integral operators mathrmS and mathrmD as follows:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"op = Inti.Helmholtz(; k, dim = 2)\nS, D = Inti.single_double_layer(;\n    op,\n    target = Q,\n    source = Q,\n    compression = (method = :none,),\n    correction = (method = :dim,),\n)\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"There are two well-known difficulties related to the discretization of the boundary integral operators S and D:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The kernel of the integral operator is not smooth, and thus specialized quadrature rules are required to accurately approximate the matrix entries for which the target and source point lie close (relative to some scale) to each other.\nThe underlying matrix is dense, and thus the storage and computational cost of the operator is prohibitive for large problems unless acceleration techniques such as Fast Multipole Methods or Hierarchical Matrices are employed.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Inti.jl tries to provide a modular and transparent interface for dealing with both of these difficulties, where the general approach for solving a BIE will be to first construct a (possible compressed) naive representation of the integral operator where singular and nearly-singular integrals are ignored, followed by a the creation of a (sparse) correction intended to account for such singular interactions. See single_double_layer for more details on the various options available.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We can now combine S and D to form the combined-field operator:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"L = I / 2 + D - im * k * S\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"where I is the identity matrix. Assuming an incident field along the x_1 direction of the form u_i =e^ikx_1, the right-hand side of the equation can be construted using:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"uᵢ = x -> exp(im * k * x[1]) # plane-wave incident field\nrhs = map(Q) do q\n    x = q.coords\n    return -uᵢ(x)\nend\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"note: Iterating over a quadrature\nIn computing rhs above, we used map to evaluate the incident field at all quadrature nodes. When iterating over Q, the iterator returns a QuadratureNode, and not simply the coordinate of the quadrature node. This is so that you can access additional information, such as the normal vector, at the quadrature node.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We can now solve the integral equation using e.g. the backslash operator:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"σ = L \\ rhs\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The variable σ contains the value of the approximate density at the quadrature nodes. To reconstruct a continuous approximation to the solution, we can use single_double_layer_potential to obtain the single- and double-layer potentials, and then combine them as follows:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"𝒮, 𝒟 = Inti.single_double_layer_potential(; op, source = Q)\nuₛ = x -> 𝒟[σ](x) - im * k * 𝒮[σ](x)\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The variable uₛ is an anonymous/lambda function representing the approximate scattered field.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"To assess the accuracy of the solution, we can compare it to the exact solution (obtained by separation of variables in polar coordinates):","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"function circle_helmholtz_soundsoft(pt; radius = 1, k, θin)\n    x = pt[1]\n    y = pt[2]\n    r = sqrt(x^2 + y^2)\n    θ = atan(y, x)\n    u = 0.0\n    r < radius && return u\n    c(n) = -exp(im * n * (π / 2 - θin)) * besselj(n, k * radius) / besselh(n, k * radius)\n    u = c(0) * besselh(0, k * r)\n    n = 1\n    while (abs(c(n)) > 1e-12)\n        u +=\n            c(n) * besselh(n, k * r) * exp(im * n * θ) +\n            c(-n) * besselh(-n, k * r) * exp(-im * n * θ)\n        n += 1\n    end\n    return u\nend\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Here is the maximum error on some points located on a circle of radius 2:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"uₑ = x -> circle_helmholtz_soundsoft(x; k, radius = 1, θin = 0) # exact solution\ner = maximum(0:0.01:2π) do θ\n    R = 2\n    x = (R * cos(θ), R * sin(θ))\n    return abs(uₛ(x) - uₑ(x))\nend\n@info \"maximum error = $er\"","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"As we can see, the error is quite small! Let's use Makie to visualize the solution in this simple (2d) example:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"xx = yy = range(-4; stop = 4, length = 200)\nvals =\n    map(pt -> Inti.isinside(pt, Q) ? NaN : real(uₛ(pt) + uᵢ(pt)), Iterators.product(xx, yy))\nfig, ax, hm = heatmap(\n    xx,\n    yy,\n    vals;\n    colormap = :inferno,\n    interpolate = true,\n    axis = (aspect = DataAspect(), xgridvisible = false, ygridvisible = false),\n)\nviz!(Γ_msh; color = :white, segmentsize = 5)\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"While here we simply used a heatmap to visualize the solution, more complex problems may require a mesh-based visualization, where we would first create a mesh for the places where we want to visualize the solution.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Before moving on to the 3D example let us simply mention that, besides the fact that an analytic solution was available for comparisson, there was nothing special about the unit disk (or the use of GMSH). We could have, for instance, replaced the disk by shapes created parametrically:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"let\n    # vertices of an equilateral triangle centered at the origin with a vertex at (0,1)\n    a, b, c = SVector(0, 1), SVector(sqrt(3) / 2, -1 / 2), SVector(-sqrt(3) / 2, -1 / 2)\n    function circle_f(center, radius)\n        return s -> center + radius * SVector(cospi(2 * s[1]), sinpi(2 * s[1]))\n    end\n    disk1 = Inti.parametric_curve(circle_f(a, 1 / 2), 0, 1)\n    disk2 = Inti.parametric_curve(circle_f(b, 1 / 2), 0, 1)\n    disk3 = Inti.parametric_curve(circle_f(c, 1 / 2), 0, 1)\n    Γ = disk1 ∪ disk2 ∪ disk3\n    msh = Inti.meshgen(Γ; meshsize)\n    Γ_msh = view(msh, Γ)\n    Q = Inti.Quadrature(Γ_msh; qorder)\n    S, D = Inti.single_double_layer(;\n        op,\n        target = Q,\n        source = Q,\n        compression = (method = :none,),\n        correction = (method = :dim,),\n    )\n    L = I / 2 + D - im * k * S\n    rhs = map(q -> -uᵢ(q.coords), Q)\n    σ = L \\ rhs\n    𝒮, 𝒟 = Inti.single_double_layer_potential(; op, source = Q)\n    uₛ = x -> 𝒟[σ](x) - im * k * 𝒮[σ](x)\n    vals = map(\n        pt -> Inti.isinside(pt, Q) ? NaN : real(uₛ(pt) + uᵢ(pt)),\n        Iterators.product(xx, yy),\n    )\n    colorrange = (-2, 2)\n    fig, ax, hm = heatmap(\n        xx,\n        yy,\n        vals;\n        colormap = :inferno,\n        colorrange,\n        interpolate = true,\n        axis = (aspect = DataAspect(), xgridvisible = false, ygridvisible = false),\n    )\n    viz!(Γ_msh; color = :black, segmentsize = 4)\n    Colorbar(fig[1, 2], hm)\n    fig\nend","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"note: Near-field evaluation\nIn the example above we employed a naive evaluation of the integral potentials, and therefore the computed solution is expected to become innacurate near the obstacles. See the layer potential tutorial for more information on how to correct for this.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/#Three-dimensional-scattering","page":"Helmholtz scattering","title":"Three-dimensional scattering","text":"","category":"section"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We now consider the same problem in 3D. Unlike the 2D case, assembling dense matrix representations of the integral operators quickly becomes unfeasiable as the problem size increases. Inti adds support for compressing the underlying linear operators by wrapping external libraries. In this example, we will rely on HMatrices.jl to handle the compression.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"The visualization is also more involved, and we will use the Gmsh API to create a not only a mesh of the scatterer, but also of a punctured plane where we will visualize the solution. Here is the function that setups up the mesh:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"function gmsh_sphere(; meshsize, order = gorder, radius = 1, visualize = false, name)\n    gmsh.initialize()\n    gmsh.model.add(\"sphere-scattering\")\n    gmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\n    gmsh.option.setNumber(\"Mesh.MeshSizeMin\", meshsize)\n    sphere_tag = gmsh.model.occ.addSphere(0, 0, 0, radius)\n    xl, yl, zl = -2 * radius, -2 * radius, 0\n    Δx, Δy = 4 * radius, 4 * radius\n    rectangle_tag = gmsh.model.occ.addRectangle(xl, yl, zl, Δx, Δy)\n    outDimTags, _ =\n        gmsh.model.occ.cut([(2, rectangle_tag)], [(3, sphere_tag)], -1, true, false)\n    gmsh.model.occ.synchronize()\n    gmsh.model.addPhysicalGroup(3, [sphere_tag], -1, \"omega\")\n    gmsh.model.addPhysicalGroup(2, [dt[2] for dt in outDimTags], -1, \"sigma\")\n    gmsh.model.mesh.generate(2)\n    gmsh.model.mesh.setOrder(order)\n    visualize && gmsh.fltk.run()\n    gmsh.option.setNumber(\"Mesh.SaveAll\", 1) # otherwise only the physical groups are saved\n    gmsh.write(name)\n    return gmsh.finalize()\nend\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"As before, lets write a file with our mesh, and import it into Inti.jl:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"name_sphere = joinpath(@__DIR__, \"sphere.msh\")\ngmsh_sphere(; meshsize = (λ / 5), order = gorder, name = name_sphere, visualize = false)\nmsh_3d = Inti.import_mesh(name_sphere; dim = 3)","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"tip: Tip\nIf you pass visualize=true to gmsh_sphere, it will open a window with the current model. This is done by calling gmsh.fltk.run(). Note that the main julia thread will be blocked until the window is closed.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Since we created physical groups in Gmsh, we can use them to extract the relevant domains Ω and Σ:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Ω_3d = Inti.Domain(e -> \"omega\" ∈ Inti.labels(e), Inti.entities(msh_3d))\nΣ_3d = Inti.Domain(e -> \"sigma\" ∈ Inti.labels(e), Inti.entities(msh_3d))\nΓ_3d = Inti.boundary(Ω_3d)\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We can now create a quadrature as before","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Γ_msh_3d = view(msh_3d, Γ_3d)\nQ_3d = Inti.Quadrature(Γ_msh_3d; qorder)\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"tip: Writing/reading a mesh from disk\nWriting and reading a mesh to/from disk can be time consuming. You can avoid doing so by using import_mesh without a file name to import the mesh from the current gmsh session without the need to write it to disk.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Next we assemble the integral operators, indicating that we wish to compress them using hierarchical matrices:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"using HMatrices\nop_3d = Inti.Helmholtz(; k, dim = 3)\nS_3d, D_3d = Inti.single_double_layer(;\n    op = op_3d,\n    target = Q_3d,\n    source = Q_3d,\n    compression = (method = :hmatrix, tol = 1e-4),\n    correction = (method = :dim,),\n)\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Here is how much memory it would take to store the dense representation of these matrices:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"mem = 2 * length(S_3d) * 16 / 1e9 # 16 bytes per complex number, 1e9 bytes per GB, two matrices\nprintln(\"memory required to store S and D: $(mem) GB\")","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Even for this simple example, the dense representation of the integral operators as matrix is already quite expensive!","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"note: Compression methods\nIt is worth mentioning that hierchical matrices are not the only way to compress such integral operators, and may in fact not even be the best for the problem at hand. For example, one could use a fast multipole method (FMM), which has a much lighter memory footprint. See the the tutorial on compression methods for more information.","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We will use the generalized minimal residual (GMRES) iterative solver, for the linear system. This requires us to define a linear operator L, approximating the combined-field operator, that supports the matrix-vector product. While it is possible to add two HMatrix objects to obtain a new HMatrix, this is somewhat more involved due to the addition of low-rank blocks (which requires a recompression). To keep things simple, we will use LinearMaps to lazily compose the operators:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"L_3d = I / 2 + LinearMap(D_3d) - im * k * LinearMap(S_3d)\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We can now solve the linear system using GMRES solver:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"rhs_3d = map(Q_3d) do q\n    x = q.coords\n    return -uᵢ(x)\nend\nσ_3d, hist = gmres(\n    L_3d,\n    rhs_3d;\n    log = true,\n    abstol = 1e-6,\n    verbose = false,\n    restart = 100,\n    maxiter = 100,\n)\n@show hist","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"As before, let us represent the solution using IntegralPotentials:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"𝒮_3d, 𝒟_3d = Inti.single_double_layer_potential(; op = op_3d, source = Q_3d)\nuₛ_3d = x -> 𝒟_3d[σ_3d](x) - im * k * 𝒮_3d[σ_3d](x)\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"To check the result, we compare against the exact solution obtained through a series:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"sphbesselj(l, r) = sqrt(π / (2r)) * besselj(l + 1 / 2, r)\nsphbesselh(l, r) = sqrt(π / (2r)) * besselh(l + 1 / 2, r)\nsphharmonic(l, m, θ, ϕ) = GSL.sf_legendre_sphPlm(l, abs(m), cos(θ)) * exp(im * m * ϕ)\nfunction sphere_helmholtz_soundsoft(xobs; radius = 1, k = 1, θin = 0, ϕin = 0)\n    x = xobs[1]\n    y = xobs[2]\n    z = xobs[3]\n    r = sqrt(x^2 + y^2 + z^2)\n    θ = acos(z / r)\n    ϕ = atan(y, x)\n    u = 0.0\n    r < radius && return u\n    function c(l, m)\n        return -4π * im^l * sphharmonic(l, -m, θin, ϕin) * sphbesselj(l, k * radius) /\n               sphbesselh(l, k * radius)\n    end\n    l = 0\n    for l = 0:60\n        for m = (-l):l\n            u += c(l, m) * sphbesselh(l, k * r) * sphharmonic(l, m, θ, ϕ)\n        end\n        l += 1\n    end\n    return u\nend\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We will compute the error on some point on the sphere of radius 2:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"uₑ_3d = (x) -> sphere_helmholtz_soundsoft(x; radius = 1, k = k, θin = π / 2, ϕin = 0)\ner_3d = maximum(1:100) do _\n    x̂ = rand(Inti.Point3D) |> normalize # an SVector of unit norm\n    x = 2 * x̂\n    return abs(uₛ_3d(x) - uₑ_3d(x))\nend\n@info \"error with correction = $er_3d\"","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"We see that, once again, the approximation is quite accurate. Let us now visualize the solution on the punctured plane (which we labeled as \"sigma\"). Since evaluating the integral representation of the solution at many points is expensive, we will use again use a method to accelerate the evaluation:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Σ_msh = view(msh_3d, Σ_3d)\ntarget = Inti.nodes(Σ_msh)\n\nS_viz, D_viz = Inti.single_double_layer(;\n    op = op_3d,\n    target,\n    source = Q_3d,\n    compression = (method = :hmatrix, tol = 1e-4),\n    # correction for the nearfield (for visual purposes, set to `:none` to disable)\n    correction = (method = :dim, maxdist = meshsize, target_location = :outside),\n)\n\nui_eval_msh = uᵢ.(target)\nus_eval_msh = D_viz * σ_3d - im * k * S_viz * σ_3d\nu_eval_msh = ui_eval_msh + us_eval_msh\nnothing #hide","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"Finalize, we use Meshes.viz to visualize the scattered field:","category":"page"},{"location":"pluto-examples/helmholtz_scattering/","page":"Helmholtz scattering","title":"Helmholtz scattering","text":"nv = length(Inti.nodes(Γ_msh_3d))\ncolorrange = extrema(real(u_eval_msh))\ncolormap = :inferno\nfig_3d = Figure(; size = (800, 500))\nax_3d = Axis3(fig_3d[1, 1]; aspect = :data)\nviz!(Γ_msh_3d; colorrange, colormap, color = zeros(nv), interpolate = true)\nviz!(Σ_msh; colorrange, colormap, color = real(u_eval_msh))\ncb = Colorbar(fig_3d[1, 2]; label = \"real(u)\", colormap, colorrange)\nfig_3d #hide","category":"page"},{"location":"pluto-examples/toy_example/","page":"Toy example","title":"Toy example","text":"(Image: Pluto notebook)","category":"page"},{"location":"pluto-examples/toy_example/#Toy-example","page":"Toy example","title":"Toy example","text":"","category":"section"},{"location":"pluto-examples/toy_example/","page":"Toy example","title":"Toy example","text":"All examples in Inti.jl are autogenerated by executing the make.jl script in the docs folder. The workflow uses Pluto.jl to generate markdown files passed to Documenter.jl. The original pluto notebook files are downloadable from the example's page.","category":"page"},{"location":"pluto-examples/toy_example/","page":"Toy example","title":"Toy example","text":"using Inti","category":"page"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/#Inti.Inti","page":"Docstrings","title":"Inti.Inti","text":"module Inti\n\nLibrary for solving integral equations using Nyström methods.\n\n\n\n\n\n","category":"module"},{"location":"docstrings/#Inti.COMPRESSION_METHODS","page":"Docstrings","title":"Inti.COMPRESSION_METHODS","text":"const COMPRESSION_METHODS = [:none, :hmatrix, :fmm]\n\nAvailable compression methods for the dense linear operators in Inti.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#Inti.CORRECTION_METHODS","page":"Docstrings","title":"Inti.CORRECTION_METHODS","text":"const CORRECTION_METHODS = [:none, :dim, :adaptive]\n\nAvailable correction methods for the singular and nearly-singular integrals in Inti.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#Inti.ENTITIES","page":"Docstrings","title":"Inti.ENTITIES","text":"const ENTITIES\n\nDictionary mapping EntityKey to GeometricEntity. Contains all entities created in a given session.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#Inti.SAME_POINT_TOLERANCE","page":"Docstrings","title":"Inti.SAME_POINT_TOLERANCE","text":"SAME_POINTS_TOLERANCE\n\nTwo points x and y are considerd the same if norm(x-y) ≤ SAME_POINT_TOLERANCE.\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#Inti.AbstractDifferentialOperator","page":"Docstrings","title":"Inti.AbstractDifferentialOperator","text":"abstract type AbstractDifferentialOperator{N}\n\nA partial differential operator in dimension N.\n\nAbstractDifferentialOperator types are used to define AbstractKernels related to fundamental solutions of differential operators.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.AbstractKernel","page":"Docstrings","title":"Inti.AbstractKernel","text":"abstract type AbstractKernel{T}\n\nA kernel functions K with the signature K(target,source)::T.\n\nSee also: SingleLayerKernel, DoubleLayerKernel, AdjointDoubleLayerKernel, HyperSingularKernel\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.AbstractMesh","page":"Docstrings","title":"Inti.AbstractMesh","text":"abstract type AbstractMesh{N,T}\n\nAn abstract mesh structure in dimension N with primite data of type T (e.g. Float64 for double precision representation).\n\nConcrete subtypes of AbstractMesh should implement ElementIterator for accessing the mesh elements.\n\nSee also: Mesh\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.AdjointDoubleLayerKernel","page":"Docstrings","title":"Inti.AdjointDoubleLayerKernel","text":"struct AdjointDoubleLayerKernel{T,Op} <: AbstractKernel{T}\n\nGiven an operator Op, construct its free-space adjoint double-layer kernel. This corresponds to the transpose(γ₁,ₓ[G]), where G is the SingleLayerKernel. For operators such as Laplace or Helmholtz, this is simply the normal derivative of the fundamental solution respect to the target variable.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.BlockArray","page":"Docstrings","title":"Inti.BlockArray","text":"struct BlockArray{T<:StaticArray,N,S} <: AbstractMatrix{T,N}\n\nA struct which behaves like an  Array{T,N}, but with the underlying data stored as a Matrix{S}, where S::Number = eltype(T) is the scalar type associated with T. This allows for the use of many blas routines under-the-hood, while providing a convenient interface for handling arrays over StaticArrays.\n\nusing StaticArrays\nT = SMatrix{2,2,Int,4}\nB = Inti.BlockArray{T}([i*j for i in 1:4, j in 1:4])\n\n# output\n\n2×2 Inti.BlockArray{SMatrix{2, 2, Int64, 4}, 2, Int64, 2}:\n [1 2; 2 4]  [3 4; 6 8]\n [3 6; 4 8]  [9 12; 12 16]\n\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.DimParameters","page":"Docstrings","title":"Inti.DimParameters","text":"struct DimParameters\n\nParameters associated with the density interpolation method used in bdim_correction.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Domain","page":"Docstrings","title":"Inti.Domain","text":"struct Domain\n\nRepresentation of a geometrical domain formed by a set of entities with the same geometric dimension. For basic set operations on domains are supported (union, intersection, difference, etc), and they all return a new Domain object.\n\nCalling keys(Ω) returns the set of EntityKeys that make up the domain; given a key, the underlying entities can be accessed with global_get_entity(key).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Domain-Tuple{Function, Any}","page":"Docstrings","title":"Inti.Domain","text":"Domain([f::Function,] keys)\n\nCreate a domain from a set of EntityKeys. Optionally, a filter function f can be passed to filter the entities.\n\nNote that all entities in a domain must have the same geometric dimension.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.Domain-Tuple{Function, Inti.AbstractMesh}","page":"Docstrings","title":"Inti.Domain","text":"Domain(f::Function, msh::AbstractMesh)\n\nCall Domain(f, ents) on ents = entities(msh).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.DoubleLayerKernel","page":"Docstrings","title":"Inti.DoubleLayerKernel","text":"struct DoubleLayerKernel{T,Op} <: AbstractKernel{T}\n\nGiven an operator Op, construct its free-space double-layer kernel. This corresponds to the γ₁ trace of the SingleLayerKernel. For operators such as Laplace or Helmholtz, this is simply the normal derivative of the fundamental solution respect to the source variable.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Elastostatic","page":"Docstrings","title":"Inti.Elastostatic","text":"struct Elastostatic{N,T} <: AbstractDifferentialOperator{N}\n\nElastostatic operator in N dimensions: -μΔu - (μ+λ)∇(∇⋅u)\n\nNote that the displacement u is a vector of length N since this is a vectorial problem.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ElementIterator","page":"Docstrings","title":"Inti.ElementIterator","text":"struct ElementIterator{E,M} <: AbstractVector{E}\n\nStructure to lazily access elements of type E in a mesh of type M. This is particularly useful for LagrangeElements, where the information to reconstruct the element is stored in the mesh connectivity matrix.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.EmbeddedQuadrature","page":"Docstrings","title":"Inti.EmbeddedQuadrature","text":"struct EmbeddedQuadrature{L,H,D} <: ReferenceQuadrature{D}\n\nA quadrature rule for the reference shape D based on a high-order quadrature of type H and a low-order quadrature of type L. The low-order quadrature rule is embedded in the sense that its n nodes are exactly the first n nodes of the high-order quadrature rule.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.EntityKey","page":"Docstrings","title":"Inti.EntityKey","text":"EntityKey\n\nUsed to represent the key of a GeometricEntity, comprised of a dim and a tag field, where dim is the geometrical dimension of the entity, and tag is a unique integer identifying the entity.\n\nThe sign of the tag field is used to distinguish the orientation of the entity, and is ignored when comparing two EntityKeys for equality.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Fejer","page":"Docstrings","title":"Inti.Fejer","text":"struct Fejer{N}\n\nN-point Fejer's first quadrature rule for integrating a function over [0,1]. Exactly integrates all polynomials of degree ≤ N-1.\n\nusing Inti\n\nq = Inti.Fejer(;order=10)\n\nInti.integrate(cos,q) ≈ sin(1) - sin(0)\n\n# output\n\ntrue\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Gauss","page":"Docstrings","title":"Inti.Gauss","text":"struct Gauss{D,N} <: ReferenceQuadrature{D}\n\nTabulated N-point symmetric Gauss quadrature rule for integration over D.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.GaussLegendre","page":"Docstrings","title":"Inti.GaussLegendre","text":"struct GaussLegendre{N,T}\n\nN-point Gauss-Legendre quadrature rule for integrating a function over [0,1]. Exactly integrates all polynomials of degree ≤ 2N-1.\n\nusing Inti\n\nq = Inti.GaussLegendre(;order=10)\n\nInti.integrate(cos,q) ≈ sin(1) - sin(0)\n\n# output\n\ntrue\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.GeometricEntity","page":"Docstrings","title":"Inti.GeometricEntity","text":"struct GeometricEntity\n\nGeometrical objects such as lines, surfaces, and volumes.\n\nGeometrical entities are stored in a global ENTITIES dictionary mapping EntityKey to the corresponding GeometricEntity, and usually entities are manipulated through their keys.\n\nA GeometricEntity can also contain a pushforward field used to parametrically represent the entry as the image of a reference domain (pushforward.domain) under some function (pushforward.parametrization).\n\nNote that entities are manipulated through their keys, and the GeometricEntity constructor returns the key of the created entity; to retrieve the entity, use the global_get_entity function.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.GeometricEntity-Tuple{String}","page":"Docstrings","title":"Inti.GeometricEntity","text":"GeometricEntity(shape::String [; translation, rotation, scaling, kwargs...])\n\nConstructs a geometric entity with the specified shape and optional parameters, and returns its key.\n\nArguments\n\nshape::String: The shape of the geometric entity.\ntranslation: The translation vector of the geometric entity. Default is SVector(0, 0, 0).\nrotation: The rotation vector of the geometric entity. Default is SVector(0, 0, 0).\nscaling: The scaling vector of the geometric entity. Default is SVector(1, 1, 1).\nkwargs...: Additional keyword arguments to be passed to the shape constructor.\n\nSupported shapes\n\nellipsoid\ntorus\nbean\nacorn\ncushion\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.Helmholtz-Tuple{}","page":"Docstrings","title":"Inti.Helmholtz","text":"Helmholtz(; k, dim)\n\nHelmholtz operator in dim dimensions: -Δu - k²u.\n\nThe parameter k can be a real or complex number. For purely imaginary wavenumbers, consider using the Yukawa kernel.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.HyperRectangle","page":"Docstrings","title":"Inti.HyperRectangle","text":"struct HyperRectangle{N,T} <: ReferenceInterpolant{ReferenceHyperCube{N},T}\n\nAxis-aligned hyperrectangle in N dimensions given by low_corner::SVector{N,T} and high_corner::SVector{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.HyperSingularKernel","page":"Docstrings","title":"Inti.HyperSingularKernel","text":"struct HyperSingularKernel{T,Op} <: AbstractKernel{T}\n\nGiven an operator Op, construct its free-space hypersingular kernel. This corresponds to the transpose(γ₁,ₓγ₁[G]), where G is the SingleLayerKernel. For operators such as Laplace or Helmholtz, this is simply the normal derivative respect to the target variable of the DoubleLayerKernel.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.IntegralOperator","page":"Docstrings","title":"Inti.IntegralOperator","text":"struct IntegralOperator{T} <: AbstractMatrix{T}\n\nA discrete linear integral operator given by\n\nIu(x) = int_Gamma_s K(xy)u(y) ds_y x in Gamma_t\n\nwhere Gamma_s and Gamma_t are the source and target domains, respectively.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.IntegralPotential","page":"Docstrings","title":"Inti.IntegralPotential","text":"struct IntegralPotential\n\nRepresent a potential given by a kernel and a quadrature over which integration is performed.\n\nIntegralPotentials are created using IntegralPotential(kernel, quadrature).\n\nEvaluating an integral potential requires a density σ (defined over the quadrature nodes of the source mesh) and a point x at which to evaluate the integral\n\nint_Gamma K(oldsymbolxoldsymboly)sigma(y) ds_y x not in Gamma\n\nAssuming 𝒮 is an integral potential and σ is a vector of values defined on quadrature, calling 𝒮[σ] creates an anonymous function that can be evaluated at any point x.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeCube","page":"Docstrings","title":"Inti.LagrangeCube","text":"const LagrangeSquare = LagrangeElement{ReferenceSquare}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeElement","page":"Docstrings","title":"Inti.LagrangeElement","text":"struct LagrangeElement{D,Np,T} <: ReferenceInterpolant{D,T}\n\nA polynomial p : D → T uniquely defined by its Np values on the Np reference nodes of D.\n\nThe return type T should be a vector space (i.e. support addition and multiplication by scalars). For istance, T could be a number or a vector, but not a Tuple.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeLine","page":"Docstrings","title":"Inti.LagrangeLine","text":"const LagrangeLine = LagrangeElement{ReferenceLine}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeSquare","page":"Docstrings","title":"Inti.LagrangeSquare","text":"const LagrangeSquare = LagrangeElement{ReferenceSquare}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeTetrahedron","page":"Docstrings","title":"Inti.LagrangeTetrahedron","text":"const LagrangeTetrahedron = LagrangeElement{ReferenceTetrahedron}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.LagrangeTriangle","page":"Docstrings","title":"Inti.LagrangeTriangle","text":"const LagrangeTriangle = LagrangeElement{ReferenceTriangle}\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Laplace-Tuple{}","page":"Docstrings","title":"Inti.Laplace","text":"Laplace(; dim)\n\nLaplace's differential operator in dim dimension: -Δu. ```\n\nNote the negative sign in the definition.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.Mesh","page":"Docstrings","title":"Inti.Mesh","text":"struct Mesh{N,T} <: AbstractMesh{N,T}\n\nUnstructured mesh defined by a set of nodes(of typeSVector{N,T}`), and a dictionary mapping element types to connectivity matrices. Each columns of a given connectivity matrix stores the integer tags of the nodes in the mesh comprising the element.\n\nAdditionally, the mesh contains a mapping from EntityKeys to the tags of the elements composing the entity. This can be used to extract submeshes from a given mesh using e.g. view(msh,Γ) or msh[Γ], where Γ is a Domain.\n\nSee elements for a way to iterate over the elements of a mesh.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ModifiedHelmholtz","page":"Docstrings","title":"Inti.ModifiedHelmholtz","text":"const ModifiedHelmholtz\n\nType alias for the Yukawa operator.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.MultiIndex","page":"Docstrings","title":"Inti.MultiIndex","text":"MultiIndex{N}\n\nWrapper around NTuple{N,Int} mimicking a multi-index in ℤ₀ᴺ.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ParametricElement","page":"Docstrings","title":"Inti.ParametricElement","text":"ParametricElement{D,T,F} <: ReferenceInterpolant{D,T}\n\nAn element represented through a explicit function f mapping D into the element. For performance reasons, f should take as input a StaticVector and return a StaticVector or StaticArray.\n\nSee also: ReferenceInterpolant, LagrangeElement\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ParametricElement-Union{Tuple{T}, Tuple{N}, Tuple{Any, Inti.HyperRectangle{N, T}}} where {N, T}","page":"Docstrings","title":"Inti.ParametricElement","text":"ParametricElement(f, d::HyperRectangle)\n\nConstruct the element defined as the image of f over d.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.PolynomialSpace","page":"Docstrings","title":"Inti.PolynomialSpace","text":"struct PolynomialSpace{D,K}\n\nThe space of all polynomials of degree ≤K, commonly referred to as ℙₖ.\n\nThe type parameter D, of singleton type, is used to determine the reference domain of the polynomial basis. In particular, when D is a hypercube in d dimensions, the precise definition is ℙₖ = span{𝐱ᶿ : 0≤max(θ)≤ K}; when D is a d-dimensional simplex, the space is ℙₖ = span{𝐱ᶿ : 0≤sum(θ)≤ K}, where θ ∈ 𝐍ᵈ is a multi-index.\n\nSee also: monomial_basis, lagrange_basis\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Quadrature","page":"Docstrings","title":"Inti.Quadrature","text":"struct Quadrature{N,T} <: AbstractVector{QuadratureNode{N,T}}\n\nA collection of QuadratureNodes used to integrate over an AbstractMesh.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Quadrature-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.Quadrature","text":"Quadrature(Ω::Domain; meshsize, qorder)\n\nConstruct a Quadrature over the domain Ω with a mesh of size meshsize and quadrature order qorder.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.Quadrature-Union{Tuple{T}, Tuple{N}, Tuple{Inti.AbstractMesh{N, T}, Dict}} where {N, T}","page":"Docstrings","title":"Inti.Quadrature","text":"Quadrature(msh::AbstractMesh, etype2qrule::Dict)\nQuadrature(msh::AbstractMesh, qrule::ReferenceQuadrature)\nQuadrature(msh::AbstractMesh; qorder)\n\nConstruct a Quadrature for msh, where for each element type E in msh the reference quadrature q = etype2qrule[E] is used. When a single qrule is passed, it is used for all element types in msh.\n\nIf an order keyword is passed, a default quadrature of the desired order is used for each element type usig _qrule_for_reference_shape.\n\nFor co-dimension one elements, the normal vector is also computed and stored in the QuadratureNodes.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.QuadratureNode","page":"Docstrings","title":"Inti.QuadratureNode","text":"QuadratureNode{N,T<:Real}\n\nA point in ℝᴺ with a weight for performing numerical integration. A QuadratureNode can optionally store a normal vector.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceCube","page":"Docstrings","title":"Inti.ReferenceCube","text":"const ReferenceCube = ReferenceHyperCube{3}\n\nSingleton type representing the unit cube [0,1]³.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceHyperCube","page":"Docstrings","title":"Inti.ReferenceHyperCube","text":"struct ReferenceHyperCube{N} <: ReferenceShape{N}\n\nSingleton type representing the axis-aligned hypercube in N dimensions with the lower corner at the origin and the upper corner at (1,1,…,1).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceInterpolant","page":"Docstrings","title":"Inti.ReferenceInterpolant","text":"abstract type ReferenceInterpolant{D,T}\n\nInterpolanting function mapping points on the domain D<:ReferenceShape (of singleton type) to a value of type T.\n\nInstances el of ReferenceInterpolant are expected to implement:\n\nel(x̂): evaluate the interpolation scheme at the (reference) coordinate x̂ ∈ D.\njacobian(el,x̂) : evaluate the jacobian matrix of the interpolation at the (reference) coordinate x ∈ D.\n\nnote: Note\nFor performance reasons, both el(x̂) and jacobian(el,x̂) should take as input a StaticVector and output a static vector or static array.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceLine","page":"Docstrings","title":"Inti.ReferenceLine","text":"const ReferenceLine = ReferenceHyperCube{1}\n\nSingleton type representing the [0,1] segment.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceQuadrature","page":"Docstrings","title":"Inti.ReferenceQuadrature","text":"abstract type ReferenceQuadrature{D}\n\nA quadrature rule for integrating a function over the domain D <: ReferenceShape.\n\nCalling x,w = q() returns the nodes x, given as SVectors, and weights w, for performing integration over domain(q).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceShape","page":"Docstrings","title":"Inti.ReferenceShape","text":"abstract type ReferenceShape\n\nA fixed reference domain/shape. Used mostly for defining more complex shapes as transformations mapping an ReferenceShape to some region of ℜᴹ.\n\nSee e.g. ReferenceLine or ReferenceTriangle for some examples of concrete subtypes.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceSimplex","page":"Docstrings","title":"Inti.ReferenceSimplex","text":"struct ReferenceSimplex{N}\n\nSingleton type representing the N-simplex with N+1 vertices (0,...,0),(0,...,0,1),(0,...,0,1,0),(1,0,...,0)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceSquare","page":"Docstrings","title":"Inti.ReferenceSquare","text":"const ReferenceSquare = ReferenceHyperCube{2}\n\nSingleton type representing the unit square [0,1]².\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceTetrahedron","page":"Docstrings","title":"Inti.ReferenceTetrahedron","text":"struct ReferenceTetrahedron\n\nSingleton type representing the tetrahedron with vertices (0,0,0),(0,0,1),(0,1,0),(1,0,0)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.ReferenceTriangle","page":"Docstrings","title":"Inti.ReferenceTriangle","text":"struct ReferenceTriangle\n\nSingleton type representing the triangle with vertices (0,0),(1,0),(0,1)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.SingleLayerKernel","page":"Docstrings","title":"Inti.SingleLayerKernel","text":"struct SingleLayerKernel{T,Op} <: AbstractKernel{T}\n\nThe free-space single-layer kernel (i.e. the fundamental solution) of an Op <: AbstractDifferentialOperator.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Stokes-Tuple{}","page":"Docstrings","title":"Inti.Stokes","text":"Stokes(; μ, dim)\n\nStokes operator in dim dimensions: -μΔu + p u.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.SubMesh","page":"Docstrings","title":"Inti.SubMesh","text":"struct SubMesh{N,T} <: AbstractMesh{N,T}\n\nView into a parent mesh over a given domain.\n\nA submesh implements the interface for AbstractMesh; therefore you can iterate over elements of the submesh just like you would with a mesh.\n\nConstruct SubMeshs using view(parent,Ω::Domain).\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.TensorProductQuadrature","page":"Docstrings","title":"Inti.TensorProductQuadrature","text":"TensorProductQuadrature{N,Q}\n\nA tensor-product of one-dimension quadrature rules. Integrates over [0,1]^N.\n\nExamples\n\nqx = Inti.Fejer(10)\nqy = Inti.Fejer(15)\nq  = Inti.TensorProductQuadrature(qx,qy)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.VioreanuRokhlin","page":"Docstrings","title":"Inti.VioreanuRokhlin","text":"struct VioreanuRokhlin{D,N} <: ReferenceQuadrature{D}\n\nTabulated N-point Vioreanu-Rokhlin quadrature rule for integration over D.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Inti.Yukawa-Tuple{}","page":"Docstrings","title":"Inti.Yukawa","text":"Yukawa(; λ, dim)\n\nYukawa operator, also known as modified Helmholtz, in dim dimensions: -Δu + λ²u.\n\nThe parameter λ is a positive number. Note the negative sign in front of the Laplacian.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.iterate","page":"Docstrings","title":"Base.iterate","text":"iterate(Ω::Domain)\n\nIterating over a domain means iterating over its entities.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.DoubleLayerPotential-Tuple{Inti.AbstractDifferentialOperator, Inti.Quadrature}","page":"Docstrings","title":"Inti.DoubleLayerPotential","text":"DoubleLayerPotential(op::AbstractDifferentialOperator, source::Quadrature)\n\nAn IntegralPotential over source with kernel given by DoubleLayerKernel(op).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.SingleLayerPotential-Tuple{Inti.AbstractDifferentialOperator, Inti.Quadrature}","page":"Docstrings","title":"Inti.SingleLayerPotential","text":"SingleLayerPotential(op::AbstractDifferentialOperator, source::Quadrature)\n\nAn IntegralPotential over source with kernel given by SingleLayerKernel(op).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._blocksize_normalized-Union{Tuple{Inti.BlockArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Docstrings","title":"Inti._blocksize_normalized","text":"_blocksize_normalized(A::BlockArray)\n\nLike blocksize, but appends 1s if A is a higher-dimensional.\n\nFor example, a BlockArray{SVector{3,Float64}, 2} has a blocksize of (3,), but a normalized_blocksize of (3, 1).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._get_gauss_qcoords_and_qweights-Tuple{Type{<:Inti.ReferenceShape}, Any}","page":"Docstrings","title":"Inti._get_gauss_qcoords_and_qweights","text":"_get_gauss_and_qweights(R::Type{<:ReferenceShape{D}}, N) where D\n\nReturns the N-point symmetric gaussian qnodes and qweights (x, w) for integration over R.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._get_vioreanurokhlin_qcoords_and_qweights-Tuple{Type{<:Inti.ReferenceShape}, Any}","page":"Docstrings","title":"Inti._get_vioreanurokhlin_qcoords_and_qweights","text":"_get_vioreanurokhlin_qcoords_and_qweights(R::Type{<:ReferenceShape{D}}, N) where D\n\nReturns the N-point Vioreanu-Rokhlin qnodes and qweights (x, w) for integration over R.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._green_multiplier-Tuple{Symbol}","page":"Docstrings","title":"Inti._green_multiplier","text":"_green_multiplier(s::Symbol)\n\nReturn -1.0 if s == :inside, 0.0 if s == :outside, and -0.5 if s == :on; otherwise, throw an error. The orientation is relative to the normal of the bounding curve/surface.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._green_multiplier-Union{Tuple{N}, Tuple{StaticArraysCore.SVector, Inti.Quadrature{N}}} where N","page":"Docstrings","title":"Inti._green_multiplier","text":"_green_multiplier(x, quad)\n\nHelper function to help determine the constant σ in the Green identity S[γ₁u](x)\n\nD[γ₀u](x) + σ*u(x) = 0. This can be used as a predicate to determine whether a\n\npoint is inside a domain or not.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._meshgen-Tuple{Any, Inti.HyperRectangle, NTuple{N, T} where {N, T}}","page":"Docstrings","title":"Inti._meshgen","text":"_meshgen(f,d::HyperRectangle,sz)\n\nCreate prod(sz) elements of ParametricElement type representing the push forward of f on each of the subdomains defined by a uniform cartesian mesh of d of size sz.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._normal-Union{Tuple{StaticArraysCore.SMatrix{N, M}}, Tuple{M}, Tuple{N}, Tuple{StaticArraysCore.SMatrix{N, M}, Any}} where {N, M}","page":"Docstrings","title":"Inti._normal","text":"_normal(jac::SMatrix{M,N}, s = 1)\n\nGiven a an M by N matrix representing the jacobian of a codimension one object, compute the normal vector. If s=-1, the normal vector is flipped.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti._qrule_for_reference_shape-Tuple{Any, Any}","page":"Docstrings","title":"Inti._qrule_for_reference_shape","text":"_qrule_for_reference_shape(ref,order)\n\nGiven a reference shape and a desired quadrature order, return an appropiate quadrature rule.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.acorn-Tuple{}","page":"Docstrings","title":"Inti.acorn","text":"acorn(; translation, rotation, scaling, labels)\n\nCreate an acorn entity in 3D, and apply optional transformations. Returns the key.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.adaptive_correction-Tuple{Inti.IntegralOperator}","page":"Docstrings","title":"Inti.adaptive_correction","text":"adaptive_correction(iop::IntegralOperator; [maxdist, rtol, threads = true, kwargs...])\nadaptive_correction(iop::IntegralOperator, maxdist, quads_dict::Dict, threads = true)\n\nThis function computes a sparse correction for the integral operator iop, addressing its singular or nearly singular entries.\n\nThe parameter maxdist specifies the maximum distance between target points  and source elements to be considered for correction (only interactions within this distance are corrected).\n\nThe parameter rtol defines the tolerance for the adaptive quadrature used to compute the corrections for singular or nearly singular entries.\n\nAdditional kwargs arguments are passed to adaptive_quadrature; see its documentation for more information.\n\nSelecting maxdist and rtol involves balancing accuracy and computational cost. A smaller maxdist reduces the number of corrections but may impact accuracy. Conversely, a smaller rtol improves correction accuracy but increases computational expense. The ideal values for maxdist and rtol depend on the kernel and the mesh/quadrature rule applied.\n\nBy default, maxdist and rtol are estimated using the local_correction_dist_and_tol, but it is often possible to improve performance by manually tunning these parameters.\n\nAdvanced usage\n\nFor finer control, you can provide a dictionary quads_dict that contains quadrature rules for each reference element type present in the mesh of source(iop). This allows you to fine-tune the quadrature rules for specific element types (e.g. use a fixed quadrature rule instead of an adaptive one).\n\nThe dictionary quads_dict must adhere to the following structure:\n\nquads_dict[E].nearfield_quad: A function that integrates over the nearfield of the reference element type E. Used in the nearly-singular correction.\nquads_dict[E].radial_quad: A function that integrates over the radial direction of the reference element type E. Used in the singular correction.\nquads_dict[E].angular_quad: A function that integrates over the angular direction of the reference element type E. Used in the singular correction.\n\nHere is an example of how to implement a custom quads_dict given an iop:\n\nquads_dict = Dict()\nmsh = Inti.mesh(source(iop))\nfor E in Inti.element_types(msh)\n    ref_domain = Inti.reference_domain(E)\n    quads = (\n        nearfield_quad = Inti.adaptive_quadrature(ref_domain; atol),\n        radial_quad    = Inti.GaussLegendre(;order=5),\n        angular_quad   = Inti.GuassLegendre(;order=20),\n    )\n    quads_dict[E] = quads\nend\n\nThis will use an adaptive quadrature rule for the nearfield and fixed Gauss-Legendre quadrature rules for the radial and angular directions when computing the singular correction in polar coordinates on the reference domain. You can then call adaptive_correction(iop, maxdist, quads_dict) to use the custom quadrature.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.adaptive_quadrature-Tuple{Inti.ReferenceHyperCube{1}}","page":"Docstrings","title":"Inti.adaptive_quadrature","text":"adaptive_quadrature(ref_domain::ReferenceShape; kwargs...)\n\nReturn a function quad callable as quad(f) that integrates the function f over the reference shape ref_domain. The keyword arguments are passed to HAdaptiveIntegration.integrate.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.adj_double_layer_hypersingular-Tuple{}","page":"Docstrings","title":"Inti.adj_double_layer_hypersingular","text":"adj_double_layer_hypersingular(; op, target, source, compression,\ncorrection)\n\nSimilar to single_double_layer, but for the adjoint double-layer and hypersingular operators. See the documentation of [single_double_layer] for a description of the arguments.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.ambient_dimension","page":"Docstrings","title":"Inti.ambient_dimension","text":"ambient_dimension(x)\n\nDimension of the ambient space where x lives. For geometrical objects this can differ from its geometric_dimension; for example a triangle in ℝ³ has ambient dimension 3 but geometric dimension 2, while a curve in ℝ³ has ambient dimension 3 but geometric dimension 1.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.assemble_fmm-Tuple{Inti.IntegralOperator}","page":"Docstrings","title":"Inti.assemble_fmm","text":"assemble_fmm(iop; rtol)\n\nSet up a 2D or 3D FMM for evaluating the discretized integral operator iop associated with the op. In 2D the FMM2D or FMMLIB2D library is used (whichever was most recently loaded) while in 3D FMM3D is used.\n\nwarning: FMMLIB2D\nFMMLIB2D does no checking for if the targets and sources coincide, and will return Inf values if iop.target !== iop.source, but there is a point x ∈ iop.target such that x ∈ iop.source.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.assemble_hmatrix-Tuple","page":"Docstrings","title":"Inti.assemble_hmatrix","text":"assemble_hmatrix(iop[; atol, rank, rtol, eta])\n\nAssemble an H-matrix representation of the discretized integral operator iop using the HMatrices.jl library.\n\nSee the documentation of HMatrices for more details on usage and other keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.assemble_matrix-Tuple{Inti.IntegralOperator}","page":"Docstrings","title":"Inti.assemble_matrix","text":"assemble_matrix(iop::IntegralOperator; threads = true)\n\nAssemble a dense matrix representation of an IntegralOperator.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.bdim_correction-Tuple{Any, Any, Inti.Quadrature, Any, Any}","page":"Docstrings","title":"Inti.bdim_correction","text":"bdim_correction(op,X,Y,S,D; green_multiplier, kwargs...)\n\nGiven a op and a (possibly inaccurate) discretizations of its single and double-layer operators S and D (taking a vector of values on Y and returning a vector on of values on X), compute corrections δS and δD such that S + δS and D + δD are more accurate approximations of the underlying single- and double-layer integral operators.\n\nSee [8] for more details on the method.\n\nArguments\n\nRequired:\n\nop must be an AbstractDifferentialOperator\nY must be a Quadrature object of a closed surface\nX is either inside, outside, or on Y\nS and D are approximations to the single- and double-layer operators for op taking densities in Y and returning densities in X.\ngreen_multiplier (keyword argument) is a vector with the same length as X storing the value of μ(x) for x ∈ X in the Green identity S\\[γ₁u\\](x) - D\\[γ₀u\\](x) + μ*u(x) = 0. See _green_multiplier.\n\nOptional kwargs:\n\nparameters::DimParameters: parameters associated with the density interpolation method\nderivative: if true, compute the correction to the adjoint double-layer and hypersingular operators instead. In this case, S and D should be replaced by a (possibly innacurate) discretization of adjoint double-layer and hypersingular operators, respectively.\nmaxdist: distance beyond which interactions are considered sufficiently far so that no correction is needed. This is used to determine a threshold for nearly-singular corrections when X and Y are different surfaces. When X === Y, this is not needed.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.bean-Tuple{}","page":"Docstrings","title":"Inti.bean","text":"bean(; translation, rotation, scaling, labels)\n\nCreate a bean entity in 3D, and apply optional transformations. Returns the key.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.blocksize-Union{Tuple{Inti.BlockArray{T}}, Tuple{T}} where T","page":"Docstrings","title":"Inti.blocksize","text":"blocksize(A::BlockArray)\n\nThe size of an individual entry of A.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.boundary-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.boundary","text":"boundary(Ω::Domain)\n\nReturn the external boundaries of a domain.\n\nSee also: external_boundary, internal_boundary, skeleton.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.boundary_idxs-Tuple{Inti.LagrangeElement{Inti.ReferenceHyperCube{1}}}","page":"Docstrings","title":"Inti.boundary_idxs","text":"boundary_idxs(el::LagrangeElement)\n\nThe indices of the nodes in el that define the boundary of the element.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.cart2sph-Tuple{Any, Any, Any}","page":"Docstrings","title":"Inti.cart2sph","text":"cart2sph(x,y,z)\n\nMap cartesian coordinates x,y,z to spherical ones r, θ, φ representing the radius, elevation, and azimuthal angle respectively. The convention followed is that 0 ≤ θ ≤ π and -π < φ ≤ π. Same as the cart2sph function in MATLAB.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.connectivity-Tuple{Inti.Mesh, DataType}","page":"Docstrings","title":"Inti.connectivity","text":"connectivity(msh::AbstractMesh,E::DataType)\n\nReturn the connectivity matrix for elements of type E in msh. The integer tags in the matrix refer to the points in nodes(msh)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.coords-Tuple{T} where T","page":"Docstrings","title":"Inti.coords","text":"coords(q)\n\nReturn the spatial coordinates of q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.cushion-Tuple{}","page":"Docstrings","title":"Inti.cushion","text":"cushion(; translation, rotation, scaling, labels)\n\nCreate a cushion entity in 3D, and apply optional transformations. Returns the key.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.degree-Union{Tuple{Type{<:Inti.LagrangeElement{D, Np}}}, Tuple{Np}, Tuple{D}} where {D, Np}","page":"Docstrings","title":"Inti.degree","text":"degree(el::LagrangeElement)\ndegree(el::Type{<:LagrangeElement})\n\nThe polynomial degree el.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.dimension-Union{Tuple{Type{Inti.PolynomialSpace{D, K}}}, Tuple{K}, Tuple{D}} where {D, K}","page":"Docstrings","title":"Inti.dimension","text":"dimension(space)\n\nThe length of a basis for space; i.e. the number of linearly independent elements required to span space.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.dom2elt-Tuple{Inti.AbstractMesh, Inti.Domain, DataType}","page":"Docstrings","title":"Inti.dom2elt","text":"dom2elt(m::Mesh,Ω,E)::Vector{Int}\n\nCompute the element indices idxs of the elements of type E composing Ω.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.dom2qtags-Tuple{Inti.Quadrature, Inti.Domain}","page":"Docstrings","title":"Inti.dom2qtags","text":"dom2qtags(Q::Quadrature, dom::Domain)\n\nGiven a domain, return the indices of the quadratures nodes in Q associated to its quadrature.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.domain","page":"Docstrings","title":"Inti.domain","text":"domain(f)\n\nGiven a function-like object f: Ω → R, return Ω.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.domain-Tuple{Inti.AbstractMesh}","page":"Docstrings","title":"Inti.domain","text":"domain(msh::AbstractMesh)\n\nReturn a [Domain] containing of all entities covered by the mesh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.domain-Tuple{Inti.Quadrature}","page":"Docstrings","title":"Inti.domain","text":"domain(Q::Quadrature)\n\nThe Domain over which Q performs integration.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.domain-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D","page":"Docstrings","title":"Inti.domain","text":"domain(q::ReferenceQuadrature)\n\nThe domain of integratino for quadrature rule q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.element_types","page":"Docstrings","title":"Inti.element_types","text":"element_types(msh::AbstractMesh)\n\nReturn the element types present in the msh.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.elements","page":"Docstrings","title":"Inti.elements","text":"elements(msh::AbstractMesh [, E::DataType])\n\nReturn the elements of a msh. Passing and element type E will restricts to elements of that type.\n\nA common pattern to avoid type-instabilies in performance critical parts of the code is to use a function barrier, as illustrated below:\n\nfor E in element_types(msh)\n    _long_computation(elements(msh, E), args...)\nend\n\n@noinline function _long_computation(iter, args...)\n    for el in iter # the type of el is known at compile time\n        # do something with el\n    end\nend\n\nwhere a dynamic dispatch is performed only on the element types (typically small for a given mesh).\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.ellipsoid-Tuple{}","page":"Docstrings","title":"Inti.ellipsoid","text":"ellipsoid(; translation, rotation, scaling, labels)\n\nCreate an ellipsoid entity in 3D, and apply optional transformations. Returns the key of the created entity.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.ent2etags-Tuple{Inti.Mesh}","page":"Docstrings","title":"Inti.ent2etags","text":"ent2etags(msh::AbstractMesh)\n\nReturn a dictionary mapping entities to a dictionary of element types to element tags.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.entities-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.entities","text":"entities(Ω::Domain)\n\nReturn all entities making up a domain (as a set of EntityKeys).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.etype_to_nearest_points-Tuple{Any, Inti.Quadrature}","page":"Docstrings","title":"Inti.etype_to_nearest_points","text":"etype_to_nearest_points(X,Y::Quadrature; maxdist)\n\nFor each element el in Y.mesh, return a list with the indices of all points in X for which el is the nearest element. Ignore indices for which the distance exceeds maxdist.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.external_boundary-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.external_boundary","text":"external_boundary(Ω::Domain)\n\nReturn the external boundaries inside a domain. These are entities in the skeleton of Ω which are not in the internal boundaries of Ω.\n\nSee also: internal_boundary, skeleton.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.fibonnaci_points_sphere-Tuple{Any, Any, Any}","page":"Docstrings","title":"Inti.fibonnaci_points_sphere","text":"fibonnaci_points_sphere(N,r,c)\n\nReturn N points distributed (roughly) in a uniform manner on the sphere of radius r centered at c.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.flip_normal-Tuple{Inti.QuadratureNode}","page":"Docstrings","title":"Inti.flip_normal","text":"flip_normal(q::QuadratureNode)\n\nReturn a new QuadratureNode with the normal vector flipped.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.gauss_curvature-Tuple{Inti.Quadrature}","page":"Docstrings","title":"Inti.gauss_curvature","text":"gauss_curvature(Q::Quadrature)\n\nCompute the gauss_curvature at each quadrature node in Q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.gauss_curvature-Tuple{Inti.ReferenceInterpolant, Any}","page":"Docstrings","title":"Inti.gauss_curvature","text":"gauss_curvature(τ, x̂)\n\nCalculate the Gaussian curvature of the element τ at the parametric coordinate x̂.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.geometric_dimension","page":"Docstrings","title":"Inti.geometric_dimension","text":"geometric_dimension(x)\n\nNNumber of degrees of freedom necessary to locally represent the geometrical object. For example, lines have geometric dimension of 1 (whether in ℝ² or in ℝ³), while surfaces have geometric dimension of 2.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.global_get_entity-Tuple{Inti.EntityKey}","page":"Docstrings","title":"Inti.global_get_entity","text":"global_get_entity(k::EntityKey)\n\nRetrieve the GeometricEntity corresponding to the EntityKey k from the global ENTITIES dictionary.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.gmsh_curve-Tuple","page":"Docstrings","title":"Inti.gmsh_curve","text":"gmsh_curve(f::Function, a, b; npts=100, meshsize = 0, tag=-1)\n\nCreate a curve in the current gmsh model given by {f(t) : t ∈ (a,b) } where f is a function from ℝ to ℝ^3. The curve is approximated by C² b-splines passing through npts equispaced in parameter space. If a meshsize is given, gmsh will use it when meshing the curve.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.hessian-Tuple{Inti.ReferenceInterpolant, Any}","page":"Docstrings","title":"Inti.hessian","text":"hesssian(el,x)\n\nGiven a (possibly vector-valued) functor f : 𝐑ᵐ → 𝐅ⁿ, return the n × m × m matrix Aᵢⱼⱼ = ∂²fᵢ/∂xⱼ∂xⱼ. By default ForwardDiff is used to compute the hessian, but you should overload this method for specific f if better performance and/or precision is required.\n\nNote: both x and f(x) are expected to be of SVector type.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.image","page":"Docstrings","title":"Inti.image","text":"image(f)\n\nGiven a function-like object f: Ω → R, return f(Ω).\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.import_mesh-Tuple","page":"Docstrings","title":"Inti.import_mesh","text":"import_mesh(filename = nothing; dim=3)\n\nOpen filename and create a Mesh from the gmsh model in it.\n\nIf filename is nothing, the current gmsh model is used. Note that this assumes that the Gmsh API has been initialized through gmsh.initialize.\n\nPassing dim=2 will create a two-dimensional mesh by projecting the original mesh onto the x,y plane.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.integrate-Tuple{Any, Inti.Quadrature}","page":"Docstrings","title":"Inti.integrate","text":"integrate(f,quad::Quadrature)\n\nCompute ∑ᵢ f(qᵢ)wᵢ, where the qᵢ are the quadrature nodes of quad, and wᵢ are the quadrature weights.\n\nNote that you must define f(::QuadratureNode): use q.coords and q.normal if you need to access the coordinate or normal vector at que quadrature node.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.integrate-Tuple{Any, Inti.ReferenceQuadrature}","page":"Docstrings","title":"Inti.integrate","text":"integrate(f,q::ReferenceQuadrature)\nintegrate(f,x,w)\n\nIntegrate the function f using the quadrature rule q. This is simply sum(f.(x) .* w), where x and w are the quadrature nodes and weights, respectively.\n\nThe function f should take an SVector as input.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.integrate_with_error_estimate","page":"Docstrings","title":"Inti.integrate_with_error_estimate","text":"integrate_with_error_estimate(f, quad::EmbeddedQuadrature, norm = LinearAlgebra.norm)\n\nReturn I, E where I is the estimated integral of f over domain(quad) using the high-order quadrature and E is the error estimate obtained by taking the norm of the difference between the high and low-order quadratures in quad.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.integration_measure-Tuple{Any, Any}","page":"Docstrings","title":"Inti.integration_measure","text":"integration_measure(f, x̂)\n\nGiven the Jacobian matrix J of a transformation f : ℝᴹ → ℝᴺ compute the integration measure √det(JᵀJ) at the parametric coordinate x̂\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.interface_method-Tuple{DataType}","page":"Docstrings","title":"Inti.interface_method","text":"interface_method(x)\n\nA method of an abstract type for which concrete subtypes are expected to provide an implementation.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.internal_boundary-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.internal_boundary","text":"internal_boundary(Ω::Domain)\n\nReturn the internal boundaries of a Domain. These are entities in skeleton(Ω) which appear at least twice as a boundary of entities in Ω.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.interpolation_order-Tuple{Inti.ReferenceQuadrature{Inti.ReferenceHyperCube{1}}}","page":"Docstrings","title":"Inti.interpolation_order","text":"interpolation_order(qrule::ReferenceQuadrature)\n\nThe interpolation order of a quadrature rule is defined as the the smallest k such that there exists a unique polynomial in PolynomialSpace{D,k} that minimizes the error in approximating the function f at the quadrature nodes.\n\nFor an N-point Gauss quadrature rule on the segment, the interpolation order is N-1 since N points uniquely determine a polynomial of degree N-1.\n\nFor a triangular reference domain, the interpolation order is more difficult to define. An unisolvent three-node quadrature on the triangular, for example, has an interpolation order k=1 since the three nodes uniquely determine a linear polynomial, but a four-node quadrature may also have an interpolation order k=1 since for k=2 there are multiple polynomials that pass through the four nodes.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.jacobian-Tuple{Any, Any}","page":"Docstrings","title":"Inti.jacobian","text":"jacobian(f,x)\n\nGiven a (possibly vector-valued) functor f : 𝐑ᵐ → 𝐅ⁿ, return the n × m matrix Aᵢⱼ = ∂fᵢ/∂xⱼ. By default ForwardDiff is used to compute the jacobian, but you should overload this method for specific f if better performance and/or precision is required.\n\nNote: both x and f(x) are expected to be of SVector type.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.kress_change_of_variables-Tuple{Any}","page":"Docstrings","title":"Inti.kress_change_of_variables","text":"kress_change_of_variables(P)\n\nReturn a change of variables mapping [0,1] to [0,1] with the property that the first P-1 derivatives of the transformation vanish at x=0.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.kress_change_of_variables_periodic-Tuple{Any}","page":"Docstrings","title":"Inti.kress_change_of_variables_periodic","text":"kress_change_of_variables_periodic(P)\n\nLike kress_change_of_variables, this change of variables maps the interval [0,1] onto itself, but the first P derivatives of the transformation vanish at both endpoints (thus making it a periodic function).\n\nThis change of variables can be used to periodize integrals over the interval [0,1] by mapping the integrand into a new integrand that vanishes (to order P) at both endpoints.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.lagrange_basis-Tuple{Any, Inti.PolynomialSpace}","page":"Docstrings","title":"Inti.lagrange_basis","text":"lagrange_basis(nodes,[sp::AbstractPolynomialSpace])\n\nReturn the set of n polynomials in sp taking the value of 1 on node i and 0 on nodes j ≂̸ i for 1 ≤ i ≤ n.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.lagrange_basis-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D","page":"Docstrings","title":"Inti.lagrange_basis","text":"lagrange_basis(qrule::ReferenceQuadrature)\n\nReturn a function L : ℝᴺ → ℝᵖ where N is the dimension of the domain of qrule, and p is the number of nodes in qrule. The function L is a polynomial in polynomial_space(qrule), and L(xⱼ)[i] = δᵢⱼ (i.e. the ith component of L is the ith Lagrange basis).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.lagrange_basis-Union{Tuple{Type{Inti.LagrangeElement{D, N, T}}}, Tuple{T}, Tuple{N}, Tuple{D}} where {D, N, T}","page":"Docstrings","title":"Inti.lagrange_basis","text":"lagrange_basis(E::Type{<:LagrangeElement})\n\nReturn the Lagrange basis B for the element E. Evaluating B(x) yields the value of each basis function at x.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.laurent_coefficients-Tuple{Any, Any, Val{-2}}","page":"Docstrings","title":"Inti.laurent_coefficients","text":"laurent_coefficients(f, h, order) --> f₋₂, f₋₁, f₀\n\nGiven a one-dimensional function f, return f₋₂, f₋₁, f₀ such that f(x) = f₋₂ / x^2 + f₋₁ / x + f₀ + 𝒪(x) as x -> 0, where we assume that fₙ = 0 for n < N.\n\nThe order argument is an integer that indicates the order of the singularity at the origin:\n\nVal{-2}: The function has a singularity of order -2 at the origin.\nVal{-1}: The function has a singularity of order -1 at the origin, so f₋₂ = 0.\nVal{0}: The function has a finite part at the origin, so f₋₂ = f₋₁ = 0.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.line-Tuple{Any, Any}","page":"Docstrings","title":"Inti.line","text":"line(a,b)\n\nCreate a [GeometricEntity] representing a straight line connecting points a and b. The points a and b can be either SVectors or a Tuple.\n\nThe parametrization of the line is given by f(u) = a + u(b - a), where 0 ≤ u ≤ 1.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.local_correction_dist_and_tol","page":"Docstrings","title":"Inti.local_correction_dist_and_tol","text":"local_correction_dist_and_tol(iop::IntegralOperator, kmax = 10, ratio = 8)\n\nTry to estimate resonable maxdist and rtol parameters for the adaptive_correction function, where maxdist is at most kmax times the radius of the largest element in the source mesh of iop. See the Extended help for more details.\n\nnote: Note\nThis is a heuristic and may not be accurate/efficient in all cases. It is recommended to test different values of maxdist and rtol to find the optimal values for your problem.\n\nExtended help\n\nThe heuristic works as follows, where we let K = kernel(iop) and msh = mesh(source(iop)):\n\nPick the largest element in msh\nLet h be the radius of el\nFor k between 1 and kmax, estimate the (relative) quadrature error when integrating y -> K(x,y) for x at a distance k * h from the center of the element using a regular quadrature rule\nFind a k such that ratio between errors at distances k * h and (k + 1) * h is below ratio. This indicates stagnation in the error, and suggests that little is gained by increasing the distance.\nReturn maxdist = k * h and rtol as the error at distance k * h.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.mean_curvature-Tuple{Inti.Quadrature}","page":"Docstrings","title":"Inti.mean_curvature","text":"mean_curvature(Q::Quadrature)\n\nCompute the mean_curvature at each quadrature node in Q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.mean_curvature-Tuple{Inti.ReferenceInterpolant, Any}","page":"Docstrings","title":"Inti.mean_curvature","text":"mean_curvature(τ, x̂)\n\nCalculate the mean curvature of the element τ at the parametric coordinate x̂.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.measure","page":"Docstrings","title":"Inti.measure","text":"measure(k::EntityKey, rtol)\n\nCompute the length/area/volume of the entity k using an adaptive quadrature with a relative tolerance rtol. Assumes that the entity has an explicit parametrization.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.meshgen!-Tuple{Inti.Mesh, Inti.Domain, Int64}","page":"Docstrings","title":"Inti.meshgen!","text":"meshgen!(mesh,Ω,sz)\n\nSimilar to meshgen, but append entries to mesh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.meshgen-Tuple{Inti.Domain, Vararg{Any}}","page":"Docstrings","title":"Inti.meshgen","text":"meshgen(Ω, n; T = Float64)\nmeshgen(Ω, n_dict; T = Float64)\nmeshgen(Ω; meshsize, T = Float64)\n\nGenerate a Mesh for the domain Ω where each curve is meshed using n elements. Passing a dictionary allows for a finer control; in such cases, n_dict[ent] should return an integer for each entity ent in Ω of geometric_dimension one.\n\nAlternatively, a meshsize can be passed, in which case, the number of elements is computed as so as to obtain an average mesh size of meshsize. Note that the actual mesh size may vary significantly for each element if the parametrization is far from uniform.\n\nThe mesh is created with primitive data of type T.\n\nThis function requires the entities forming Ω to have an explicit parametrization.\n\nwarning: Mesh quality\nThe quality of the generated mesh created using meshgen depends on the quality of the underlying parametrization. For complex surfaces, you are better off using a proper mesher such as gmsh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.monomial_basis","page":"Docstrings","title":"Inti.monomial_basis","text":"monomial_basis(sp::PolynomialSpace)\n\nReturn a function f : ℝᴺ → ℝᵈ, where N is the dimension of the domain of sp     containing a basis of monomials 𝐱ᶿ spanning the polynomial space PolynomialSpace.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.near_interaction_list-Union{Tuple{N}, Tuple{AbstractVector{<:StaticArraysCore.SVector{N}}, Inti.AbstractMesh{N}}} where N","page":"Docstrings","title":"Inti.near_interaction_list","text":"near_interaction_list(X,Y::AbstractMesh; tol)\n\nFor each element el of type E in Y, return the indices of the points in X which are closer than tol to the center of el.\n\nThis function returns a dictionary where e.g. dict[E][5] --> Vector{Int} gives the indices of points in X which are closer than tol to the center of the fifth element of type E.\n\nIf tol is a Dict, then tol[E] is the tolerance for elements of type E.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.new_tag-Tuple{Integer}","page":"Docstrings","title":"Inti.new_tag","text":"new_tag(dim)\n\nReturn a new tag for an entity of dimension dim so that EntityKey(dim, tag) is not already in ENTITIES.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.nodes-Tuple{Inti.SubMesh}","page":"Docstrings","title":"Inti.nodes","text":"nodes(msh::SubMesh)\n\nA view of the nodes of the parent mesh belonging to the submesh. The ordering is given by the nodetags function.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.nodetags-Tuple{Inti.SubMesh}","page":"Docstrings","title":"Inti.nodetags","text":"nodetags(msh::SubMesh)\n\nReturn the tags of the nodes in the parent mesh belonging to the submesh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.normal-Tuple{Any, Any}","page":"Docstrings","title":"Inti.normal","text":"normal(el, x̂)\n\nReturn the normal vector of el at the parametric coordinate x̂.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.normal-Tuple{T} where T","page":"Docstrings","title":"Inti.normal","text":"normal(q)\n\nReturn the normal vector of q, if it exists.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.notimplemented-Tuple{}","page":"Docstrings","title":"Inti.notimplemented","text":"notimplemented()\n\nThings which should probably be implemented at some point.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.order-Union{Tuple{Inti.Fejer{N}}, Tuple{N}} where N","page":"Docstrings","title":"Inti.order","text":"order(q::ReferenceQuadrature)\n\nA quadrature of order p (sometimes called degree of precision) integrates all polynomials of degree ≤ p but not ≤ p + 1.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.order-Union{Tuple{Type{<:Inti.LagrangeElement{D, Np}}}, Tuple{Np}, Tuple{D}} where {D, Np}","page":"Docstrings","title":"Inti.order","text":"order(el::LagrangeElement)\n\nThe order of the element's interpolating polynomial (e.g. a LagrangeLine with 2 nodes defines a linear polynomial, and thus has order 1).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.orientation-Tuple{Inti.AbstractMesh, DataType}","page":"Docstrings","title":"Inti.orientation","text":"orientation(msh::AbstractMesh,E::DataType)\n\nReturn the orientation of the elements of type E in msh (1 if normal and -1 if inverted).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.parametric_curve-Union{Tuple{F}, Tuple{F, Real, Real}} where F","page":"Docstrings","title":"Inti.parametric_curve","text":"parametric_curve(f, a::Real, b::Real)\n\nCreate a [GeometricEntity] representing a parametric curve defined by the {f(t) | a ≤ t ≤ b}. The function f should map a scalar to an SVector.\n\nFlipping the orientation is supported by passing a > b.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.parametric_surface","page":"Docstrings","title":"Inti.parametric_surface","text":"    parametric_surface(f, lc, hc, boundary = nothing; kwargs...)\n\nCreate a parametric surface defined by the function f over the rectangular domain defined by the lower corner lc and the upper corner hc. The optional boundary argument can be used to specify the boundary curves of the surface.\n\nArguments\n\nf: A function that takes two arguments x and y and returns a tuple (u, v)   representing the parametric coordinates of the surface at (x, y).\nlc: A 2-element array representing the lower corner of the rectangular domain.\nhc: A 2-element array representing the upper corner of the rectangular domain.\nboundary: An optional array of boundary curves that define the surface.\n\nKeyword Arguments\n\nkwargs: Additional keyword arguments that can be passed to the GeometricEntity   constructor.\n\nReturns\n\nThe key of the created GeometricEntity.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.polar_decomposition-Tuple{Inti.ReferenceHyperCube{2}, StaticArraysCore.SVector{2, <:Number}}","page":"Docstrings","title":"Inti.polar_decomposition","text":"polar_decomposition(shape::ReferenceSquare, x̂::SVector{2,Float64})\n\nDecompose the square [0,1] × [0,1] into four triangles, and return four tuples of the form θₛ, θₑ, ρ where θₛ and θₑ are the initial and final angles of the triangle, and ρ is the function that gives the distance from x̂ to the border of the square in the direction θ.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.polar_decomposition-Tuple{Inti.ReferenceSimplex{2}, StaticArraysCore.SVector{2, <:Number}}","page":"Docstrings","title":"Inti.polar_decomposition","text":"polar_decomposition(shape::ReferenceTriangle, x̂::SVector{2,Float64})\n\nDecompose the triangle {x,y ≥ 0, x + y ≤ 1} into three triangles, and return three tuples of the form θₛ, θₑ, ρ where θₛ and θₑ are the initial and final angles of the triangle, and ρ is the function that gives the distance from x̂ to the border of the triangle in the direction θ.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.polynomial_solutions_vdim","page":"Docstrings","title":"Inti.polynomial_solutions_vdim","text":"polynomial_solutions_vdim(op, order[, center])\n\nFor every monomial term pₙ of degree order, compute a polynomial Pₙ such that ℒ[Pₙ] = pₙ, where ℒ is the differential operator associated with op. This function returns {pₙ,Pₙ,γ₁Pₙ}, where γ₁Pₙ is the generalized Neumann trace of Pₙ.\n\nPassing a point center will shift the monomials and solutions accordingly.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Inti.polynomial_space-Union{Tuple{Inti.ReferenceQuadrature{D}}, Tuple{D}} where D","page":"Docstrings","title":"Inti.polynomial_space","text":"polynomial_space(qrule::ReferenceQuadrature)\n\nReturn a PolynomialSpace associated with the interpolation_order of the quadrature nodes of qrule.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.qcoords-Tuple{Inti.ReferenceQuadrature}","page":"Docstrings","title":"Inti.qcoords","text":"qcoords(q)\n\nReturn the coordinate of the quadrature nodes associated with q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.quadrature_to_node_vals-Tuple{Inti.Quadrature, AbstractVector}","page":"Docstrings","title":"Inti.quadrature_to_node_vals","text":"quadrature_to_node_vals(Q::Quadrature, qvals::AbstractVector)\n\nGiven a vector qvals of scalar values at the quadrature nodes of Q, return a vector ivals of scalar values at the interpolation nodes of Q.mesh.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.qweights-Tuple{Inti.ReferenceQuadrature}","page":"Docstrings","title":"Inti.qweights","text":"qweights(q)\n\nReturn the quadrature weights associated with q.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.reference_nodes-Tuple{Inti.LagrangeElement}","page":"Docstrings","title":"Inti.reference_nodes","text":"reference_nodes(el::LagrangeElement)\nreference_nodes(::Type{<:LagrangeElement})\n\nReturn the reference nodes on domain(el) used for the polynomial interpolation. The function values on these nodes completely determines the interpolating polynomial.\n\nWe use the same convention as gmsh for defining the reference nodes and their order (see node ordering on gmsh documentation).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.return_type-Tuple{Any, Vararg{Any}}","page":"Docstrings","title":"Inti.return_type","text":"return_type(f[,args...])\n\nThe type returned by f(args...), where args is a tuple of types. Falls back to Base.promote_op by default.\n\nA functors of type T with a knonw return type should extend return_type(::T,args...) to avoid relying on promote_op.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.rotation_matrix-Tuple{Any}","page":"Docstrings","title":"Inti.rotation_matrix","text":"rotation_matrix(rot)\n\nConstructs a rotation matrix given the rotation angles around the x, y, and z axes.\n\nArguments\n\nrot: A tuple or vector containing the rotation angles in radians for each axis.\n\nReturns\n\nR::SMatrix: The resulting rotation matrix.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.single_double_layer-Tuple{}","page":"Docstrings","title":"Inti.single_double_layer","text":"single_double_layer(; op, target, source::Quadrature, compression,\ncorrection, derivative = false)\n\nConstruct a discrete approximation to the single- and double-layer integral operators for op, mapping values defined on the quadrature nodes of source to values defined on the nodes of target. If derivative = true, return instead the adjoint double-layer and hypersingular operators (which are the generalized Neumann trace of the single- and double-layer, respectively).\n\nFor finer control, you must choose a compression method and a correction method, as described below.\n\nCompression\n\nThe compression argument is a named tuple with a method field followed by method-specific fields. It specifies how the dense linear operators should be compressed. The available options are:\n\n(method = :none, ): no compression is performed, the resulting matrices are dense. This is the default, but not recommended for large problems.\n(method =:hmatrix, tol): the resulting operators are compressed using hierarchical matrices with an absolute tolerance tol (defaults to 1e-8).\n(method = :fmm, tol): the resulting operators are compressed using the fast multipole method with an absolute tolerance tol (defaults to 1e-8).\n\nCorrection\n\nThe correction argument is a named tuple with a method field followed by method-specific fields. It specifies how the singular and nearly-singular integrals should be computed. The available options are:\n\n(method = :none, ): no correction is performed. This is not recommended, as the resulting approximation will be inaccurate if the kernel is singular and source and target are not sufficiently far from each other.\n(method = :adaptive, maxdist, tol): correct interactions corresponding to entries of target and elements of source that are within maxdist of each other. The singular (including finite part) interactions are computed in polar coordinates, while the near-singular interactions are computing using an adaptive quadrature rule. The tol argument specifies the tolerance of the adaptive integration. See adaptive_correction for more details.\n(method = :dim, maxdist, target_location): use the density interpolation method to compute the correction. maxdist specifies the distance between source and target points above which no correction is performed (defaults to Inf). target_location should be either :inside, :outside, or :on, and specifies where the targetpoints lie relative to the to thesourcecurve/surface (which is assumed to be closed). Whentarget === source,targetlocationis not needed. See [bdimcorrection](@ref) and [vdim_correction`] for more details.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.single_double_layer_potential-Tuple{}","page":"Docstrings","title":"Inti.single_double_layer_potential","text":"single_double_layer_potential(; op, source)\n\nReturn the single- and double-layer potentials for op as IntegralPotentials.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.singularity_order-Tuple{Any}","page":"Docstrings","title":"Inti.singularity_order","text":"singularity_order(K)\n\nGiven a kernel K with signature K(target,source)::T, return the order of the singularity of K at target = source. Order n means that K(x,y) ∼ (x - y)^n as x -> y.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.skeleton-Tuple{Inti.Domain}","page":"Docstrings","title":"Inti.skeleton","text":"skeleton(Ω::Domain)\n\nReturn all the boundaries of the domain, i.e. the domain's skeleton.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.stack_weakdeps_env!-Tuple{}","page":"Docstrings","title":"Inti.stack_weakdeps_env!","text":"stack_weakdeps_env!(; verbose = false, update = false)\n\nPush to the load stack an environment providing the weak dependencies of Inti.jl. This allows benefiting from additional functionalities of Inti.jl which are powered by weak dependencies without having to manually install them in your environment.\n\nSet update=true if you want to update the weakdeps environment.\n\nwarning: Warning\nCalling this function can take quite some time, especially the first time around, if packages have to be installed or precompiled. Run in verbose mode to see what is happening.\n\nExamples:\n\nInti.stack_weakdeps_env!()\nusing HMatrices\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.standard_basis_vector-Union{Tuple{N}, Tuple{Any, Val{N}}} where N","page":"Docstrings","title":"Inti.standard_basis_vector","text":"standard_basis_vector(k, ::Val{N})\n\nCreate an SVector of length N with a 1 in the kth position and zeros elsewhere.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.svector-Union{Tuple{F}, Tuple{F, Any}} where F","page":"Docstrings","title":"Inti.svector","text":"svector(f,n)\n\nCreate an SVector of length n, computing each element as f(i), where i is the index of the element.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.torus-Tuple{}","page":"Docstrings","title":"Inti.torus","text":"torus(; r, R, translation, rotation, scaling, labels)\n\nCreate a torus entity in 3D, and apply optional transformations. Returns the key. The parameters r and R are the inner and outer radii of the torus.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.uniform_points_circle-Tuple{Any, Any, Any}","page":"Docstrings","title":"Inti.uniform_points_circle","text":"uniform_points_circle(N,r,c)\n\nReturn N points uniformly distributed on a circle of radius r centered at c.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.vdim_correction-Union{Tuple{SHIFT}, Tuple{Any, Any, Inti.Quadrature, Inti.Quadrature, Any, Any, Any}} where SHIFT","page":"Docstrings","title":"Inti.vdim_correction","text":"vdim_correction(op,X,Y,Y_boundary,S,D,V; green_multiplier, kwargs...)\n\nCompute a correction to the volume potential V : Y → X such that V + δV is a more accurate approximation of the underlying volume potential operator. The correction is computed using the (volume) density interpolation method.\n\nThis function requires a op::AbstractDifferentialOperator, a target set X, a source quadrature Y, a boundary quadrature Y_boundary, approximations S : Y_boundary -> X and D : Y_boundary -> X to the single- and double-layer potentials (correctly handling nearly-singular integrals), and a naive approximation of the volume potential V. The green_multiplier is a vector of the same length as X storing the value of μ(x) for x ∈ X in the Green identity (see _green_multiplier).\n\nSee [11] for more details on the method.\n\nOptional kwargs:\n\ninterpolation_order: the order of the polynomial interpolation. By default, the maximum order of the quadrature rules is used.\nmaxdist: distance beyond which interactions are considered sufficiently far so that no correction is needed. This is used to determine a threshold for nearly-singular corrections.\ncenter: the center of the basis functions. By default, the basis functions are centered at the origin.\nshift: a boolean indicating whether the basis functions should be shifted and rescaled to each element.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.vdim_mesh_center-Tuple{Inti.AbstractMesh}","page":"Docstrings","title":"Inti.vdim_mesh_center","text":"vdim_mesh_center(msh)\n\nPoint x which minimizes ∑ (x-xⱼ)²/r²ⱼ, where xⱼ and rⱼ are the circumcenter and circumradius of the elements of msh, respectively.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.vertices-Tuple{Inti.LagrangeElement}","page":"Docstrings","title":"Inti.vertices","text":"vertices(el::LagrangeElement)\n\nCoordinates of the vertices of el.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.vertices_idxs-Tuple{Type{<:Inti.LagrangeElement{Inti.ReferenceHyperCube{1}}}}","page":"Docstrings","title":"Inti.vertices_idxs","text":"vertices_idxs(el::LagrangeElement)\n\nThe indices of the nodes in el that define the vertices of the element.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Inti.volume_potential-Tuple{}","page":"Docstrings","title":"Inti.volume_potential","text":"volume_potential(; op, target, source::Quadrature, compression, correction)\n\nCompute the volume potential operator for a given PDE.\n\nArguments\n\nop: The PDE (Partial Differential Equation) to solve.\ntarget: The target domain where the potential is computed.\nsource: The source domain where the potential is generated.\ncompression: The compression method to use for the potential operator.\ncorrection: The correction method to use for the potential operator.\n\nReturns\n\nThe volume potential operator V that represents the interaction between the target and source domains.\n\nCompression\n\nThe compression argument is a named tuple with a method field followed by method-specific fields. It specifies how the dense linear operators should be compressed. The available options are:\n\n(method = :none, ): no compression is performed, the resulting matrices are dense.\n(method =:hmatrix, tol): the resulting operators are compressed using hierarchical matrices with an absolute tolerance tol (defaults to 1e-8).\n(method = :fmm, tol): the resulting operators are compressed using the fast multipole method with an absolute tolerance tol (defaults to 1e-8).\n\nCorrection\n\nThe correction argument is a named tuple with a method field followed by method-specific fields. It specifies how the singular and nearly-singular integrals should be computed. The available options are:\n\n(method = :none, ): no correction is performed. This is not recommented, as the resulting approximation will be inaccurate if the source and target are not sufficiently far apart.\n(method = :dim, maxdist, target_location): use the density interpolation method to compute the correction. maxdist specifies the distance between source and target points above which no correction is performed (defaults to Inf). target_location should be either :inside, :outside, or :on, and specifies where the targetpoints lie relative to the to thesource's boundary. Whentarget === source,target_location` is not needed.\n\nDetails\n\nThe volume potential operator is computed by assembling the integral operator V using the single-layer kernel G. The operator V is then compressed using the specified compression method. If no compression is specified, the operator is returned as is. If a correction method is specified, the correction is computed and added to the compressed operator.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/compression_methods/#Compression-methods","page":"Compression methods","title":"Compression methods","text":"","category":"section"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"note: Important points covered in this tutorial\nOverview of the compression methods available in Inti.jl\nDetails and limitations of the various compression methods\nGuideline on how to choose a compression method","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"Inti.jl wraps several external libraries providing acceleration routines for integral operators. In general, acceleration routines have the signature assemble_*(iop, args...; kwargs...), and take an IntegralOperator as a first argument. They return a new object that represents a compressed version of the operator. The following methods are available:","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"assemble_matrix: create a dense Matrix representation of the integral operator. Not really a compression method, but useful for debugging and small problems.\nassemble_hmatrix: assemble a hierarchical matrix representation of the operator using the HMatrices library.\nassemble_fmm: return a LinearMap object that represents the operator using the fast multipole method. This method is powered by the FMM2D, FMMLIB2D and FMM3D libraries, and is only available for certain kernels.","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"warning: Singular kernels\nAcceleration methods do not correct for singular or nearly-singular interactions. When the underlying kernel is singular, a correction is usually necessary in order to obtain accurate results (see the section on correction methods for more details).","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"To demonstrate the use of compression methods, we will compress the single-layer operator for the Helmholtz equation on an ellipsoid. While compression methods may not be necessary for small problems like this, they become essential – and often indispensable – for tackling larger-scale problems efficiently.","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"using Inti\nusing LinearAlgebra\n# define the quadrature\ngeo = Inti.GeometricEntity(\"ellipsoid\")\nΩ = Inti.Domain(geo)\nΓ = Inti.boundary(Ω)\nQ = Inti.Quadrature(Γ; meshsize = 0.4, qorder = 5)\n# create the operator\nop = Inti.Helmholtz(; dim = 3, k = 2π)\nK = Inti.SingleLayerKernel(op)\nSop = Inti.IntegralOperator(K, Q, Q)\nx = rand(ComplexF64, length(Q))\nrtol = 1e-8\nnothing # hide","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"In what follows we compress Sop using the different methods available.","category":"page"},{"location":"tutorials/compression_methods/#Dense-matrix","page":"Compression methods","title":"Dense matrix","text":"","category":"section"},{"location":"tutorials/compression_methods/#Inti.assemble_matrix-tutorials-compression_methods","page":"Compression methods","title":"Inti.assemble_matrix","text":"assemble_matrix(iop::IntegralOperator; threads = true)\n\nAssemble a dense matrix representation of an IntegralOperator.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"Typically used for small problems, the dense matrix representation converts the IntegralOperator into a Matrix object. The underlying type of the Matrix is determined by the eltype of the IntegralOperator, and depends on the inferred type of the kernel. Here is how assemble_matrix can be used:","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"Smat = Inti.assemble_matrix(Sop; threads=true)\n@assert Sop * x ≈ Smat * x # hide\ner = norm(Sop * x - Smat * x, Inf) / norm(Sop * x, Inf)\nprintln(\"Forward map error: $er\")","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"Since the returned object is plain Julia Matrix, it can be used with any of the linear algebra routines available in Julia (e.g. \\, lu, qr, *, etc.)","category":"page"},{"location":"tutorials/compression_methods/#Hierarchical-matrix","page":"Compression methods","title":"Hierarchical matrix","text":"","category":"section"},{"location":"tutorials/compression_methods/#Inti.assemble_hmatrix-tutorials-compression_methods","page":"Compression methods","title":"Inti.assemble_hmatrix","text":"assemble_hmatrix(iop[; atol, rank, rtol, eta])\n\nAssemble an H-matrix representation of the discretized integral operator iop using the HMatrices.jl library.\n\nSee the documentation of HMatrices for more details on usage and other keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"The hierarchical matrix representation is a compressed representation of the underlying operator; as such, it takes a tolerance parameter that determines the relative error of the compression. Here is an example of how to use the assemble_hmatrix method to compress the previous problem:","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"using HMatrices\nShmat = Inti.assemble_hmatrix(Sop; rtol = 1e-8)\ner = norm(Smat * x - Shmat * x, Inf) / norm(Smat * x, Inf)\n@assert er < 10*rtol # hide\nprintln(\"Forward map error: $er\")","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"Note that HMatrices are said to be kernel-independent, meaning that they efficiently compress a wide range of integral operators provided they satisfy a certain asymptotic smoothness criterion (see e.g. [3, 4]).","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"The HMatrix object can be used to solve linear systems, both iteratively through e.g. GMRES, or directly using an LU factorization.","category":"page"},{"location":"tutorials/compression_methods/#Fast-multipole-method","page":"Compression methods","title":"Fast multipole method","text":"","category":"section"},{"location":"tutorials/compression_methods/#Inti.assemble_fmm-tutorials-compression_methods","page":"Compression methods","title":"Inti.assemble_fmm","text":"assemble_fmm(iop; rtol)\n\nSet up a 2D or 3D FMM for evaluating the discretized integral operator iop associated with the op. In 2D the FMM2D or FMMLIB2D library is used (whichever was most recently loaded) while in 3D FMM3D is used.\n\nwarning: FMMLIB2D\nFMMLIB2D does no checking for if the targets and sources coincide, and will return Inf values if iop.target !== iop.source, but there is a point x ∈ iop.target such that x ∈ iop.source.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"The fast multipole method (FMM) is an acceleration technique based on an analytic multipole expansion of the kernel in the integral operator [5, 6]. It provides a very memory-efficient and fast way to evaluate certain types of integral operators. Here is how assemble_fmm can be used:","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"using FMM3D\nSfmm = Inti.assemble_fmm(Sop; rtol = 1e-8)\ner = norm(Sop * x - Sfmm * x, Inf) / norm(Sop * x, Inf)\n@assert er < 10*rtol # hide\nprintln(\"Forward map error: $er\")","category":"page"},{"location":"tutorials/compression_methods/#Tips-on-choosing-a-compression-method","page":"Compression methods","title":"Tips on choosing a compression method","text":"","category":"section"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"The choice of compression method depends on the problem at hand, as well as on the available hardware. Here is a rough guide on how to choose a compression:","category":"page"},{"location":"tutorials/compression_methods/","page":"Compression methods","title":"Compression methods","text":"For small problems (say less than 5k degrees of freedom), use the dense matrix representation. It is the simplest and most straightforward method, and does not require any additional packages. It is also the most accurate since it does not introduce any additional approximation errors.\nIf the integral operator is supported by the assemble_fmm, and if an iterative solver is acceptable, use it. The FMM is a very efficient method for certain types of kernels, and can handle problems with up to a few million degrees of freedom on a laptop.\nIf the kernel is not supported by assemble_fmm, if iterative solvers are not an option, or if the system needs solution for many right-hand sides, use the assemble_hmatrix method. It is a very general method that can handle a wide range of kernels, and although assembling the HMatrix can be time and memory consuming (the complexity is still log-linear in the DOFs for many kernels of interest, but the constants can be large), the resulting HMatrix object is very efficient to use. For example, the forward map is usually significantly faster than the one obtained through assemble_fmm.","category":"page"},{"location":"tutorials/correction_methods/#Correction-methods","page":"Correction methods","title":"Correction methods","text":"","category":"section"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"note: Important Points Covered in This Tutorial\nOverview of the correction methods available in Inti.jl.\nDetails and limitations of the various correction methods.\nGuidelines on how to choose a correction method.","category":"page"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"When the underlying kernel is singular, a correction is usually necessary to obtain accurate results in the approximation of the underlying integral operator by a quadrature. Currently, Inti.jl provides the following functions to correct for singularities:","category":"page"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"adaptive_correction\nbdim_correction\nvdim_correction","category":"page"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"Each method has its own strengths and weaknesses, which will be discussed in the following sections.","category":"page"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"note: High-Level API\nThe single_double_layer, adj_double_layer_hypersingular, and volume_potential functions provide a high-level API with a correction keyword argument. This allows users to specify the correction method to use when constructing the integral operators. See the documentation of these functions for more details.","category":"page"},{"location":"tutorials/correction_methods/#Adaptive-Correction","page":"Correction methods","title":"Adaptive Correction","text":"","category":"section"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"The adaptive_correction method combines adaptive quadrature for nearly singular integrals with a direct evaluation method for singular integrals, based on [7]. It is a robust method suitable for a wide range of kernels, as long as the singularities are no worse than a Hadamard finite-part (e.g., 1r^3 in 3D and 1r^2 in 2D). This makes it a good default choice for most problems.","category":"page"},{"location":"tutorials/correction_methods/#Strengths","page":"Correction methods","title":"Strengths","text":"","category":"section"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"Robust method that works for a wide range of kernels.\nConceptually straightforward and easy to use.\nHandles open surfaces.","category":"page"},{"location":"tutorials/correction_methods/#Weaknesses","page":"Correction methods","title":"Weaknesses","text":"","category":"section"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"Can be slow for large problems and high accuracy requirements.\nSometimes difficult to tune parameters for optimal performance.\nRound-off errors in certain cases can make achieving high accuracy challenging.","category":"page"},{"location":"tutorials/correction_methods/#Docstrings","page":"Correction methods","title":"Docstrings","text":"","category":"section"},{"location":"tutorials/correction_methods/#Inti.adaptive_correction-tutorials-correction_methods","page":"Correction methods","title":"Inti.adaptive_correction","text":"adaptive_correction(iop::IntegralOperator; [maxdist, rtol, threads = true, kwargs...])\nadaptive_correction(iop::IntegralOperator, maxdist, quads_dict::Dict, threads = true)\n\nThis function computes a sparse correction for the integral operator iop, addressing its singular or nearly singular entries.\n\nThe parameter maxdist specifies the maximum distance between target points  and source elements to be considered for correction (only interactions within this distance are corrected).\n\nThe parameter rtol defines the tolerance for the adaptive quadrature used to compute the corrections for singular or nearly singular entries.\n\nAdditional kwargs arguments are passed to adaptive_quadrature; see its documentation for more information.\n\nSelecting maxdist and rtol involves balancing accuracy and computational cost. A smaller maxdist reduces the number of corrections but may impact accuracy. Conversely, a smaller rtol improves correction accuracy but increases computational expense. The ideal values for maxdist and rtol depend on the kernel and the mesh/quadrature rule applied.\n\nBy default, maxdist and rtol are estimated using the local_correction_dist_and_tol, but it is often possible to improve performance by manually tunning these parameters.\n\nAdvanced usage\n\nFor finer control, you can provide a dictionary quads_dict that contains quadrature rules for each reference element type present in the mesh of source(iop). This allows you to fine-tune the quadrature rules for specific element types (e.g. use a fixed quadrature rule instead of an adaptive one).\n\nThe dictionary quads_dict must adhere to the following structure:\n\nquads_dict[E].nearfield_quad: A function that integrates over the nearfield of the reference element type E. Used in the nearly-singular correction.\nquads_dict[E].radial_quad: A function that integrates over the radial direction of the reference element type E. Used in the singular correction.\nquads_dict[E].angular_quad: A function that integrates over the angular direction of the reference element type E. Used in the singular correction.\n\nHere is an example of how to implement a custom quads_dict given an iop:\n\nquads_dict = Dict()\nmsh = Inti.mesh(source(iop))\nfor E in Inti.element_types(msh)\n    ref_domain = Inti.reference_domain(E)\n    quads = (\n        nearfield_quad = Inti.adaptive_quadrature(ref_domain; atol),\n        radial_quad    = Inti.GaussLegendre(;order=5),\n        angular_quad   = Inti.GuassLegendre(;order=20),\n    )\n    quads_dict[E] = quads\nend\n\nThis will use an adaptive quadrature rule for the nearfield and fixed Gauss-Legendre quadrature rules for the radial and angular directions when computing the singular correction in polar coordinates on the reference domain. You can then call adaptive_correction(iop, maxdist, quads_dict) to use the custom quadrature.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/correction_methods/#Boundary-Density-Interpolation-Method","page":"Correction methods","title":"Boundary Density Interpolation Method","text":"","category":"section"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"The bdim_correction method implements the general-purpose version of the density interpolation method proposed in [8]. Is a global correction method that uses solutions of the underlying PDE, together with Green's identities, to interpolate the density on the boundary. It works best for low to moderate-order quadratures and is particularly useful for smooth boundaries when the PDE.","category":"page"},{"location":"tutorials/correction_methods/#Strengths-2","page":"Correction methods","title":"Strengths","text":"","category":"section"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"Can be faster and more accurate for standard problems, such as scattering by closed surfaces.\nEasier parameter tuning, as it only requires knowing whether the target surface is inside, outside, or on the boundary of the source.","category":"page"},{"location":"tutorials/correction_methods/#Weaknesses-2","page":"Correction methods","title":"Weaknesses","text":"","category":"section"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"Only suitable for closed surfaces.\nThe underlying kernel must be related to the fundamental solution of a PDE.","category":"page"},{"location":"tutorials/correction_methods/#Docstrings-2","page":"Correction methods","title":"Docstrings","text":"","category":"section"},{"location":"tutorials/correction_methods/#Inti.bdim_correction-tutorials-correction_methods","page":"Correction methods","title":"Inti.bdim_correction","text":"bdim_correction(op,X,Y,S,D; green_multiplier, kwargs...)\n\nGiven a op and a (possibly inaccurate) discretizations of its single and double-layer operators S and D (taking a vector of values on Y and returning a vector on of values on X), compute corrections δS and δD such that S + δS and D + δD are more accurate approximations of the underlying single- and double-layer integral operators.\n\nSee [8] for more details on the method.\n\nArguments\n\nRequired:\n\nop must be an AbstractDifferentialOperator\nY must be a Quadrature object of a closed surface\nX is either inside, outside, or on Y\nS and D are approximations to the single- and double-layer operators for op taking densities in Y and returning densities in X.\ngreen_multiplier (keyword argument) is a vector with the same length as X storing the value of μ(x) for x ∈ X in the Green identity S\\[γ₁u\\](x) - D\\[γ₀u\\](x) + μ*u(x) = 0. See _green_multiplier.\n\nOptional kwargs:\n\nparameters::DimParameters: parameters associated with the density interpolation method\nderivative: if true, compute the correction to the adjoint double-layer and hypersingular operators instead. In this case, S and D should be replaced by a (possibly innacurate) discretization of adjoint double-layer and hypersingular operators, respectively.\nmaxdist: distance beyond which interactions are considered sufficiently far so that no correction is needed. This is used to determine a threshold for nearly-singular corrections when X and Y are different surfaces. When X === Y, this is not needed.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/correction_methods/#Volume-density-interpolation-method","page":"Correction methods","title":"Volume density interpolation method","text":"","category":"section"},{"location":"tutorials/correction_methods/","page":"Correction methods","title":"Correction methods","text":"TODO","category":"page"},{"location":"tutorials/geo_and_meshes/#Geometry-and-meshes","page":"Geometry and meshes","title":"Geometry and meshes","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"note: Important points covered in this tutorial\nCombine simple shapes to create domains\nImport a mesh from a file\nIterative over mesh elements","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"In the getting started tutorial, we saw how to solve a simple Helmholtz scattering problem in 2D. We will now dig deeper into how to create and manipulate more complex geometrical shapes, as well the associated meshes.","category":"page"},{"location":"tutorials/geo_and_meshes/#Overview","page":"Geometry and meshes","title":"Overview","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Inti.jl provides a flexible way to define geometrical entities and their associated meshes. Simply put, the GeometricEntity type is the atomic building block of geometries: they can represent points, curves, surfaces, or volumes. Geometrical entities of the same dimension can be combined to form Domain, and domains can be manipulated using basic set operations such union and intersection. Meshes on the other hand are collections of (simple) elements that approximate the geometrical entities. A mesh element is a just a function that maps points from a ReferenceShape to the physical space.","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"In most applications involving complex three-dimensional surfaces, an external meshing software is used to generate a mesh, and the mesh is imported using the import_mesh function (which relies on Gmsh). The entities can then be extracted from the mesh based on e.g. their dimension or label. Here is an example of how to import a mesh from a file:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"using Inti\nusing Gmsh \nfilename = joinpath(Inti.PROJECT_ROOT,\"docs\", \"assets\", \"piece.msh\")\nmsh = Inti.import_mesh(filename)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"The imported mesh contains elements of several types, used to represent the segments, triangles, and tetras used to approximate the geometry:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Inti.element_types(msh)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Note that the msh object contains all entities used to construct the mesh, usually defined in a .geo file, which can be extracted using the entities:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"ents = Inti.entities(msh)\nnothing # hide","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Filtering of entities satisfying a certain condition, e.g., entities of a given dimension or containing a certain label, can also be performed in order to construct a domain:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"filter = e -> Inti.geometric_dimension(e) == 3\nΩ = Inti.Domain(filter, ents)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Domains can be used to index the mesh, creating either a new object containing only the necessary elements:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Γ = Inti.boundary(Ω)\nmsh[Γ]","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"or a SubMesh containing a view of the mesh:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Γ_msh = view(msh, Γ)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Finally, we can visualize the mesh using:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"using Meshes, GLMakie\nfig = Figure(; size = (800,400))\nax = Axis3(fig[1, 1]; aspect = :data)\nviz!(Γ_msh; showsegments = true, alpha = 0.5)\nfig","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"warning: Mesh visualization\nNote that although the mesh may be of high order and/or conforming, the visualization of a mesh is always performed on the underlying first order mesh, and therefore elements may look flat even if the problem is solved on a curved mesh.","category":"page"},{"location":"tutorials/geo_and_meshes/#Parametric-entities-and-meshgen","page":"Geometry and meshes","title":"Parametric entities and meshgen","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"In the previous section we saw an example of how to import a mesh from a file, and how to extract the entities from the mesh. For simple geometries for which an explicit parametrization is available, Inti.jl provides a way to create and manipulate geometrical entities and their associated meshes.","category":"page"},{"location":"tutorials/geo_and_meshes/#Parametric-curves","page":"Geometry and meshes","title":"Parametric curves","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"The simplest parametric shapes are parametric_curves, which are defined by a function that maps a scalar parameter t to a point in 2D or 3D space. Parametric curves are expected to return an SVector, and can be created as follows:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"using StaticArrays\nl1 = Inti.parametric_curve(x->SVector(x, 0.1 * sin(2π * x)), 0.0, 1.0, labels = [\"l₁\"])","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"The object l1 represents a GeometricEntity with a known push-forward map:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Inti.pushforward(l1)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"For the sake of this example, let's create three more curves, and group them together to form a Domain:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"l2 = Inti.parametric_curve(x->SVector(1 + 0.1 * sin(2π * x), x), 0.0, 1.0, labels = [\"l₂\"])\nl3 = Inti.parametric_curve(x->SVector(1 - x, 1 - 0.1 * sin(2π * x)), 0.0, 1.0, labels = [\"l₃\"])\nl4 = Inti.parametric_curve(x->SVector(0.1 * sin(2π * x), 1 - x), 0.0, 1.0, labels = [\"l₄\"])\nΓ  = l1 ∪ l2 ∪ l3 ∪ l4","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Domains for which a parametric representation is available can be passed to the meshgen function:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"msh = Inti.meshgen(Γ; meshsize = 0.05)\nnothing # hide","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"We can use the Meshes.viz function to visualize the mesh, and use domains to index the mesh:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Γ₁ = l1 ∪ l3\nΓ₂ = l2 ∪ l4\nfig, ax, pl = viz(view(msh, Γ₁); segmentsize = 4,  label = \"Γ₁\")\nviz!(view(msh, Γ₂); segmentsize = 4, color = :red, label = \"Γ₂\")\nfig # hide","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Note that the orientation of the curve determines the direction of the normal vector. The normal points to the right of the curve when moving in the direction of increasing parameter t:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"pts, tangents, normals = Makie.Point2f[], Makie.Vec2f[], Makie.Vec2f[]\nfor l in [l1, l2, l3, l4]\n      push!(pts, l(0.5)) # mid-point of the curve \n      push!(tangents, vec(Inti.jacobian(l, 0.5)))\n      push!(normals,Inti.normal(l, 0.5))\nend\narrows!(pts, tangents, color = :blue, linewidth = 2, linestyle = :dash, lengthscale = 1/4, label = \"tangent\")\narrows!(pts, normals, color = :black, linewidth = 2, linestyle = :dash, lengthscale = 1/4, label = \"normal\")\naxislegend()\nfig # hide","category":"page"},{"location":"tutorials/geo_and_meshes/#Parametric-surfaces","page":"Geometry and meshes","title":"Parametric surfaces","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Like parametric curves, parametric surfaces are defined by a function that maps a reference domain D subset mathbbR^2 to a surface in 3D space. They can be constructed using the parametric_surface function:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"# a patch of the unit sphere\nlc = SVector(-1.0, -1.0)\nhc = SVector(1.0, 1.0)\nf = (u,v) -> begin\n      x = SVector(1.0, u, v)   # a face of the cube\n      x ./ sqrt(u^2 + v^2 + 1) # project to the sphere\nend\npatch = Inti.parametric_surface(f, lc, hc, labels = [\"patch1\"])\nΓ  = Inti.Domain(patch)\nmsh = Inti.meshgen(Γ; meshsize = 0.1)\nviz(msh[Γ]; showsegments = true, figure = (; size = (400,400),))","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Since creating parametric surfaces that form a closed volume can be a bit more involved, Inti.jl provide a few helper functions to create simple shapes:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"fig = Figure(; size = (600,400))\nnshapes = Inti.length(Inti.PREDEFINED_SHAPES)\nncols = 3; nrows = ceil(Int, nshapes/ncols)\nfor (n,shape) in enumerate(Inti.PREDEFINED_SHAPES)\n      Ω = Inti.GeometricEntity(shape) |> Inti.Domain\n      Γ = Inti.boundary(Ω)\n      msh = Inti.meshgen(Γ; meshsize = 0.1)\n      i,j = (n-1) ÷ ncols + 1, (n-1) % ncols + 1\n      ax = Axis3(fig[i,j]; aspect = :data, title = shape)\n      hidedecorations!(ax)\n      viz!(msh; showsegments = true)\nend\nfig # hide","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"See GeometricEntity(shape::String) for a list of predefined geometries.","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"warning: Mesh quality\nThe quality of the generated mesh created through meshgen depends   heavily on the quality of the underlying parametrization. For surfaces   containing a degenerate parametrization, or for complex shapes, one is   better off using a suitable CAD (Computer-Aided Design) software in   conjunction with a mesh generator.","category":"page"},{"location":"tutorials/geo_and_meshes/#Transfinite-domains","page":"Geometry and meshes","title":"Transfinite domains","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"It is possible to combine parametric curves/surfaces to form a transfinite domain where the parametrization is inherited from the curves/surfaces that form its boundary. At present, Inti.jl only supports transfinite squares, which are defined by four parametric curves:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"l1 = Inti.parametric_curve(x->SVector(x, 0.1 * sin(2π * x)), 0.0, 1.0, labels = [\"l₁\"])\nl2 = Inti.parametric_curve(x->SVector(1 + 0.1 * sin(2π * x), x), 0.0, 1.0, labels = [\"l₂\"])\nl3 = Inti.parametric_curve(x->SVector(1 - x, 1 - 0.1 * sin(2π * x)), 0.0, 1.0, labels = [\"l₃\"])\nl4 = Inti.parametric_curve(x->SVector(0.1 * sin(2π * x), 1 - x), 0.0, 1.0, labels = [\"l₄\"])\nsurf = Inti.transfinite_square(l1, l2, l3, l4; labels = [\"Ω\"])\nΩ = Inti.Domain(surf)\nmsh = Inti.meshgen(Ω; meshsize = 0.05)\nviz(msh; showsegments = true)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Note that the msh object contains all entities used to construct Ω, including the boundary segments:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Inti.entities(msh)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"This allows us to probe the msh object to extract e.g. the boundary mesh:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"viz(msh[Inti.boundary(Ω)]; color = :red)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"warning: Limitations\nAt present only the transfinite interpolation for the logically   quadrilateral domains is supported. In the future we hope to add support   for three-dimensional transfinite interpolation, as well as transfinite   formulas for simplices.","category":"page"},{"location":"tutorials/geo_and_meshes/#Elements-of-a-mesh","page":"Geometry and meshes","title":"Elements of a mesh","text":"","category":"section"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"To iterate over the elements of a mesh, use the elements function:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"filename = joinpath(Inti.PROJECT_ROOT,\"docs\", \"assets\", \"piece.msh\")\nmsh = Inti.import_mesh(filename)\nents = Inti.entities(msh)\nΩ = Inti.Domain(e -> Inti.geometric_dimension(e) == 3, ents) \nels = Inti.elements(view(msh, Ω))\ncenters = map(el -> Inti.center(el), els)\nfig = Figure(; size = (800,400))\nax = Axis3(fig[1, 1]; aspect = :data)\nscatter!([c[1] for c in centers], [c[2] for c in centers], [c[3] for c in centers], markersize = 5)\nfig # hide","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"This example shows how to extract the centers of the tetrahedral elements in the mesh; and of course we can perform any desired computation on the elements.","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"tip: Type-stable iteration over elements\nSince a mesh in Inti.jl can contain elements of various types, the   elements function above is not type-stable. For a type-stable iterator   approach, one should first iterate over the element types using   element_types, and then use elements(msh, E) to iterate over a   specific element type E.","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Under the hood, each element is simply a functor which maps points x̂ from a ReferenceShape into the physical space:","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"el = first(els)\nx̂ = SVector(1/3,1/3, 1/3)\nel(x̂)","category":"page"},{"location":"tutorials/geo_and_meshes/","page":"Geometry and meshes","title":"Geometry and meshes","text":"Likewise, we can compute the jacobian of the element, or its normal at a given parametric coordinate.","category":"page"},{"location":"examples/stokes_drag/#Stokes-Drag","page":"Stokes drag","title":"Stokes Drag","text":"","category":"section"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"note: Important points covered in this example\nSolving a vector-valued problem\nUsage of curved triangular mesh\nPost-processing integral quantities","category":"page"},{"location":"examples/stokes_drag/#Problem-description","page":"Stokes drag","title":"Problem description","text":"","category":"section"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"In this example, we solve the classical Stokes drag problem, which models the drag force experienced by a sphere moving through a viscous fluid. The governing equations are the Stokes equations:","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"beginalign*\n-nabla p + mu Delta mathbfu = 0 quad  textin  Omega^c \nnabla cdot mathbfu = 0 quad  textin  Omega^c\nendalign*","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"where:","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"mathbfu is the velocity field,\np is the pressure,\nmu is the dynamic viscosity,\nOmega is the sphere, and Omega^c = mathbbR^3 setminus overlineOmega is the fluid domain.","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"The boundary conditions are:","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"mathbfu = mathbfU on the sphere's surface, where mathbfU is the velocity of the sphere. This is a no-slip condition.\nmathbfu to mathbf0 at infinity, which means that the fluid is at rest far away from the sphere.","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"The drag force experienced by the sphere is described by Stokes' law:","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"mathbfF_d = -6pimu R mathbfU","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"where R is the sphere's radius. This drag force, mathbfF_d, is the primary quantity of interest in this example. We will compute it using Hebeker's formulation [9], which expresses the velocity field mathbfu as a combination of single- and double-layer potentials:","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"mathbfu(mathbfx) = mathcalDboldsymbolsigma(mathbfx) + eta mathcalSboldsymbolsigma(mathbfx)","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"Here, boldsymbolsigma is the unknown density, mathcalS and mathcalD denote the single- and double-layer potentials, respectively, and eta  0 is a coupling parameter, which we set to eta = mu throughout this example.","category":"page"},{"location":"examples/stokes_drag/#Discretization","page":"Stokes drag","title":"Discretization","text":"","category":"section"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"To discretize the boundary Gamma = partial Omega, we employ a second-order triangular mesh created using Gmsh:","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"using Inti, Gmsh\nmeshsize = 0.4\nR = 2.0\ngmsh.initialize()\ngmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\ngmsh.model.occ.addSphere(0, 0, 0, R)\ngmsh.model.occ.synchronize()\ngmsh.model.mesh.generate(2)\ngmsh.model.mesh.setOrder(2)\nmsh = Inti.import_mesh()\ngmsh.finalize()\nnothing # hide","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"tip: Second-order mesh\nUsing gmsh.model.mesh.setOrder(2) creates a second-order mesh, which is crucial for accurately capturing the curved surface of the sphere and significantly enhances the numerical solution's precision. For simple geometries like spheres, an exact (isogeometric) representation can also be achieved using Inti's parametric entities. See the Geometry and meshes section for more details.","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"Next we extract the Domain Gamma from the mesh, and create a Quadrature on it:","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"Ω = Inti.Domain(e -> Inti.geometric_dimension(e) == 3, Inti.entities(msh)) # the 3D volume\nΓ = Inti.boundary(Ω) # its boundary\nΓ_msh = view(msh, Γ)\nΓ_quad = Inti.Quadrature(Γ_msh; qorder = 2) # quadrature on the boundary\nnothing # hide","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"With the quadrature prepared, we can now define the Stokes operator along with its associated integral operators. We use the FMM3D library to accelerate the evaluation of the integral operators:","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"using FMM3D\n# pick a correction and compression method\ncorrection = (method = :adaptive, )\ncompression = (method = :fmm, )\n\n# define the Stokes operator\nμ = η = 2.0\nop = Inti.Stokes(; dim = 3, μ)\n\n# assemble integral operators\nS, D = Inti.single_double_layer(;\n    op,\n    target = Γ_quad,\n    source = Γ_quad,\n    compression,\n    correction,\n)","category":"page"},{"location":"examples/stokes_drag/#Solution-and-drag-force-computation","page":"Stokes drag","title":"Solution and drag force computation","text":"","category":"section"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"We are now ready to set up and solve the problem. First, we define the boundary conditions (a constant velocity on the sphere):","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"using StaticArrays\nv = 2.0\nU = SVector(v,0,0)\nf = fill(U, length(Γ_quad))\nnothing # hide","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"To solve the linear system, we will use the gmres function from IterativeSolvers. Since the function requires scalar types, we need to convert the vector-valued quantities into scalars and vice versa. We can achieve this by using reinterpret to convert between the vector of SVectors and a vector of Float64s types.","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"using IterativeSolvers, LinearAlgebra, LinearMaps\nT = SVector{3, Float64} # vector type\nL = I/2 + D + η * S\nL_ = LinearMap{Float64}(3 * size(L, 1)) do y, x\n    σ = reinterpret(T, x)\n    μ = reinterpret(T, y)\n    mul!(μ, L, σ)\n    return y\nend\nσ  = zeros(T, length(Γ_quad))\nσ_ = reinterpret(Float64, σ)\nf_ = reinterpret(Float64, f)\n_, hist = gmres!(σ_, L_, f_; reltol = 1e-8, maxiter = 200, restart = 200, log = true)\n@assert hist.iters < 10 # hide\nhist","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"Note that gmres converges in very few iterations, highlighting the favorable spectral properties of the Hebeker formulation for this problem.","category":"page"},{"location":"examples/stokes_drag/#Drag-force-computation","page":"Stokes drag","title":"Drag force computation","text":"","category":"section"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"Now that we have the density σ, we can compute the drag force. As pointed out in [9, Theorem 2.4], the drag force of the body Omega is given by:","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"    mathbfF_d = eta int_Gamma boldsymbolsigma  dGamma","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"which can be approximated using our knowledge of σ and the quadrature Γ_quad:","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"drag = μ * sum(eachindex(Γ_quad)) do i\n    return σ[i] * Γ_quad[i].weight\nend","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"A quick comparison with the analytical solution indicates a good agreement.","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"exact = 6π * μ * R * U\nrelative_error = norm(drag - exact) / norm(exact)\n@assert relative_error < 1e-4 # hide\nprintln(\"Relative error: \", relative_error)","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"The relative error in this example is less than 1e-4, indicating that the numerical solution is very close to the analytical solution.","category":"page"},{"location":"examples/stokes_drag/#Visualization","page":"Stokes drag","title":"Visualization","text":"","category":"section"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"Finally, to visualize the flow field, we need to evaluate our integral representation at points off the boundary. The easiest way to achieve this is to use IntegralPotentials, or the convenient SingleLayerPotential and DoubleLayerPotential wrappers:","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"𝒮 = Inti.SingleLayerPotential(op, Γ_quad)\n𝒟 = Inti.DoubleLayerPotential(op, Γ_quad)\nu(x) = 𝒟[σ](x) + η*𝒮[σ](x) - U # fluid velocity relative to the sphere","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"In the code above, we have created a function u that evaluates the velocity at any point x:","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"u(SVector(1,2,3))","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"With u defined, we can visualize the flow field around the sphere. For this example we will simply sample points on a grid in the xz plane, and plot the velocity vectors at those points:","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"using Meshes\nusing GLMakie\nL = 5\ntargets     = [SVector(x, 0, z) for x in -L:meshsize:L, z in -L:meshsize:L] |> vec\nfilter!(x -> norm(x) > 1.1 * R, targets) # remove points inside or close to the sphere\ndirections  = u.(targets)\nstrength    = norm.(directions)\nfig = Figure(size = (1000, 800))\nax  = Axis3(fig[1, 1]; title = \"Velocity field\", aspect = :data, limits = ([-L, L], [-R, R], [-L, L]))\nviz!(msh[Γ], showsegments=true)\narrows!(ax, Point3.(targets), Point3.(directions), arrowsize = 0.15, lengthscale = 0.4, arrowcolor = strength, linecolor = strength)\ncurrent_figure()\nfig","category":"page"},{"location":"examples/stokes_drag/#Summary","page":"Stokes drag","title":"Summary","text":"","category":"section"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"This tutorial demonstrates how to solve the Stokes drag problem using the Inti library. The approach combines boundary integral equations with numerical quadrature and iterative solvers to compute the drag force on a sphere in a viscous fluid.","category":"page"},{"location":"examples/stokes_drag/","page":"Stokes drag","title":"Stokes drag","text":"tip: Extensions\nExperiment with different geometries or boundary conditions.\nUse higher-order quadrature for improved accuracy.\nExplore the effect of mesh refinement on the solution.","category":"page"},{"location":"examples/crack_elasticity/#Elastic-crack-in-2D","page":"Elastic crack","title":"Elastic crack in 2D","text":"","category":"section"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"note: Important points covered in this example\nSolving a problem with an open surface (crack)\nUsing the hypersingular operator\nDefining a custom kernel with a weight function\nDealing with vector-valued problems","category":"page"},{"location":"examples/crack_elasticity/#Problem-definition","page":"Elastic crack","title":"Problem definition","text":"","category":"section"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"In this example, we solve a disk crack problem in the context of linear elasticity using boundary integral equations. The problem involves determining the displacement jump field boldsymbolphi in an infinite elastic domain containing a disk-shaped crack. It is possible to show that the problem can be reduced to a boundary integral equation of the form (e.g. [10, Chapter 13]):","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"Tboldsymbolphi = -boldsymbolf","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"where T represents the integral operator associated with the hypersingular kernel, defined on the crack surface Gamma; boldsymbolf is the applied traction on the boundary, which is symmetric on the two crack lips; and boldsymbolphi is the so-called crack opening displacement (COD), defined as the \"displacement\" jump that occurs through the crack : boldsymbolphi=boldsymbol u^+-boldsymbol u^-.","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"details: Details\nBeing considered an open surface, the crack Gamma is arbitrarily extended onto a closed surface tildeGamma. Then, we consider boldsymbolu^+ and boldsymbolu^- as the interior and exterior displacements, depending on the convention used. The crack opening displacement is then defined as the difference between the two displacements at the two crack lips, mathematically superposed. It has to be understood as a mathematical limit of the displacement field as a point approaches one lip or the other. This method is called the Displacement Discontinuity Method.","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"This example demonstrates the formulation, solution, and visualization of the problem, highlighting the use of integral operators.","category":"page"},{"location":"examples/crack_elasticity/#Geometry-and-mesh","page":"Elastic crack","title":"Geometry and mesh","text":"","category":"section"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"The domain is a disk of radius 1 on the plane z=0. We use the GMSH library to create the mesh, and Inti's import_mesh function to import it.","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"using Inti\nusing StaticArrays\nusing Gmsh\n\nmeshsize = 0.2\nqorder  = 2 # avoid 3 since it contains a negative weight\nrx = ry = 1\ngmsh.initialize(String[], false)\ngmsh.option.setNumber(\"Mesh.MeshSizeMin\", meshsize)\ngmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\ngmsh.model.occ.addDisk(0.0, 0.0, 0.0, rx, ry)\ngmsh.model.occ.synchronize()\ngmsh.model.mesh.generate(2)\ngmsh.model.mesh.setOrder(1)\nmsh = Inti.import_mesh(; dim = 3)\nΓ = Inti.Domain(e -> Inti.geometric_dimension(e) == 2, msh)\nΓ_msh = msh[Γ]\nQ = Inti.Quadrature(Γ_msh; qorder = 2)\ngmsh.finalize()","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"Note that we have used second-order elements for the mesh, which is useful for better representing the edges of the circular crack.","category":"page"},{"location":"examples/crack_elasticity/#Integral-operators","page":"Elastic crack","title":"Integral operators","text":"","category":"section"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"We will now build an approximation to T using:","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"A hierarchical matrix representation for the integral operator\nAn adaptive correction to account for the singular and nearly singular interactions","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"using HMatrices\nusing LinearMaps\nusing LinearAlgebra\n#Elastic properties\nμ = 1; ν = 0.15;\nE = 2*μ*(1+ν)\nλ = ν*E / ((1+ν)*(1-2*ν))\nop = Inti.Elastostatic(; λ, μ, dim = 3)\nK = Inti.HyperSingularKernel(op)\nTop = Inti.IntegralOperator(K, Q)\nT₀ = Inti.assemble_hmatrix(Top)\nδT = Inti.adaptive_correction(Top)\nnothing # hide","category":"page"},{"location":"examples/crack_elasticity/#Boundary-conditions","page":"Elastic crack","title":"Boundary conditions","text":"","category":"section"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"For the boundary conditions, we consider a constant normal loading on the crack surface, simply given by:","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"f = 1.0\nt = -[SVector(0,0,f) for _ in Q]\nnothing # hide","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"Note that we used an SVector to represent the traction at a point on the crack surface. For vector-valued problems, SVectors and SMatrixs are often used to represent vectors and tensors, respectively, since their size is known at compile time (and small). This avoids the overhead of dynamic arrays.","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"We are now ready to compute the approximate solution.","category":"page"},{"location":"examples/crack_elasticity/#Solution","page":"Elastic crack","title":"Solution","text":"","category":"section"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"The exact solution for this problem can be obtained by separation of variables in cylindrical coordinates, and can be shown to be:","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"σ = 1\nφ₃(r) = 4*(1-ν)*σ / (π*μ) * sqrt(1-r^2)\nuexact(x) = SVector(0, 0, φ₃(norm(x)))","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"To compute the approximate solution, we will need to solve the linear system:","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"Tboldsymbolphi = boldsymbolf","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"where boldsymbolphi is the unknown vector of displacements. One difficulty that arises is related to the fact that in our implementation, both \\phi and f are represented as Vectors of SVectors. While convenient for some operations, this can lead to difficulties when trying to solve the linear system since most linear algebra libraries expect matrices over a scalar field (usually either mathbbR or mathbbC). To address this, we will write a short function solve that will convert between the vector of vectors and the vector of scalars.","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"using IterativeSolvers\nfunction solve!(u, T₀, δT, t)\n    @assert eltype(T₀) == eltype(δT) == SMatrix{3,3,Float64,9}\n    @assert eltype(t) == eltype(u) == SVector{3,Float64}\n    # write a LinearMap over scalars by reinterpreting them as vectors of SVectors, \n    # applying our operators T₀ and δT, and converting back before returning\n    L_ = LinearMap{Float64}(3 * size(T₀, 1)) do y, x\n        σ = reinterpret(SVector{3,Float64}, x)\n        μ = reinterpret(SVector{3,Float64}, y)\n        mul!(μ, T₀, σ)\n        mul!(μ, δT, σ, 1, 1)\n        return y\n    end\n    # flatten our input vectors and call gmres on the Float64 version\n    u_ = reinterpret(Float64, u)\n    t_ = reinterpret(Float64, t)\n    u_, gmres_hist = gmres!(u_, L_, t_, restart = 1000, maxiter = 1000, log=true)\n    @show gmres_hist\n    # since u_ is just a reinterpretation of u, we can simply return u when done\n    return u\nend\nsolve(T₀, δT, t) = solve!(zero(t), T₀, δT, t)","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"We can now easily call solve to obtain our approximate solution:","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"φ = solve(T₀, δT, t)\nnothing # hide","category":"page"},{"location":"examples/crack_elasticity/#Visualization","page":"Elastic crack","title":"Visualization","text":"","category":"section"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"Next we show a crude visualization by plotting the displacement value at each point of the quadrature (as a function of the radius), and comparing it to the exact solution. The displacement is a vector, but we will only plot the z component, which is the only one that is non-zero in this case.","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"using LinearAlgebra\nusing GLMakie\nr    = map(q -> norm(Inti.coords(q)), Q)\nvals = getindex.(φ, 3)\nscatter(r, vals, label = \"Numerical solution\")\nlines!(0:0.01:1, φ₃, label = \"Exact solution\", color = :red, linewidth = 4)\naxislegend()\ncurrent_figure()","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"Although the solution is not perfect, it captures the general behavior of the displacement field. One way to make the error smaller is to use a finer mesh and/or higher order quadrature. An alternative way, however, is to use a weight function to incorporate the singular behavior of the displacement field near the edge of the crack, as shown next.","category":"page"},{"location":"examples/crack_elasticity/#Improving-the-accuracy","page":"Elastic crack","title":"Improving the accuracy","text":"","category":"section"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"It is beneficial to add a weight function to help the solution being more accurate near the crack, where the displacement is singular, asymptotically equal to d^12 (d is the distance from a point to the crack front) according to the Williams' asymptotic expansion. For this simple example we take the weight function as:","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"w(boldsymbol x)=sqrt1-boldsymbol xundersetdrightarrow\n0simsqrtd(boldsymbol x)","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"weight(x) = sqrt(1 - norm(x))","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"and define a modified kernel K_w as:","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"Kw = let w = weight, K = K\n    (p,q) ->  K(p,q) * w(q.coords)\nend\nInti.singularity_order(::typeof(Kw)) = -3","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"With this new kernel, we can build our new integral operator T_w and solve the displacement jump equation for a modified density boldsymbolphi_w = boldsymbolphi  w:","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"Tw_op = Inti.IntegralOperator(Kw, Q)\nTw₀ = Inti.assemble_hmatrix(Tw_op)\nδTw = Inti.adaptive_correction(Tw_op; maxdist = 2*meshsize, atol = 1e-2)\nφw = solve(Tw₀, δTw, t)","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"We now plot the displacement field again, but this with the weighted kernel approach, and compare it to the previous approach. Note that we must multiply the solution φw by the weight function to obtain the actual displacement jump φ.","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"weights = [weight(q.coords) for q in Q]\nscatter(r, getindex.(φw,3) .* weights, label = \"Numerical solution (weighted)\")\nlines!(0:0.01:1, φ₃, label = \"Exact solution\", color = :red, linewidth = 4)\naxislegend()\ncurrent_figure()","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"The solution is now much more accurate, especially near the crack front, even though the same mesh and quadrature were used. This is a common technique in boundary integral equation: factoring out the asymptotic (non-smooth) behavior of the solution using a weight function.","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"Finally, we can visualize the displacement field on the mesh by interpolating the computed values on the quadrature points to the mesh nodes. We use Meshes to visualize the solution:","category":"page"},{"location":"examples/crack_elasticity/","page":"Elastic crack","title":"Elastic crack","text":"using Meshes\nφ3w_nodes = Inti.quadrature_to_node_vals(Q, getindex.(φw, 3))\nmsh_nodes = Inti.nodes(Q.mesh)\nw_nodes = [weight(x) for x in msh_nodes]\nφ3_nodes = φ3w_nodes .* w_nodes\ncolorrange = extrema(φ3_nodes)\nfig = Figure(; size = (800, 600))\nax = Axis3(fig[1, 1])\nn = length(Q.mesh.nodes)\nviz!(Q.mesh; color = φ3_nodes, interpolate = false, showsegments=true)\ncb = Colorbar(fig[1, 2]; label = \"φ₃\", colorrange)\nfig","category":"page"},{"location":"examples/heat_equation/#Heat-equation","page":"Heat equation","title":"Heat equation","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"note: Important points covered in this example\nUsing Rothe's method to solve a time-dependent PDE\nCombining volume and boundary integral equations for efficient solution\nHandling complex domains with holes\nAnimating the solution evolution using Makie","category":"page"},{"location":"examples/heat_equation/#Problem-description","page":"Heat equation","title":"Problem description","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"In this example, we'll solve the heat equation in a domain Omega with Dirichlet boundary conditions on Gamma = partial Omega.","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"beginalign*\n    partial_t u(xt) - Delta u(xt)  = f(xtu) quad  x in Omega quad t in 0T\n    u(xt) = g(xt) quad  x in Gamma quad t in 0T\n    u(x t = 0) = u_0(x) quad  x in Omega tagHeat equation\nendalign*","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"where:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"u(xt) represents temperature at position x and time t\nf(xtu) is a source/sink term (can depend on the solution itself for nonlinear problems)\ng(xt) specifies the Dirichlet boundary condition (prescribed temperature at the boundary)\nu_0(x) is the initial temperature distribution","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"The heat equation is a parabolic PDE, and we will solve it using Rothe's method (also known as the method of lines transpose). This approach first discretizes in time, reducing the problem to a sequence of elliptic PDEs which we then solve using integral equations. This contrasts with the method of lines, which discretizes in space first and solves the resulting ODEs.","category":"page"},{"location":"examples/heat_equation/#Solution-approach","page":"Heat equation","title":"Solution approach","text":"","category":"section"},{"location":"examples/heat_equation/#Overview","page":"Heat equation","title":"Overview","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Our solution strategy follows these key steps:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Time discretization: Apply backward Euler to convert the time-dependent PDE into a sequence of Yukawa equations\nSolution splitting: Decompose the solution into particular and homogeneous parts\nIntegral formulation: Use volume potentials for the particular solution and boundary integrals for the homogeneous solution\nDiscretization: Apply numerical quadrature to the integral operators\nTime stepping: Solve the sequence of spatial problems to march forward in time","category":"page"},{"location":"examples/heat_equation/#Time-discretization-(Rothe's-method)","page":"Heat equation","title":"Time discretization (Rothe's method)","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Following these lecture notes by Costabel, we first discretize time using an implicit scheme (backward Euler for simplicity):","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"beginalign*\nu^n - tauDelta u^n  = tau f^n-1 + u^n-1 quad  textin  Omega\nu^n = g^n quad  texton  partialOmega\nendalign*","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"where tau is the time step and an n superscript denotes the function value at time t = ntau (e.g. u^n(x) = u(x t = ntau)). ","category":"page"},{"location":"examples/heat_equation/#Converting-to-a-Yukawa-equation","page":"Heat equation","title":"Converting to a Yukawa equation","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Dividing both sides by tau we get a Yukawa (or modified Helmholtz) equation for the function u^n:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"beginalign*\n-Delta u^n + frac1tauu^n  = f^n-1 + fracu^n-1tau quad  textin  Omega\nu^n = g^n quad  texton  partialOmega tagYukawa equation\nendalign*","category":"page"},{"location":"examples/heat_equation/#Solution-decomposition","page":"Heat equation","title":"Solution decomposition","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"This is now amenable to an integral equation formulation. To do so we split the solution into a particular solution u^n_p and a homogeneous solution u^n_h:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"u^n = u^n_p + u^n_h","category":"page"},{"location":"examples/heat_equation/#The-particular-solution","page":"Heat equation","title":"The particular solution","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"The function u^n_p is given as a volume potential:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"u^n_p(x) = int_Omega G(x y) left( f(yt^n-1 u^n-1) + fracu^n-1(y)tau right)  mathrmdOmega(y) tagParticular solution","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"where G(xy) is the fundamental solution of the Yukawa operator.","category":"page"},{"location":"examples/heat_equation/#The-homogeneous-solution","page":"Heat equation","title":"The homogeneous solution","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"As for the homogeneous solution u^n_h, it satisfies:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"beginalign*\n-Delta u^n_h + frac1tau u^n_h = 0  quad textin  quad Omega \nu^n_h = g^n - u^n_p  quad texton   partialOmega tagHomogenous problem\nendalign*","category":"page"},{"location":"examples/heat_equation/#Boundary-integral-formulation","page":"Heat equation","title":"Boundary integral formulation","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"We'll use an indirect double-layer formulation, where we seek u^n_h in the form:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"u^n_h(r) = mathcalDsigma(r) quad r in Omega","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"with mathcalD the double-layer potential associated with the Yukawa equation, and sigma the unknown density. Taking the interior Dirichlet trace (for a smooth boundary) yields:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"frac-sigma(x)2 + Dsigma(x) = g^n(x) - u^n_p(x) quad x in partialOmega tagBIE","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"This boundary integral equation (BIE) allows us to solve for the density sigma on the boundary.","category":"page"},{"location":"examples/heat_equation/#Summary-of-the-solution-strategy","page":"Heat equation","title":"Summary of the solution strategy","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"The steps outlined above reduce the time-dependent heat equation to a sequence of forced Yukawa equations which can be solved using the same techniques as in the Poisson problem tutorial. For each time step:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Use the volume potential to compute the particular solution u^n_p\nSolve the BIE to find the density sigma\nApply the double-layer potential to compute the homogeneous solution u^n_h\nCombine the solutions: u^n = u^n_p + u^n_h","category":"page"},{"location":"examples/heat_equation/#Spatial-discretization","page":"Heat equation","title":"Spatial discretization","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"We now proceed to discretize the inhomogeneous Yukawa equation. We will use Gmsh to create a disk with a few holes in it, representing a domain with inclusions where heat can flow around but not through.","category":"page"},{"location":"examples/heat_equation/#Creating-the-mesh","page":"Heat equation","title":"Creating the mesh","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"using Inti\nusing Gmsh\nfunction create_mesh(meshsize, meshorder=2)\n\tgmsh.initialize()\n\tgmsh.option.setNumber(\"General.Verbosity\", 2)\n\tgmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\n\tdisk = gmsh.model.occ.addDisk(0, 0, 0, 1, 1)\n\tell1 = gmsh.model.occ.addDisk(.5, 0, 0, 0.2, 0.1)\n\tell2 = gmsh.model.occ.addDisk(-.5, 0.3, 0, 0.3, 0.2)\n\tgmsh.model.occ.rotate([(2,ell2)], 0, 0, 0, 0, 0, 1, -π/3)\n\tell3 = gmsh.model.occ.addDisk(-.5, -0.5, 0, 0.2, 0.15)\n\tgmsh.model.occ.rotate([(2,ell3)], 0, 0, 0, 0, 0, 1, π/3)\n\tgmsh.model.occ.cut([(2,disk)], [(2,ell1), (2,ell2), (2,ell3)])\n\tgmsh.model.occ.synchronize()\n\tgmsh.model.mesh.generate(2)\n\tgmsh.model.mesh.setOrder(meshorder)\n\tmsh = Inti.import_mesh(; dim = 2)\n\tgmsh.finalize()\n\treturn msh\nend\nmeshsize = 0.1\nmeshorder = 2\ntau       = 2π / 40\nmsh = create_mesh(meshsize, meshorder)","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"note: Mesh structure\nNote that msh contains all the elements of the generated mesh, including the boundary segments and any point entities that Gmsh may have created. To properly index into our mesh elements, we must use Domains, which are simply a collection of geometric entities.","category":"page"},{"location":"examples/heat_equation/#Extracting-domain-and-boundary","page":"Heat equation","title":"Extracting domain and boundary","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Since we will need to work with Omega and Gamma separately, we will extract those domains and their corresponding (sub)meshes:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Ω = Inti.Domain(e -> Inti.geometric_dimension(e) == 2, msh)\nΓ = Inti.boundary(Ω)\nΩ_msh = @views msh[Ω]\nΓ_msh = @views msh[Γ]\nnothing # hide","category":"page"},{"location":"examples/heat_equation/#Visualizing-the-geometry","page":"Heat equation","title":"Visualizing the geometry","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Let's visualize the mesh to confirm our domain setup. The red outline shows the boundary Gamma, which consists of both the outer boundary and the boundaries of the interior holes:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"using Meshes\nusing GLMakie\nfig = viz(\n    Ω_msh;\n    segmentsize = 1,\n    showsegments = true,\n    axis = (aspect = DataAspect(),),\n    figure = (; size = (500, 400)),\n)\nviz!(Γ_msh; color = :red, segmentsize = 4)\nfig # hide","category":"page"},{"location":"examples/heat_equation/#Setting-up-numerical-quadrature","page":"Heat equation","title":"Setting up numerical quadrature","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Now we create quadrature rules for both Omega and Gamma, which will be used to  accurately integrate our kernel functions over the domain and boundary:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Ω_quad = Inti.Quadrature(Ω_msh; qorder = 3)\nΓ_quad = Inti.Quadrature(Γ_msh; qorder = 3)\nnothing # hide","category":"page"},{"location":"examples/heat_equation/#Constructing-integral-operators","page":"Heat equation","title":"Constructing integral operators","text":"","category":"section"},{"location":"examples/heat_equation/#The-Yukawa-operator","page":"Heat equation","title":"The Yukawa operator","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"First, we define the Yukawa operator with parameter λ = 1sqrttau, which arises from our time discretization:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"λ = 1/sqrt(tau)\nop = Inti.Yukawa(; dim = 2, λ)","category":"page"},{"location":"examples/heat_equation/#Creating-the-integral-operators","page":"Heat equation","title":"Creating the integral operators","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Next, we construct four key integral operators needed to solve our problem:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Operator Type Purpose\nmathcalV_Omega to Omega Volume potential Computes the particular solution in the domain\nmathcalV_Omega to Gamma Volume potential Computes the trace of the particular solution on the boundary\nmathcalD_Gamma to Gamma Double-layer operator Solves for the density on the boundary\nmathcalD_Gamma to Omega Double-layer potential Computes the homogeneous solution in the domain","category":"page"},{"location":"examples/heat_equation/#Setting-operator-parameters","page":"Heat equation","title":"Setting operator parameters","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"For each operator, we specify compression and correction parameters:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"# using HMatrices\n# compression = (method = :hmatrix, atol = 1e-8)\ncorrection = (\n    method = :adaptive,\n    threads = true,\n    maxdist = 3 * meshsize,\n    atol = 1e-6,\n    maxsubdiv = 10_000,\n)\ncompression = (method = :none,)\nnothing # hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"tip: Performance optimization\nInstead of using a dense matrix representation of the integral operators, you would typically enable HMatrix compression for larger problems. The commented code shows how to configure it with appropriate tolerance parameters.","category":"page"},{"location":"examples/heat_equation/#Building-the-operators","page":"Heat equation","title":"Building the operators","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Let's create our operators:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"V_d2b = Inti.volume_potential(;\n\top,\n\ttarget = Γ_quad,\n\tsource = Ω_quad,\n\tcompression,\n\tcorrection,\n)\n_, D_b2b = Inti.single_double_layer(;\n\top,\n\ttarget = Γ_quad,\n\tsource = Γ_quad,\n\tcompression,\n\tcorrection\n)\nV_d2d = Inti.volume_potential(;\n\top,\n\ttarget = Ω_quad,\n\tsource = Ω_quad,\n\tcompression,\n\tcorrection,\n)\n_, D_b2d = Inti.single_double_layer(;\n\top,\n\ttarget = Ω_quad,\n\tsource = Γ_quad,\n\tcompression,\n\tcorrection\n)\nnothing # hide","category":"page"},{"location":"examples/heat_equation/#Time-evolution","page":"Heat equation","title":"Time evolution","text":"","category":"section"},{"location":"examples/heat_equation/#Factoring-the-boundary-integral-operator","page":"Heat equation","title":"Factoring the boundary integral operator","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Since our domain remains fixed throughout the simulation, we can factor the boundary integral operator to improve computational efficiency:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"using LinearAlgebra\nL = -I/2 + D_b2b\nF = lu(L)\nnothing # hide","category":"page"},{"location":"examples/heat_equation/#Verification-with-a-manufactured-solution","page":"Heat equation","title":"Verification with a manufactured solution","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"To verify our implementation, we'll first use the method of manufactured solutions. We choose a  known analytical solution u_e(xt) and derive the corresponding source term and boundary conditions:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"uₑ = (x, t) -> sin(x[1]) * sin(x[2]) * cos(t)\nf  = (x, t) -> 2 * uₑ(x, t) - sin(t) * sin(x[1]) * sin(x[2])\ng = (x, t) -> uₑ(x, t) # boundary values\nnothing # hide","category":"page"},{"location":"examples/heat_equation/#Time-stepping-algorithm","page":"Heat equation","title":"Time-stepping algorithm","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Now we perform the time-stepping loop for one full period (T = 2pi):","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"nsteps = round(Int, 2π/tau)\nuⁿ⁻¹ = map(q -> uₑ(q.coords, 0), Ω_quad) # initial condition\nuⁿ   = zero(uⁿ⁻¹)\nt    = Ref(0.0)\nfor n in 1:nsteps\n\t# 1. Evaluate source term at current time\n\tfⁿ  = map(q -> f(q.coords, t[] + tau), Ω_quad)\n\t\n\t# 2. Compute the particular solution\n\tuₚⁿ = V_d2d*(fⁿ + uⁿ⁻¹/tau)\n\t\n\t# 3. Evaluate boundary conditions\n\tgⁿ  = map(q -> g(q.coords, t[] + tau), Γ_quad)\n\t\n\t# 4. Solve BIE and compute homogeneous solution\n\tuₕⁿ = D_b2d * (F \\ (gⁿ - V_d2b * (fⁿ + uⁿ⁻¹ / tau)))\n\t\n\t# 5. Combine solutions and update for next time step\n\tuⁿ .= uₚⁿ + uₕⁿ\n\tuⁿ⁻¹ .= uⁿ\n\tt[] += tau\nend","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Let's check the accuracy of our solution by comparing with the exact solution:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"uref = map(q -> uₑ(q.coords, t[]), Ω_quad) # reference solution\ner = norm(uⁿ - uref, Inf) / norm(uref, Inf)\n@assert er < 1e-2 # hide\ner","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"A relative error of this magnitude confirms that our implementation is working correctly.","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"note: Convergence\nTesting that the error is \"small\" is just a basic verification. For rigorous validation, we should analyze the convergence order as we refine both spatial and temporal discretizations. For this example, the error is primarily determined by the first-order backward Euler scheme. Try halving the time step and observe how the error reduces approximately by a factor of 2!","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Now let's explore a more interesting scenario: heat flow in a domain with inclusions. We'll set the  temperature to zero at the outer boundary and apply a time-varying temperature of sin^2(t) at  the boundaries of the inclusions:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"f  = (x, t) -> 0.0\ng  = (x, t) -> norm(x) > 0.9 ? 0.0 : (sin(t))^2\nu⁰ = zeros(length(Ω_quad))\nnothing # hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"This physical setup models a scenario where the outer surface is kept at a constant cold temperature, while the inclusions have a periodically varying temperature - similar to heat sources that turn on and off.","category":"page"},{"location":"examples/heat_equation/#Visualizing-the-temperature-evolution","page":"Heat equation","title":"Visualizing the temperature evolution","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Here's the animation of the temperature distribution evolving over time:","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"fig = Figure()\nax = Axis(fig[1, 1]; aspect = DataAspect())\ncolorrange = (0.0, 1.0)\nrecord(fig, joinpath(@__DIR__,\"heat.gif\")) do io\n\tnsteps = round(Int, 2π/tau)\n\tuⁿ⁻¹ = u⁰\n\tuⁿ   = zero(uⁿ⁻¹)\n\tt    = 0.0\n\tfor n in 1:nsteps\n\t\t# Convert quadrature values to node values for visualization\n\t\tu_nodes = Inti.quadrature_to_node_vals(Ω_quad, uⁿ⁻¹)\n\t\t\n\t\t# Setup visualization for current frame\n\t\tax.title = \"Temperature at t = $(round(t, digits = 2))\"\n\t\tviz!(Ω_quad.mesh; showsegments = true, color = u_nodes, colorrange)\n\t\tviz!(Γ_msh; color = :black, segmentsize = 4)\n\t\tColorbar(fig[1, 2]; colorrange = colorrange, label = \"Temperature\")\n\t\t\n\t\t# Record current frame\n\t\trecordframe!(io)\n\t\t\n\t\t# Solve for next time step\n\t\tfⁿ  = map(q -> f(q.coords, t + tau), Ω_quad)\n\t\tuₚⁿ = V_d2d*(fⁿ + uⁿ⁻¹/tau)\n\t\tgⁿ  = map(q -> g(q.coords, t + tau), Γ_quad)\n\t\tuₕⁿ = D_b2d * (F \\ (gⁿ - V_d2b * (fⁿ + uⁿ⁻¹ / tau)))\n\t\tuⁿ = uₚⁿ + uₕⁿ\n\t\tuⁿ⁻¹ = uⁿ\n\t\tt += tau\n\tend\nend\nnothing # hide","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"(Image: Heat equation)","category":"page"},{"location":"examples/heat_equation/#Summary-and-extensions","page":"Heat equation","title":"Summary and extensions","text":"","category":"section"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"We've demonstrated how to solve the heat equation using Rothe's method combined with boundary integral equations. This approach effectively handles complex geometries and provides accurate solutions with reasonable computational cost.","category":"page"},{"location":"examples/heat_equation/","page":"Heat equation","title":"Heat equation","text":"tip: Going further\nTo extend this example, consider:Implementing a second-order time scheme (e.g., Crank-Nicolson) for improved accuracy\nUtilizing hierarchical matrix compression (HMatrix) for larger domains\nExploring more complex geometries or physical scenarios\nAdding nonlinear terms to model more complex physical phenomena","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"(Image: Pluto notebook)","category":"page"},{"location":"pluto-examples/poisson/#Poisson-Problem","page":"Poisson problem","title":"Poisson Problem","text":"","category":"section"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"note: Important points covered in this example\nReformulating Poisson-like problems using integral equations\nUsing volume potentials\nCreating interior meshes using Gmsh","category":"page"},{"location":"pluto-examples/poisson/#Problem-definition","page":"Poisson problem","title":"Problem definition","text":"","category":"section"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"In this example we will solve the Poisson equation in a domain Omega with Dirichlet boundary conditions on Gamma = partial Omega:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"  beginalign*\n      -Delta u = f  quad textin  quad Omega\n      u = g  quad texton  quad Gamma\n  endalign*","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"where f  Omega to mathbbR and g  Gamma to mathbbR are given functions. To solve this problem using integral equations, we split the solution u into a particular solution u_p and a homogeneous solution u_h:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"  u = u_p + u_h","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"The function u_p is given by","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"u_p(boldsymbolr) = int_Omega G(boldsymbolr boldsymbolr) f(boldsymbolr) dboldsymbolr","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"with G the fundamental solution of -Delta.","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"The function u_h satisfies the homogeneous problem","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"  beginalign*\n      Delta u_h = 0  quad textin  quad Omega \n      u_h = g - u_p  quad texton   quad Gamma\n  endalign*","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"which can be solved using the integral equation method. In particular, for this example, we employ a double-layer formulation:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"u_h(boldsymbolr) = int_Gamma G(boldsymbolr boldsymbolr) sigma(boldsymbolr) dboldsymbolr","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"where the density function sigma solves the integral equation","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"  -fracsigma(boldsymbolx)2 + int_Gamma partial_nu_boldsymbolyG(boldsymbolx boldsymboly) sigma(boldsymboly)  mathrmd s_boldsymboly = g(boldsymbolx) - u_p(boldsymbolx)","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"In what follows we illustrate how to solve the problem in this manner.","category":"page"},{"location":"pluto-examples/poisson/#Geometry-and-mesh","page":"Poisson problem","title":"Geometry and mesh","text":"","category":"section"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"We use the Gmsh API to create a jellyfish-shaped domain and to generate a second order mesh of its interior and boundary:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"using Inti, Gmsh\nmeshsize = 0.1\ngmsh.initialize()\njellyfish = Inti.gmsh_curve(0, 2π; meshsize) do s\n    r = 1 + 0.3 * cos(4 * s + 2 * sin(s))\n    return r * Inti.Point2D(cos(s), sin(s))\nend\ncl = gmsh.model.occ.addCurveLoop([jellyfish])\nsurf = gmsh.model.occ.addPlaneSurface([cl])\ngmsh.model.occ.synchronize()\ngmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\ngmsh.model.mesh.generate(2)\ngmsh.model.mesh.setOrder(2)\nmsh = Inti.import_mesh(; dim = 2)\ngmsh.finalize()","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"We can now extract components of the mesh corresponding to the Omega and Gamma domains:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"Ω = Inti.Domain(e -> Inti.geometric_dimension(e) == 2, msh)\nΓ = Inti.boundary(Ω)\nΩ_msh = view(msh, Ω)\nΓ_msh = view(msh, Γ)\nnothing #hide","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"and visualize them:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"using Meshes, GLMakie\nviz(Ω_msh; showsegments = true)\nviz!(Γ_msh; color = :red)\nMakie.current_figure() #hide","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"To conclude the geometric setup, we need a quadrature for the volume and boundary:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"Ω_quad = Inti.Quadrature(Ω_msh; qorder = 4)\nΓ_quad = Inti.Quadrature(Γ_msh; qorder = 6)\nnothing #hide","category":"page"},{"location":"pluto-examples/poisson/#Integral-operators","page":"Poisson problem","title":"Integral operators","text":"","category":"section"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"We can now assemble the required volume potential. To obtain the value of the particular solution u_p on the boundary for the modified integral equation above we will need the volume integral operator mapping to points on the boundary, i.e. operator:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"using FMM2D #to accelerate the maps\nop = Inti.Laplace(; dim = 2)\n# Newtonian potential mapping domain to boundary\nV_d2b = Inti.volume_potential(;\n    op,\n    target = Γ_quad,\n    source = Ω_quad,\n    compression = (method = :fmm, tol = 1e-12),\n    correction = (method = :dim, maxdist = 5 * meshsize, target_location = :on),\n)","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"We require also the boundary integral operators for the ensuing integral equation:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"# Single and double layer operators on Γ\nS_b2b, D_b2b = Inti.single_double_layer(;\n    op,\n    target = Γ_quad,\n    source = Γ_quad,\n    compression = (method = :fmm, tol = 1e-12),\n    correction = (method = :dim,),\n)","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"note: Note\nIn this example we used the Fast Multipole Method (:fmm) to accelerate the operators, and the Density Interpolation Method (:dim) to correct singular and nearly-singular integral.","category":"page"},{"location":"pluto-examples/poisson/#Solving-the-linear-system","page":"Poisson problem","title":"Solving the linear system","text":"","category":"section"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"We are now in a position to solve the original Poisson problem, but for that we need to specify the functions f and g. In order to verify that our numerical approximation is correct, however, we will play a different game and specify instead a manufactured solution u_e from which we will derive the functions f and g:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"# Create a manufactured solution\nuₑ = (x) -> cos(2 * x[1]) * sin(2 * x[2])\nfₑ = (x) -> 8 * cos(2 * x[1]) * sin(2 * x[2]) # -Δuₑ\ng = map(q -> uₑ(q.coords), Γ_quad)\nf = map(q -> fₑ(q.coords), Ω_quad)\nnothing #hide","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"With these, we can compute the right-hand-side of the integral equation for the homogeneous part of the solution:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"rhs = g - V_d2b * f\nnothing #hide","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"and solve the integral equation for the integral density function σ:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"using IterativeSolvers, LinearAlgebra\nσ = gmres(-I / 2 + D_b2b, rhs; abstol = 1e-8, verbose = true, restart = 1000)\nnothing #hide","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"With the density function at hand, we can now reconstruct our approximate solution:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"G = Inti.SingleLayerKernel(op)\ndG = Inti.DoubleLayerKernel(op)\n𝒱 = Inti.IntegralPotential(G, Ω_quad)\n𝒟 = Inti.IntegralPotential(dG, Γ_quad)\nu = (x) -> 𝒱[f](x) + 𝒟[σ](x)","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"and evaluate it at any point in the domain:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"x = Inti.Point2D(0.1, 0.4)\nprintln(\"error at $x: \", u(x) - uₑ(x))","category":"page"},{"location":"pluto-examples/poisson/#Solution-evaluation-and-visualization","page":"Poisson problem","title":"Solution evaluation and visualization","text":"","category":"section"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"Although we have \"solved\" the problem in the previous section, using the anonymous function u to evaluate the field is neither efficient nor accurate when there are either many points to evaluate, or when they lie close to the domain Omega. The fundamental reason for this is the usual: the integral operators in the function u are dense matrices, and their evaluation inside or near to Omega suffers from inaccurate singular and near-singular quadrature.","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"To address this issue, we need to assemble accelerated and corrected versions of the integral operators. Let us suppose we wish to evaluate the solution u at all the quadrature nodes of Omega:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"V_d2d = Inti.volume_potential(;\n    op,\n    target = Ω_quad,\n    source = Ω_quad,\n    compression = (method = :fmm, tol = 1e-8),\n    correction = (method = :dim,),\n)","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"Likewise, we need operators mapping densities from our boundary quadrature to our mesh nodes:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"We now evaluate the solution at all quadrature nodes and compare it to the manufactured:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"u_quad = V_d2d * f + D_b2d * σ\ner_quad = u_quad - map(q -> uₑ(q.coords), Ω_quad)\nprintln(\"maximum error at all quadrature nodes: \", norm(er_quad, Inf))\nnothing #hide","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"Lastly, let us visualize the solution and the error on the mesh nodes using quadrature_to_node_vals:","category":"page"},{"location":"pluto-examples/poisson/","page":"Poisson problem","title":"Poisson problem","text":"nodes = Inti.nodes(Ω_msh)\nu_nodes = Inti.quadrature_to_node_vals(Ω_quad, u_quad)\ner = u_nodes - map(uₑ, nodes)\ncolorrange = extrema(u_nodes)\nfig = Figure(; size = (800, 300))\nax = Axis(fig[1, 1]; aspect = DataAspect())\nviz!(Ω_msh; colorrange, color = u_nodes, interpolate = true)\ncb = Colorbar(fig[1, 2]; label = \"u\", colorrange)\n# plot error\nlog_er = log10.(abs.(er))\ncolorrange = extrema(log_er)\ncolormap = :inferno\nax = Axis(fig[1, 3]; aspect = DataAspect())\nviz!(Ω_msh; colorrange, colormap, color = log_er, interpolate = true)\ncb = Colorbar(fig[1, 4]; label = \"log₁₀|u - uₑ|\", colormap, colorrange)\nfig #hide","category":"page"},{"location":"tutorials/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"note: Important points covered in this tutorial\nCreate a domain and its accompanying mesh\nSolve a basic boundary integral equation\nVisualize the solution","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"This first tutorial will be a guided tour through the basic steps of setting up a boundary integral equation and solving it using Inti.jl.","category":"page"},{"location":"tutorials/getting_started/#Mathematical-formulation","page":"Getting started","title":"Mathematical formulation","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"We will consider the classic Helmholtz scattering problem in 2D, and solve it using a direct boundary integral formulation. More precisely, letting Omega subset mathbbR^2 be a bounded domain, and denoting by Gamma = partial Omega its boundary, we will solve the following Helmholtz problem:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"beginaligned\n    Delta u + k^2 u  = 0 quad textin quad mathbbR^2 setminus overlineOmega\n    partial_nu u = g quad texton quad Gamma\n    sqrtr left( fracpartial upartial r - i k u right) = o(1) quad textas quad r = boldsymbolx to infty\nendaligned","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"where g is the given boundary datum, nu is the outward unit normal to Gamma, and k is the constant wavenumber. The last condition is the Sommerfeld radiation condition, and is required to ensure the uniqueness of the solution; physically, it means that the solution sought should radiate energy towards infinity.","category":"page"},{"location":"tutorials/getting_started/#PDE,-geometry,-and-mesh","page":"Getting started","title":"PDE, geometry, and mesh","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"The first step is to define the PDE under consideration:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"using Inti\nInti.stack_weakdeps_env!() # shortcut to add all dependencies \n# PDE\nk = 2π\nop = Inti.Helmholtz(; dim = 2, k)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Next, we generate the geometry of the problem. For this tutorial, we will manually create parametric curves representing the boundary of the domain using the parametric_curve function:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"using StaticArrays # for SVector\n# Create the geometry as the union of a kite and a circle\nkite = Inti.parametric_curve(0.0, 1.0; labels = [\"kite\"]) do s\n    return SVector(2.5 + cos(2π * s[1]) + 0.65 * cos(4π * s[1]) - 0.65, 1.5 * sin(2π * s[1]))\nend\ncircle = Inti.parametric_curve(0.0, 1.0; labels = [\"circle\"]) do s\n    return SVector(cos(2π * s[1]), sin(2π * s[1]))\nend\nΓ = kite ∪ circle","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Inti.jl expects the parametrization of the curve to be a function mapping scalars to points in space represented by SVectors (defined in the StaticArrays package). The labels argument is optional, and can be used to identify the different parts of the boundary. The Domain object Γ represents the boundary of the geometry, and can be used to create a mesh:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# Create a mesh for the geometry\nmsh = Inti.meshgen(Γ; meshsize = 2π / k / 10)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"To visualize the mesh, we can load Meshes.jl and one of Makie's backends:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"using Meshes, GLMakie\nviz(msh; segmentsize = 3, axis = (aspect = DataAspect(), ), figure = (; size = (400,300)))","category":"page"},{"location":"tutorials/getting_started/#Quadrature","page":"Getting started","title":"Quadrature","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Once the mesh is created, we can define a quadrature to be used in the discretization of the integral operators:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# Create a quadrature\nQ = Inti.Quadrature(msh; qorder = 5)\nnothing # hide","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"A Quadrature is simply a collection of QuadratureNode objects:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Q[1]","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"In the constructor above we specified a quadrature order of 5, and Inti.jl internally picked a ReferenceQuadrature suitable for the specified order; for finer control, a quadrature rule can be specified directly.","category":"page"},{"location":"tutorials/getting_started/#Integral-operators","page":"Getting started","title":"Integral operators","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"To continue, we need to reformulate the Helmholtz problem as a boundary integral equation. Among the plethora of options, we will use in this tutorial a simple direct formulation, which uses Green's third identity to relate the values of u and partial_nu u on Gamma:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"    -fracu(boldsymbolx)2 + Du(boldsymbolx) = Spartial_nu u(boldsymbolx) quad boldsymbolx in Gamma","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Here S and D are the single- and double-layer operators, formally defined as:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"    Ssigma(boldsymbolx) = int_Gamma G(boldsymbolx boldsymboly) sigma(boldsymboly)  mathrmds(boldsymboly) quad\n    Dsigma(boldsymbolx) = int_Gamma fracpartial Gpartial nu_boldsymboly(boldsymbolx boldsymboly) sigma(boldsymboly)  mathrmds(boldsymboly)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"where","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"G(boldsymbolx boldsymboly) = fraci4 H^(1)_0(kboldsymbolx -\nboldsymboly)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"is the fundamental solution of the Helmholtz equation, with H^(1)_0 being the Hankel function of the first kind. Note that G is singular when boldsymbolx = boldsymboly, and therefore the numerical discretization of S and D requires special care.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"To approximate S and D, we can proceed as follows:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"S, D = Inti.single_double_layer(;\n    op,\n    target = Q,\n    source = Q,\n    compression = (method = :none,),\n    correction = (method = :dim,),\n)\nnothing # hide","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Much of the complexity involved in the numerical computation is hidden in the function above; later in the tutorials we will discuss in more details the options available for the compression and correction methods, as well as how to define custom kernels and operators. For now, it suffices to know that S and D are matrix-like objects that can be used to solve the boundary integral equation. For that, we need to provide the boundary data g.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"tip: Fast algorithms\nPowered by external libraries, Inti.jl supports several acceleration methods for matrix-vector multiplication. See the compression methods section for more details. Note that in such cases only the matrix-vector product may not be available, and therefore iterative solvers such as GMRES are required for the solution of the resulting linear systems.","category":"page"},{"location":"tutorials/getting_started/#Source-term-and-solution","page":"Getting started","title":"Source term and solution","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"We are interested in the scattered field u produced by an incident plane wave u_i = e^i k boldsymbold cdot boldsymbolx, where boldsymbold is a unit vector denoting the direction of the plane wave. Assuming that the total field u_t = u_i + u satisfies a homogenous Neumann condition on Gamma, and that the scattered field u satisfies the Sommerfeld radiation condition, we can write the boundary condition as:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"    partial_nu u = -partial_nu u_i quad boldsymbolx in Gamma","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"We can thus solve the boundary integral equation to find u on Gamma:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"using LinearAlgebra\n# define the incident field and compute its normal derivative\nθ = 0\nd = SVector(cos(θ), sin(θ))\ng = map(Q) do q\n    # normal derivative of e^{ik*d⃗⋅x}\n    x, ν = q.coords, q.normal\n    return -im * k * exp(im * k * dot(x, d)) * dot(d, ν)\nend ## Neumann trace on boundary\nu = (-I / 2 + D) \\ (S * g) # Dirichlet trace on boundary\nnothing # hide","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"note: Iterating over a quadrature\nIn computing g above, we used map to evaluate the incident field at   all quadrature nodes. When iterating over Q, the iterator returns a   QuadratureNode, and not simply the coordinate   of the quadrature node. This is so that we can access additional   information, such as the normal vector, at the quadrature node.","category":"page"},{"location":"tutorials/getting_started/#Integral-representation-and-visualization","page":"Getting started","title":"Integral representation and visualization","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Now that we know both the Dirichlet and Neumann data on the boundary, we can use Green's representation formula, i.e.,","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"    mathcalDu(boldsymbolr) - mathcalSpartial_nu u(boldsymbolr) = begincases\n        u(boldsymbolr)  textif  boldsymbolr in mathbbR^2 setminus overlineOmega\n        0  textif  boldsymbolr in Omega\n    endcases","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"where mathcalD and mathcalS are the double- and single-layer potentials defined as:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"    mathcalSsigma(boldsymbolr) = int_Gamma G(boldsymbolr boldsymboly) sigma(boldsymboly)  mathrmds(boldsymboly) quad\n    mathcalDsigma(boldsymbolr) = int_Gamma fracpartial Gpartial nu_boldsymboly(boldsymbolr boldsymboly) sigma(boldsymboly)  mathrmds(boldsymboly)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"to compute the solution u in the domain:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"𝒮, 𝒟 = Inti.single_double_layer_potential(; op, source = Q)\nuₛ = x -> 𝒟[u](x) - 𝒮[g](x)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"To wrap things up, let's visualize the scattered field:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"xx = yy = range(-5; stop = 5, length = 100)\nU = map(uₛ, Iterators.product(xx, yy))\nUi = map(x -> exp(im*k*dot(x, d)), Iterators.product(xx, yy))\nUt = Ui + U\nfig, ax, hm = heatmap(\n    xx,\n    yy,\n    real(Ut);\n    colormap = :inferno,\n    interpolate = true,\n    axis = (aspect = DataAspect(), xgridvisible = false, ygridvisible = false),\n)\nviz!(msh; segmentsize = 2)\nColorbar(fig[1, 2], hm; label = \"real(u)\")\nfig # hide","category":"page"},{"location":"tutorials/getting_started/#Accuracy-check","page":"Getting started","title":"Accuracy check","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"The scattering example above does not provide an easy way to check the accuracy of the solution. To do so, we can manufacture an exact solution and compare it to the solution obtained numerically, as illustrated below:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# build an exact solution\nG = Inti.SingleLayerKernel(op)\ndG = Inti.DoubleLayerKernel(op)\nxs = map(θ -> 0.5 * rand() * SVector(cos(θ), sin(θ)), 2π * rand(10))\ncs = rand(ComplexF64, length(xs))\nuₑ  = q -> sum(c * G(x, q) for (x, c) in zip(xs, cs))\n∂ₙu = q -> sum(c * dG(x, q) for (x, c) in zip(xs, cs))\ng  = map(∂ₙu, Q) \nu = (-I / 2 + D) \\ (S * g)\nuₛ = x -> 𝒟[u](x) - 𝒮[g](x)\npts = [5*SVector(cos(θ), sin(θ)) for θ in range(0, 2π, length = 100)]\ner = norm(uₛ.(pts) - uₑ.(pts), Inf)\nprintln(\"maximum error on circle of radius 5: $er\")","category":"page"},{"location":"#Inti","page":"Home","title":"Inti","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: codecov) (Image: Aqua)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Inti.jl is a Julia library for the numerical solution of boundary and volume integral equations. It offers routines for assembling and solving the linear systems that result from applying the Nyström discretization method. Designed for flexibility and efficiency, the package currently supports the following features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Specialized integration routines for computing singular and nearly-singular integrals.\nIntegrated support for acceleration routines, including the Fast Multipole Method (FMM) and Hierarchical Matrices, by wrapping external libraries.\nPredefined kernels and integral operators for partial differential equations (PDEs) commonly found in mathematical physics (e.g. Laplace, Helmholtz, Stokes).\nSupport for complex geometries in 2D and 3D, either through native parametric representations or by importing mesh files from external sources.\nEfficient construction of complex integral operators from simpler ones through lazy composition.","category":"page"},{"location":"#Installing-Julia","page":"Home","title":"Installing Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Download Julia from julialang.org, or use juliaup installer. We recommend using the latest stable version of Julia, although Inti.jl should work with >=v1.9.","category":"page"},{"location":"#Installing-Inti.jl","page":"Home","title":"Installing Inti.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Inti.jl is registered in the Julia General registry and can be installed by launching a Julia REPL and typing the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add Inti","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, one can install the latest version of Inti.jl from the main branch using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(;url = \"https://github.com/IntegralEquations/Inti.jl\", rev = \"main\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Change rev if a different branch or a specific commit hash is desired.","category":"page"},{"location":"#Installing-weak-dependencies","page":"Home","title":"Installing weak dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Inti.jl comes with a set of optional dependencies that can be installed on demand. These provide additional features which can be useful in certain scenarios (e.g. visualization, meshing, acceleration). For convenience, Inti.jl provides the stack_weakdeps_env! function to install all the weak dependencies at once:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Inti\nInti.stack_weakdeps_env!(; verbose = false, update = true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the first time you run this command, it may take a while to download and compile the dependencies. Subsequent runs will be faster. If preferred,  extensions can be manually controlled by Pkg.adding the desired packages from the list above.","category":"page"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Inti.jl can be used to solve a variety of linear partial differential equations by recasting them as integral equations. The general workflow for solving a problem consists of the following steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"    underbracefboxGeometry rightarrow fboxMesh_textbfpre-processing rightarrow colorredfboxSolver rightarrow underbracefboxVisualization_textbfpost-processing","category":"page"},{"location":"","page":"Home","title":"Home","text":"Geometry: Define the domain of interest using simple shapes (e.g., circles, rectangles) or more complex CAD models.\nMesh: Create a mesh to approximate the geometry. The mesh is used to define a quadrature and discretize the boundary integral equation.\nSolver: With a mesh and an accompanying quadrature, Inti.jl's routines provide ways to assemble and solve the system of equations arising from the discretization of the integral operators. The core of the library lies in service of this step.\nVisualization: Visualize the solution using a plotting library such as Makie.jl, or export it to a file for further analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As a simple example illustrating the steps above, consider an interior Laplace problem, in two dimensions, with Dirichlet boundary conditions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nDelta u = 0 quad textin  Omega \nu = g quad texton  Gamma\nendaligned","category":"page"},{"location":"","page":"Home","title":"Home","text":"where Omega subset mathbbR^2 is a sufficiently smooth domain, and Gamma = partial Omega its boundary. A boundary integral reformulation can be achieved by e.g. searching for the solution u in the form of a single-layer potential:","category":"page"},{"location":"","page":"Home","title":"Home","text":"u(boldsymbolr) = int_Gamma G(boldsymbolrboldsymboly)sigma(boldsymboly)  mathrmdGamma(boldsymboly)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where sigma  Gamma to mathbbR is an unknown density function, and G is the fundamental solution of the Laplace equation. This ansatz is, by construction, an exact solution to the PDE on Omega. Imposing the boundary condition on Gamma leads to the following integral equation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"    int_Gamma G(boldsymbolxboldsymboly)sigma(boldsymboly)  mathrmdGamma(boldsymboly) = g(boldsymbolx) quad forall boldsymbolx in Gamma","category":"page"},{"location":"","page":"Home","title":"Home","text":"Expressing the problem above in Inti.jl looks like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Inti, LinearAlgebra, StaticArrays\n# a parametric curve given by a function f : [0,1] → Γ ⊂ R^2. \ngeo = Inti.parametric_curve(0, 1) do s\n    SVector(0.25, 0.0) + SVector(cos(2π * s) + 0.65 * cos(4π * s[1]) - 0.65, 1.5 * sin(2π * s))\nend\nΓ = Inti.Domain(geo)\n# mesh and quadrature\nmsh = Inti.meshgen(Γ; meshsize = 0.1)\nQ = Inti.Quadrature(msh; qorder = 5)\n# integral operators\nop = Inti.Laplace(;dim=2)\nS, _ = Inti.single_double_layer(;\n    op, \n    target = Q,\n    source = Q,\n)\n# manufacture a harmonic function (exact solution) and take its trace on Γ\nuₑ = x -> x[1] + x[2] + x[1]*x[2] + x[1]^2 - x[2]^2  - 2 * log(norm(x .- SVector(-0.5, -1.5)))\ng = map(q -> uₑ(q.coords), Q) # value at quad nodes\n# solve for σ\nσ = S \\ g\n# use the single-layer potential to evaluate the solution\n𝒮, 𝒟 = Inti.single_double_layer_potential(; op, source = Q)\nuₕ = x -> 𝒮[σ](x)\npt = SVector(0.5, 0.1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The function uₕ is now a numerical approximation of the solution to the Laplace equation, and can be evaluated at any point in the domain:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pt = SVector(0.5, 0.1)\nprintln(\"Exact value at $pt:   \", uₑ(pt))\nprintln(\"Approx. value at $pt: \", uₕ(pt))","category":"page"},{"location":"","page":"Home","title":"Home","text":"If we care about the solution on the entire domain, we can visualize it using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Meshes, GLMakie # trigger the loading of some Inti extensions\nxx = yy = range(-2, 2, length = 100)\nfig = Figure(; size = (600,300))\ninside = x -> Inti.isinside(x, Q) \nopts = (xlabel = \"x\", ylabel = \"y\", aspect = DataAspect())\nax1 = Axis(fig[1, 1]; title = \"Exact solution\", opts...)\nh1 = heatmap!(ax1, xx,yy,(x, y) -> inside((x,y)) ? uₑ((x,y)) : NaN)\nviz!(msh; segmentsize = 3)\ncb = Colorbar(fig[1, 3], h1, size = 20, height = 200)\nax2 = Axis(fig[1, 2]; title = \"Approx. solution\", opts...)\nh2 = heatmap!(ax2, xx,yy, (x, y) -> inside((x,y)) ? uₕ((x,y)) : NaN, colorrange = cb.limits[])\nviz!(msh; segmentsize = 3)\nfig # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Formulation of the problem as an integral equation\nGiven a PDE and boundary conditions, there are often many ways to recast the problem as an integral equation, and the choice of formulation plays an important role in the unique solvability, efficiency, and accuracy of the numerical solution. Inti.jl provides a flexible framework for experimenting with different formulations, but it is up to the user to choose the most appropriate one for their problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"While the example above is a simple one, Inti.jl can handle significantly more complex problems involving multiple domains, heterogeneous coefficients, vector-valued PDEs, and three-dimensional geometries. The best way to dive deeper into Inti.jl's capabilities is the tutorials section. More advanced usage can be found in the examples section.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are several ways to contribute to Inti.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Reporting bugs: If you encounter a bug, please open an issue on the GitHub. If possible, please include a minimal working example that reproduces the problem.\nExamples: If you have a cool example that showcases Inti.jl's capabilities, consider submitting a PR to add it to the examples section.\nContributing code: If you would like to contribute code to Inti.jl, please fork the repository and submit a pull request. Feel free to open a draft PR early in the development process to get feedback on your changes.\nFeature requests: If you have an idea for a new feature or improvement, we would love to hear about it.\nDocumentation: If you find any part of the documentation unclear or incomplete, please let us know. Or even better, submit a PR with the improved documentation.","category":"page"}]
}
